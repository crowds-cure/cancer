(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}
},{}],2:[function(require,module,exports){
/*! cornerstone-core - 2.2.6 - 2018-09-24 | (c) 2016 Chris Hafey | https://github.com/cornerstonejs/cornerstone */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("cornerstone-core", [], factory);
	else if(typeof exports === 'object')
		exports["cornerstone-core"] = factory();
	else
		root["cornerstone"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "a4d4ad6f905736a5574a";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "cornerstone";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./index.js")(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./canvasToPixel.js":
/*!**************************!*\
  !*** ./canvasToPixel.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getTransform.js */ "./internal/getTransform.js");


/**
 * Converts a point in the canvas coordinate system to the pixel coordinate system
 * system.  This can be used to reset tools' image coordinates after modifications
 * have been made in canvas space (e.g. moving a tool by a few cm, independent of
 * image resolution).
 *
 * @param {HTMLElement} element The Cornerstone element within which the input point lies
 * @param {{x: Number, y: Number}} pt The input point in the canvas coordinate system
 *
 * @returns {{x: Number, y: Number}} The transformed point in the pixel coordinate system
 * @memberof PixelCoordinateSystem
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, pt) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var transform = Object(_internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement);
  transform.invert();
  return transform.transformPoint(pt.x, pt.y);
});

/***/ }),

/***/ "./colors/colormap.js":
/*!****************************!*\
  !*** ./colors/colormap.js ***!
  \****************************/
/*! exports provided: getColormapsList, getColormap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColormapsList", function() { return getColormapsList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColormap", function() { return getColormap; });
/* harmony import */ var _lookupTable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lookupTable.js */ "./colors/lookupTable.js");

var COLOR_TRANSPARENT = [0, 0, 0, 0]; // Colormaps
//
// Hot Iron, PET, Hot Metal Blue and PET 20 Step are color palettes
// Defined by the DICOM standard
// http://dicom.nema.org/dicom/2013/output/chtml/part06/chapter_B.html
//
// All Linear Segmented Colormaps were copied from matplotlib
// https://github.com/stefanv/matplotlib/blob/master/lib/matplotlib/_cm.py

var colormapsData = {
  hotIron: {
    name: 'Hot Iron',
    numOfColors: 256,
    colors: [[0, 0, 0, 255], [2, 0, 0, 255], [4, 0, 0, 255], [6, 0, 0, 255], [8, 0, 0, 255], [10, 0, 0, 255], [12, 0, 0, 255], [14, 0, 0, 255], [16, 0, 0, 255], [18, 0, 0, 255], [20, 0, 0, 255], [22, 0, 0, 255], [24, 0, 0, 255], [26, 0, 0, 255], [28, 0, 0, 255], [30, 0, 0, 255], [32, 0, 0, 255], [34, 0, 0, 255], [36, 0, 0, 255], [38, 0, 0, 255], [40, 0, 0, 255], [42, 0, 0, 255], [44, 0, 0, 255], [46, 0, 0, 255], [48, 0, 0, 255], [50, 0, 0, 255], [52, 0, 0, 255], [54, 0, 0, 255], [56, 0, 0, 255], [58, 0, 0, 255], [60, 0, 0, 255], [62, 0, 0, 255], [64, 0, 0, 255], [66, 0, 0, 255], [68, 0, 0, 255], [70, 0, 0, 255], [72, 0, 0, 255], [74, 0, 0, 255], [76, 0, 0, 255], [78, 0, 0, 255], [80, 0, 0, 255], [82, 0, 0, 255], [84, 0, 0, 255], [86, 0, 0, 255], [88, 0, 0, 255], [90, 0, 0, 255], [92, 0, 0, 255], [94, 0, 0, 255], [96, 0, 0, 255], [98, 0, 0, 255], [100, 0, 0, 255], [102, 0, 0, 255], [104, 0, 0, 255], [106, 0, 0, 255], [108, 0, 0, 255], [110, 0, 0, 255], [112, 0, 0, 255], [114, 0, 0, 255], [116, 0, 0, 255], [118, 0, 0, 255], [120, 0, 0, 255], [122, 0, 0, 255], [124, 0, 0, 255], [126, 0, 0, 255], [128, 0, 0, 255], [130, 0, 0, 255], [132, 0, 0, 255], [134, 0, 0, 255], [136, 0, 0, 255], [138, 0, 0, 255], [140, 0, 0, 255], [142, 0, 0, 255], [144, 0, 0, 255], [146, 0, 0, 255], [148, 0, 0, 255], [150, 0, 0, 255], [152, 0, 0, 255], [154, 0, 0, 255], [156, 0, 0, 255], [158, 0, 0, 255], [160, 0, 0, 255], [162, 0, 0, 255], [164, 0, 0, 255], [166, 0, 0, 255], [168, 0, 0, 255], [170, 0, 0, 255], [172, 0, 0, 255], [174, 0, 0, 255], [176, 0, 0, 255], [178, 0, 0, 255], [180, 0, 0, 255], [182, 0, 0, 255], [184, 0, 0, 255], [186, 0, 0, 255], [188, 0, 0, 255], [190, 0, 0, 255], [192, 0, 0, 255], [194, 0, 0, 255], [196, 0, 0, 255], [198, 0, 0, 255], [200, 0, 0, 255], [202, 0, 0, 255], [204, 0, 0, 255], [206, 0, 0, 255], [208, 0, 0, 255], [210, 0, 0, 255], [212, 0, 0, 255], [214, 0, 0, 255], [216, 0, 0, 255], [218, 0, 0, 255], [220, 0, 0, 255], [222, 0, 0, 255], [224, 0, 0, 255], [226, 0, 0, 255], [228, 0, 0, 255], [230, 0, 0, 255], [232, 0, 0, 255], [234, 0, 0, 255], [236, 0, 0, 255], [238, 0, 0, 255], [240, 0, 0, 255], [242, 0, 0, 255], [244, 0, 0, 255], [246, 0, 0, 255], [248, 0, 0, 255], [250, 0, 0, 255], [252, 0, 0, 255], [254, 0, 0, 255], [255, 0, 0, 255], [255, 2, 0, 255], [255, 4, 0, 255], [255, 6, 0, 255], [255, 8, 0, 255], [255, 10, 0, 255], [255, 12, 0, 255], [255, 14, 0, 255], [255, 16, 0, 255], [255, 18, 0, 255], [255, 20, 0, 255], [255, 22, 0, 255], [255, 24, 0, 255], [255, 26, 0, 255], [255, 28, 0, 255], [255, 30, 0, 255], [255, 32, 0, 255], [255, 34, 0, 255], [255, 36, 0, 255], [255, 38, 0, 255], [255, 40, 0, 255], [255, 42, 0, 255], [255, 44, 0, 255], [255, 46, 0, 255], [255, 48, 0, 255], [255, 50, 0, 255], [255, 52, 0, 255], [255, 54, 0, 255], [255, 56, 0, 255], [255, 58, 0, 255], [255, 60, 0, 255], [255, 62, 0, 255], [255, 64, 0, 255], [255, 66, 0, 255], [255, 68, 0, 255], [255, 70, 0, 255], [255, 72, 0, 255], [255, 74, 0, 255], [255, 76, 0, 255], [255, 78, 0, 255], [255, 80, 0, 255], [255, 82, 0, 255], [255, 84, 0, 255], [255, 86, 0, 255], [255, 88, 0, 255], [255, 90, 0, 255], [255, 92, 0, 255], [255, 94, 0, 255], [255, 96, 0, 255], [255, 98, 0, 255], [255, 100, 0, 255], [255, 102, 0, 255], [255, 104, 0, 255], [255, 106, 0, 255], [255, 108, 0, 255], [255, 110, 0, 255], [255, 112, 0, 255], [255, 114, 0, 255], [255, 116, 0, 255], [255, 118, 0, 255], [255, 120, 0, 255], [255, 122, 0, 255], [255, 124, 0, 255], [255, 126, 0, 255], [255, 128, 4, 255], [255, 130, 8, 255], [255, 132, 12, 255], [255, 134, 16, 255], [255, 136, 20, 255], [255, 138, 24, 255], [255, 140, 28, 255], [255, 142, 32, 255], [255, 144, 36, 255], [255, 146, 40, 255], [255, 148, 44, 255], [255, 150, 48, 255], [255, 152, 52, 255], [255, 154, 56, 255], [255, 156, 60, 255], [255, 158, 64, 255], [255, 160, 68, 255], [255, 162, 72, 255], [255, 164, 76, 255], [255, 166, 80, 255], [255, 168, 84, 255], [255, 170, 88, 255], [255, 172, 92, 255], [255, 174, 96, 255], [255, 176, 100, 255], [255, 178, 104, 255], [255, 180, 108, 255], [255, 182, 112, 255], [255, 184, 116, 255], [255, 186, 120, 255], [255, 188, 124, 255], [255, 190, 128, 255], [255, 192, 132, 255], [255, 194, 136, 255], [255, 196, 140, 255], [255, 198, 144, 255], [255, 200, 148, 255], [255, 202, 152, 255], [255, 204, 156, 255], [255, 206, 160, 255], [255, 208, 164, 255], [255, 210, 168, 255], [255, 212, 172, 255], [255, 214, 176, 255], [255, 216, 180, 255], [255, 218, 184, 255], [255, 220, 188, 255], [255, 222, 192, 255], [255, 224, 196, 255], [255, 226, 200, 255], [255, 228, 204, 255], [255, 230, 208, 255], [255, 232, 212, 255], [255, 234, 216, 255], [255, 236, 220, 255], [255, 238, 224, 255], [255, 240, 228, 255], [255, 242, 232, 255], [255, 244, 236, 255], [255, 246, 240, 255], [255, 248, 244, 255], [255, 250, 248, 255], [255, 252, 252, 255], [255, 255, 255, 255]]
  },
  pet: {
    name: 'PET',
    numColors: 256,
    colors: [[0, 0, 0, 255], [0, 2, 1, 255], [0, 4, 3, 255], [0, 6, 5, 255], [0, 8, 7, 255], [0, 10, 9, 255], [0, 12, 11, 255], [0, 14, 13, 255], [0, 16, 15, 255], [0, 18, 17, 255], [0, 20, 19, 255], [0, 22, 21, 255], [0, 24, 23, 255], [0, 26, 25, 255], [0, 28, 27, 255], [0, 30, 29, 255], [0, 32, 31, 255], [0, 34, 33, 255], [0, 36, 35, 255], [0, 38, 37, 255], [0, 40, 39, 255], [0, 42, 41, 255], [0, 44, 43, 255], [0, 46, 45, 255], [0, 48, 47, 255], [0, 50, 49, 255], [0, 52, 51, 255], [0, 54, 53, 255], [0, 56, 55, 255], [0, 58, 57, 255], [0, 60, 59, 255], [0, 62, 61, 255], [0, 65, 63, 255], [0, 67, 65, 255], [0, 69, 67, 255], [0, 71, 69, 255], [0, 73, 71, 255], [0, 75, 73, 255], [0, 77, 75, 255], [0, 79, 77, 255], [0, 81, 79, 255], [0, 83, 81, 255], [0, 85, 83, 255], [0, 87, 85, 255], [0, 89, 87, 255], [0, 91, 89, 255], [0, 93, 91, 255], [0, 95, 93, 255], [0, 97, 95, 255], [0, 99, 97, 255], [0, 101, 99, 255], [0, 103, 101, 255], [0, 105, 103, 255], [0, 107, 105, 255], [0, 109, 107, 255], [0, 111, 109, 255], [0, 113, 111, 255], [0, 115, 113, 255], [0, 117, 115, 255], [0, 119, 117, 255], [0, 121, 119, 255], [0, 123, 121, 255], [0, 125, 123, 255], [0, 128, 125, 255], [1, 126, 127, 255], [3, 124, 129, 255], [5, 122, 131, 255], [7, 120, 133, 255], [9, 118, 135, 255], [11, 116, 137, 255], [13, 114, 139, 255], [15, 112, 141, 255], [17, 110, 143, 255], [19, 108, 145, 255], [21, 106, 147, 255], [23, 104, 149, 255], [25, 102, 151, 255], [27, 100, 153, 255], [29, 98, 155, 255], [31, 96, 157, 255], [33, 94, 159, 255], [35, 92, 161, 255], [37, 90, 163, 255], [39, 88, 165, 255], [41, 86, 167, 255], [43, 84, 169, 255], [45, 82, 171, 255], [47, 80, 173, 255], [49, 78, 175, 255], [51, 76, 177, 255], [53, 74, 179, 255], [55, 72, 181, 255], [57, 70, 183, 255], [59, 68, 185, 255], [61, 66, 187, 255], [63, 64, 189, 255], [65, 63, 191, 255], [67, 61, 193, 255], [69, 59, 195, 255], [71, 57, 197, 255], [73, 55, 199, 255], [75, 53, 201, 255], [77, 51, 203, 255], [79, 49, 205, 255], [81, 47, 207, 255], [83, 45, 209, 255], [85, 43, 211, 255], [86, 41, 213, 255], [88, 39, 215, 255], [90, 37, 217, 255], [92, 35, 219, 255], [94, 33, 221, 255], [96, 31, 223, 255], [98, 29, 225, 255], [100, 27, 227, 255], [102, 25, 229, 255], [104, 23, 231, 255], [106, 21, 233, 255], [108, 19, 235, 255], [110, 17, 237, 255], [112, 15, 239, 255], [114, 13, 241, 255], [116, 11, 243, 255], [118, 9, 245, 255], [120, 7, 247, 255], [122, 5, 249, 255], [124, 3, 251, 255], [126, 1, 253, 255], [128, 0, 255, 255], [130, 2, 252, 255], [132, 4, 248, 255], [134, 6, 244, 255], [136, 8, 240, 255], [138, 10, 236, 255], [140, 12, 232, 255], [142, 14, 228, 255], [144, 16, 224, 255], [146, 18, 220, 255], [148, 20, 216, 255], [150, 22, 212, 255], [152, 24, 208, 255], [154, 26, 204, 255], [156, 28, 200, 255], [158, 30, 196, 255], [160, 32, 192, 255], [162, 34, 188, 255], [164, 36, 184, 255], [166, 38, 180, 255], [168, 40, 176, 255], [170, 42, 172, 255], [171, 44, 168, 255], [173, 46, 164, 255], [175, 48, 160, 255], [177, 50, 156, 255], [179, 52, 152, 255], [181, 54, 148, 255], [183, 56, 144, 255], [185, 58, 140, 255], [187, 60, 136, 255], [189, 62, 132, 255], [191, 64, 128, 255], [193, 66, 124, 255], [195, 68, 120, 255], [197, 70, 116, 255], [199, 72, 112, 255], [201, 74, 108, 255], [203, 76, 104, 255], [205, 78, 100, 255], [207, 80, 96, 255], [209, 82, 92, 255], [211, 84, 88, 255], [213, 86, 84, 255], [215, 88, 80, 255], [217, 90, 76, 255], [219, 92, 72, 255], [221, 94, 68, 255], [223, 96, 64, 255], [225, 98, 60, 255], [227, 100, 56, 255], [229, 102, 52, 255], [231, 104, 48, 255], [233, 106, 44, 255], [235, 108, 40, 255], [237, 110, 36, 255], [239, 112, 32, 255], [241, 114, 28, 255], [243, 116, 24, 255], [245, 118, 20, 255], [247, 120, 16, 255], [249, 122, 12, 255], [251, 124, 8, 255], [253, 126, 4, 255], [255, 128, 0, 255], [255, 130, 4, 255], [255, 132, 8, 255], [255, 134, 12, 255], [255, 136, 16, 255], [255, 138, 20, 255], [255, 140, 24, 255], [255, 142, 28, 255], [255, 144, 32, 255], [255, 146, 36, 255], [255, 148, 40, 255], [255, 150, 44, 255], [255, 152, 48, 255], [255, 154, 52, 255], [255, 156, 56, 255], [255, 158, 60, 255], [255, 160, 64, 255], [255, 162, 68, 255], [255, 164, 72, 255], [255, 166, 76, 255], [255, 168, 80, 255], [255, 170, 85, 255], [255, 172, 89, 255], [255, 174, 93, 255], [255, 176, 97, 255], [255, 178, 101, 255], [255, 180, 105, 255], [255, 182, 109, 255], [255, 184, 113, 255], [255, 186, 117, 255], [255, 188, 121, 255], [255, 190, 125, 255], [255, 192, 129, 255], [255, 194, 133, 255], [255, 196, 137, 255], [255, 198, 141, 255], [255, 200, 145, 255], [255, 202, 149, 255], [255, 204, 153, 255], [255, 206, 157, 255], [255, 208, 161, 255], [255, 210, 165, 255], [255, 212, 170, 255], [255, 214, 174, 255], [255, 216, 178, 255], [255, 218, 182, 255], [255, 220, 186, 255], [255, 222, 190, 255], [255, 224, 194, 255], [255, 226, 198, 255], [255, 228, 202, 255], [255, 230, 206, 255], [255, 232, 210, 255], [255, 234, 214, 255], [255, 236, 218, 255], [255, 238, 222, 255], [255, 240, 226, 255], [255, 242, 230, 255], [255, 244, 234, 255], [255, 246, 238, 255], [255, 248, 242, 255], [255, 250, 246, 255], [255, 252, 250, 255], [255, 255, 255, 255]]
  },
  hotMetalBlue: {
    name: 'Hot Metal Blue',
    numColors: 256,
    colors: [[0, 0, 0, 255], [0, 0, 2, 255], [0, 0, 4, 255], [0, 0, 6, 255], [0, 0, 8, 255], [0, 0, 10, 255], [0, 0, 12, 255], [0, 0, 14, 255], [0, 0, 16, 255], [0, 0, 17, 255], [0, 0, 19, 255], [0, 0, 21, 255], [0, 0, 23, 255], [0, 0, 25, 255], [0, 0, 27, 255], [0, 0, 29, 255], [0, 0, 31, 255], [0, 0, 33, 255], [0, 0, 35, 255], [0, 0, 37, 255], [0, 0, 39, 255], [0, 0, 41, 255], [0, 0, 43, 255], [0, 0, 45, 255], [0, 0, 47, 255], [0, 0, 49, 255], [0, 0, 51, 255], [0, 0, 53, 255], [0, 0, 55, 255], [0, 0, 57, 255], [0, 0, 59, 255], [0, 0, 61, 255], [0, 0, 63, 255], [0, 0, 65, 255], [0, 0, 67, 255], [0, 0, 69, 255], [0, 0, 71, 255], [0, 0, 73, 255], [0, 0, 75, 255], [0, 0, 77, 255], [0, 0, 79, 255], [0, 0, 81, 255], [0, 0, 83, 255], [0, 0, 84, 255], [0, 0, 86, 255], [0, 0, 88, 255], [0, 0, 90, 255], [0, 0, 92, 255], [0, 0, 94, 255], [0, 0, 96, 255], [0, 0, 98, 255], [0, 0, 100, 255], [0, 0, 102, 255], [0, 0, 104, 255], [0, 0, 106, 255], [0, 0, 108, 255], [0, 0, 110, 255], [0, 0, 112, 255], [0, 0, 114, 255], [0, 0, 116, 255], [0, 0, 117, 255], [0, 0, 119, 255], [0, 0, 121, 255], [0, 0, 123, 255], [0, 0, 125, 255], [0, 0, 127, 255], [0, 0, 129, 255], [0, 0, 131, 255], [0, 0, 133, 255], [0, 0, 135, 255], [0, 0, 137, 255], [0, 0, 139, 255], [0, 0, 141, 255], [0, 0, 143, 255], [0, 0, 145, 255], [0, 0, 147, 255], [0, 0, 149, 255], [0, 0, 151, 255], [0, 0, 153, 255], [0, 0, 155, 255], [0, 0, 157, 255], [0, 0, 159, 255], [0, 0, 161, 255], [0, 0, 163, 255], [0, 0, 165, 255], [0, 0, 167, 255], [3, 0, 169, 255], [6, 0, 171, 255], [9, 0, 173, 255], [12, 0, 175, 255], [15, 0, 177, 255], [18, 0, 179, 255], [21, 0, 181, 255], [24, 0, 183, 255], [26, 0, 184, 255], [29, 0, 186, 255], [32, 0, 188, 255], [35, 0, 190, 255], [38, 0, 192, 255], [41, 0, 194, 255], [44, 0, 196, 255], [47, 0, 198, 255], [50, 0, 200, 255], [52, 0, 197, 255], [55, 0, 194, 255], [57, 0, 191, 255], [59, 0, 188, 255], [62, 0, 185, 255], [64, 0, 182, 255], [66, 0, 179, 255], [69, 0, 176, 255], [71, 0, 174, 255], [74, 0, 171, 255], [76, 0, 168, 255], [78, 0, 165, 255], [81, 0, 162, 255], [83, 0, 159, 255], [85, 0, 156, 255], [88, 0, 153, 255], [90, 0, 150, 255], [93, 2, 144, 255], [96, 4, 138, 255], [99, 6, 132, 255], [102, 8, 126, 255], [105, 9, 121, 255], [108, 11, 115, 255], [111, 13, 109, 255], [114, 15, 103, 255], [116, 17, 97, 255], [119, 19, 91, 255], [122, 21, 85, 255], [125, 23, 79, 255], [128, 24, 74, 255], [131, 26, 68, 255], [134, 28, 62, 255], [137, 30, 56, 255], [140, 32, 50, 255], [143, 34, 47, 255], [146, 36, 44, 255], [149, 38, 41, 255], [152, 40, 38, 255], [155, 41, 35, 255], [158, 43, 32, 255], [161, 45, 29, 255], [164, 47, 26, 255], [166, 49, 24, 255], [169, 51, 21, 255], [172, 53, 18, 255], [175, 55, 15, 255], [178, 56, 12, 255], [181, 58, 9, 255], [184, 60, 6, 255], [187, 62, 3, 255], [190, 64, 0, 255], [194, 66, 0, 255], [198, 68, 0, 255], [201, 70, 0, 255], [205, 72, 0, 255], [209, 73, 0, 255], [213, 75, 0, 255], [217, 77, 0, 255], [221, 79, 0, 255], [224, 81, 0, 255], [228, 83, 0, 255], [232, 85, 0, 255], [236, 87, 0, 255], [240, 88, 0, 255], [244, 90, 0, 255], [247, 92, 0, 255], [251, 94, 0, 255], [255, 96, 0, 255], [255, 98, 3, 255], [255, 100, 6, 255], [255, 102, 9, 255], [255, 104, 12, 255], [255, 105, 15, 255], [255, 107, 18, 255], [255, 109, 21, 255], [255, 111, 24, 255], [255, 113, 26, 255], [255, 115, 29, 255], [255, 117, 32, 255], [255, 119, 35, 255], [255, 120, 38, 255], [255, 122, 41, 255], [255, 124, 44, 255], [255, 126, 47, 255], [255, 128, 50, 255], [255, 130, 53, 255], [255, 132, 56, 255], [255, 134, 59, 255], [255, 136, 62, 255], [255, 137, 65, 255], [255, 139, 68, 255], [255, 141, 71, 255], [255, 143, 74, 255], [255, 145, 76, 255], [255, 147, 79, 255], [255, 149, 82, 255], [255, 151, 85, 255], [255, 152, 88, 255], [255, 154, 91, 255], [255, 156, 94, 255], [255, 158, 97, 255], [255, 160, 100, 255], [255, 162, 103, 255], [255, 164, 106, 255], [255, 166, 109, 255], [255, 168, 112, 255], [255, 169, 115, 255], [255, 171, 118, 255], [255, 173, 121, 255], [255, 175, 124, 255], [255, 177, 126, 255], [255, 179, 129, 255], [255, 181, 132, 255], [255, 183, 135, 255], [255, 184, 138, 255], [255, 186, 141, 255], [255, 188, 144, 255], [255, 190, 147, 255], [255, 192, 150, 255], [255, 194, 153, 255], [255, 196, 156, 255], [255, 198, 159, 255], [255, 200, 162, 255], [255, 201, 165, 255], [255, 203, 168, 255], [255, 205, 171, 255], [255, 207, 174, 255], [255, 209, 176, 255], [255, 211, 179, 255], [255, 213, 182, 255], [255, 215, 185, 255], [255, 216, 188, 255], [255, 218, 191, 255], [255, 220, 194, 255], [255, 222, 197, 255], [255, 224, 200, 255], [255, 226, 203, 255], [255, 228, 206, 255], [255, 229, 210, 255], [255, 231, 213, 255], [255, 233, 216, 255], [255, 235, 219, 255], [255, 237, 223, 255], [255, 239, 226, 255], [255, 240, 229, 255], [255, 242, 232, 255], [255, 244, 236, 255], [255, 246, 239, 255], [255, 248, 242, 255], [255, 250, 245, 255], [255, 251, 249, 255], [255, 253, 252, 255], [255, 255, 255, 255]]
  },
  pet20Step: {
    name: 'PET 20 Step',
    numColors: 256,
    colors: [[0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255]]
  },
  gray: {
    name: 'Gray',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [1, 1, 1]],
      green: [[0, 0, 0], [1, 1, 1]],
      blue: [[0, 0, 0], [1, 1, 1]]
    }
  },
  jet: {
    name: 'Jet',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [0.35, 0, 0], [0.66, 1, 1], [0.89, 1, 1], [1, 0.5, 0.5]],
      green: [[0, 0, 0], [0.125, 0, 0], [0.375, 1, 1], [0.64, 1, 1], [0.91, 0, 0], [1, 0, 0]],
      blue: [[0, 0.5, 0.5], [0.11, 1, 1], [0.34, 1, 1], [0.65, 0, 0], [1, 0, 0]]
    }
  },
  hsv: {
    name: 'HSV',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 1, 1], [0.158730, 1, 1], [0.174603, 0.968750, 0.968750], [0.333333, 0.031250, 0.031250], [0.349206, 0, 0], [0.666667, 0, 0], [0.682540, 0.031250, 0.031250], [0.841270, 0.968750, 0.968750], [0.857143, 1, 1], [1, 1, 1]],
      green: [[0, 0, 0], [0.158730, 0.937500, 0.937500], [0.174603, 1, 1], [0.507937, 1, 1], [0.666667, 0.062500, 0.062500], [0.682540, 0, 0], [1, 0, 0]],
      blue: [[0, 0, 0], [0.333333, 0, 0], [0.349206, 0.062500, 0.062500], [0.507937, 1, 1], [0.841270, 1, 1], [0.857143, 0.937500, 0.937500], [1, 0.09375, 0.09375]]
    }
  },
  hot: {
    name: 'Hot',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0.0416, 0.0416], [0.365079, 1, 1], [1, 1, 1]],
      green: [[0, 0, 0], [0.365079, 0, 0], [0.746032, 1, 1], [1, 1, 1]],
      blue: [[0, 0, 0], [0.746032, 0, 0], [1, 1, 1]]
    }
  },
  cool: {
    name: 'Cool',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [1, 1, 1]],
      green: [[0, 1, 1], [1, 0, 0]],
      blue: [[0, 1, 1], [1, 1, 1]]
    }
  },
  spring: {
    name: 'Spring',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 1, 1], [1, 1, 1]],
      green: [[0, 0, 0], [1, 1, 1]],
      blue: [[0, 1, 1], [1, 0, 0]]
    }
  },
  summer: {
    name: 'Summer',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [1, 1, 1]],
      green: [[0, 0.5, 0.5], [1, 1, 1]],
      blue: [[0, 0.4, 0.4], [1, 0.4, 0.4]]
    }
  },
  autumn: {
    name: 'Autumn',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 1, 1], [1, 1, 1]],
      green: [[0, 0, 0], [1, 1, 1]],
      blue: [[0, 0, 0], [1, 0, 0]]
    }
  },
  winter: {
    name: 'Winter',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [1, 0, 0]],
      green: [[0, 0, 0], [1, 1, 1]],
      blue: [[0, 1, 1], [1, 0.5, 0.5]]
    }
  },
  bone: {
    name: 'Bone',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [0.746032, 0.652778, 0.652778], [1, 1, 1]],
      green: [[0, 0, 0], [0.365079, 0.319444, 0.319444], [0.746032, 0.777778, 0.777778], [1, 1, 1]],
      blue: [[0, 0, 0], [0.365079, 0.444444, 0.444444], [1, 1, 1]]
    }
  },
  copper: {
    name: 'Copper',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [0.809524, 1, 1], [1, 1, 1]],
      green: [[0, 0, 0], [1, 0.7812, 0.7812]],
      blue: [[0, 0, 0], [1, 0.4975, 0.4975]]
    }
  },
  spectral: {
    name: 'Spectral',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0, 0], [0.05, 0.4667, 0.4667], [0.10, 0.5333, 0.5333], [0.15, 0, 0], [0.20, 0, 0], [0.25, 0, 0], [0.30, 0, 0], [0.35, 0, 0], [0.40, 0, 0], [0.45, 0, 0], [0.50, 0, 0], [0.55, 0, 0], [0.60, 0, 0], [0.65, 0.7333, 0.7333], [0.70, 0.9333, 0.9333], [0.75, 1, 1], [0.80, 1, 1], [0.85, 1, 1], [0.90, 0.8667, 0.8667], [0.95, 0.80, 0.80], [1, 0.80, 0.80]],
      green: [[0, 0, 0], [0.05, 0, 0], [0.10, 0, 0], [0.15, 0, 0], [0.20, 0, 0], [0.25, 0.4667, 0.4667], [0.30, 0.6000, 0.6000], [0.35, 0.6667, 0.6667], [0.40, 0.6667, 0.6667], [0.45, 0.6000, 0.6000], [0.50, 0.7333, 0.7333], [0.55, 0.8667, 0.8667], [0.60, 1, 1], [0.65, 1, 1], [0.70, 0.9333, 0.9333], [0.75, 0.8000, 0.8000], [0.80, 0.6000, 0.6000], [0.85, 0, 0], [0.90, 0, 0], [0.95, 0, 0], [1, 0.80, 0.80]],
      blue: [[0, 0, 0], [0.05, 0.5333, 0.5333], [0.10, 0.6000, 0.6000], [0.15, 0.6667, 0.6667], [0.20, 0.8667, 0.8667], [0.25, 0.8667, 0.8667], [0.30, 0.8667, 0.8667], [0.35, 0.6667, 0.6667], [0.40, 0.5333, 0.5333], [0.45, 0, 0], [0.5, 0, 0], [0.55, 0, 0], [0.60, 0, 0], [0.65, 0, 0], [0.70, 0, 0], [0.75, 0, 0], [0.80, 0, 0], [0.85, 0, 0], [0.90, 0, 0], [0.95, 0, 0], [1, 0.80, 0.80]]
    }
  },
  coolwarm: {
    name: 'CoolWarm',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0.2298057, 0.2298057], [0.03125, 0.26623388, 0.26623388], [0.0625, 0.30386891, 0.30386891], [0.09375, 0.342804478, 0.342804478], [0.125, 0.38301334, 0.38301334], [0.15625, 0.424369608, 0.424369608], [0.1875, 0.46666708, 0.46666708], [0.21875, 0.509635204, 0.509635204], [0.25, 0.552953156, 0.552953156], [0.28125, 0.596262162, 0.596262162], [0.3125, 0.639176211, 0.639176211], [0.34375, 0.681291281, 0.681291281], [0.375, 0.722193294, 0.722193294], [0.40625, 0.761464949, 0.761464949], [0.4375, 0.798691636, 0.798691636], [0.46875, 0.833466556, 0.833466556], [0.5, 0.865395197, 0.865395197], [0.53125, 0.897787179, 0.897787179], [0.5625, 0.924127593, 0.924127593], [0.59375, 0.944468518, 0.944468518], [0.625, 0.958852946, 0.958852946], [0.65625, 0.96732803, 0.96732803], [0.6875, 0.969954137, 0.969954137], [0.71875, 0.966811177, 0.966811177], [0.75, 0.958003065, 0.958003065], [0.78125, 0.943660866, 0.943660866], [0.8125, 0.923944917, 0.923944917], [0.84375, 0.89904617, 0.89904617], [0.875, 0.869186849, 0.869186849], [0.90625, 0.834620542, 0.834620542], [0.9375, 0.795631745, 0.795631745], [0.96875, 0.752534934, 0.752534934], [1, 0.705673158, 0.705673158]],
      green: [[0, 0.298717966, 0.298717966], [0.03125, 0.353094838, 0.353094838], [0.0625, 0.406535296, 0.406535296], [0.09375, 0.458757618, 0.458757618], [0.125, 0.50941904, 0.50941904], [0.15625, 0.558148092, 0.558148092], [0.1875, 0.604562568, 0.604562568], [0.21875, 0.648280772, 0.648280772], [0.25, 0.688929332, 0.688929332], [0.28125, 0.726149107, 0.726149107], [0.3125, 0.759599947, 0.759599947], [0.34375, 0.788964712, 0.788964712], [0.375, 0.813952739, 0.813952739], [0.40625, 0.834302879, 0.834302879], [0.4375, 0.849786142, 0.849786142], [0.46875, 0.860207984, 0.860207984], [0.5, 0.86541021, 0.86541021], [0.53125, 0.848937047, 0.848937047], [0.5625, 0.827384882, 0.827384882], [0.59375, 0.800927443, 0.800927443], [0.625, 0.769767752, 0.769767752], [0.65625, 0.734132809, 0.734132809], [0.6875, 0.694266682, 0.694266682], [0.71875, 0.650421156, 0.650421156], [0.75, 0.602842431, 0.602842431], [0.78125, 0.551750968, 0.551750968], [0.8125, 0.49730856, 0.49730856], [0.84375, 0.439559467, 0.439559467], [0.875, 0.378313092, 0.378313092], [0.90625, 0.312874446, 0.312874446], [0.9375, 0.24128379, 0.24128379], [0.96875, 0.157246067, 0.157246067], [1, 0.01555616, 0.01555616]],
      blue: [[0, 0.753683153, 0.753683153], [0.03125, 0.801466763, 0.801466763], [0.0625, 0.84495867, 0.84495867], [0.09375, 0.883725899, 0.883725899], [0.125, 0.917387822, 0.917387822], [0.15625, 0.945619588, 0.945619588], [0.1875, 0.968154911, 0.968154911], [0.21875, 0.98478814, 0.98478814], [0.25, 0.995375608, 0.995375608], [0.28125, 0.999836203, 0.999836203], [0.3125, 0.998151185, 0.998151185], [0.34375, 0.990363227, 0.990363227], [0.375, 0.976574709, 0.976574709], [0.40625, 0.956945269, 0.956945269], [0.4375, 0.931688648, 0.931688648], [0.46875, 0.901068838, 0.901068838], [0.5, 0.865395561, 0.865395561], [0.53125, 0.820880546, 0.820880546], [0.5625, 0.774508472, 0.774508472], [0.59375, 0.726736146, 0.726736146], [0.625, 0.678007945, 0.678007945], [0.65625, 0.628751763, 0.628751763], [0.6875, 0.579375448, 0.579375448], [0.71875, 0.530263762, 0.530263762], [0.75, 0.481775914, 0.481775914], [0.78125, 0.434243684, 0.434243684], [0.8125, 0.387970225, 0.387970225], [0.84375, 0.343229596, 0.343229596], [0.875, 0.300267182, 0.300267182], [0.90625, 0.259301199, 0.259301199], [0.9375, 0.220525627, 0.220525627], [0.96875, 0.184115123, 0.184115123], [1, 0.150232812, 0.150232812]]
    }
  },
  blues: {
    name: 'Blues',
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [[0, 0.9686274528503418, 0.9686274528503418], [0.125, 0.87058824300765991, 0.87058824300765991], [0.25, 0.7764706015586853, 0.7764706015586853], [0.375, 0.61960786581039429, 0.61960786581039429], [0.5, 0.41960784792900085, 0.41960784792900085], [0.625, 0.25882354378700256, 0.25882354378700256], [0.75, 0.12941177189350128, 0.12941177189350128], [0.875, 0.031372550874948502, 0.031372550874948502], [1, 0.031372550874948502, 0.031372550874948502]],
      green: [[0, 0.9843137264251709, 0.9843137264251709], [0.125, 0.92156863212585449, 0.92156863212585449], [0.25, 0.85882353782653809, 0.85882353782653809], [0.375, 0.7921568751335144, 0.7921568751335144], [0.5, 0.68235296010971069, 0.68235296010971069], [0.625, 0.57254904508590698, 0.57254904508590698], [0.75, 0.44313725829124451, 0.44313725829124451], [0.875, 0.31764706969261169, 0.31764706969261169], [1, 0.18823529779911041, 0.18823529779911041]],
      blue: [[0, 1, 1], [0.125, 0.9686274528503418, 0.9686274528503418], [0.25, 0.93725490570068359, 0.93725490570068359], [0.375, 0.88235294818878174, 0.88235294818878174], [0.5, 0.83921569585800171, 0.83921569585800171], [0.625, 0.7764706015586853, 0.7764706015586853], [0.75, 0.70980393886566162, 0.70980393886566162], [0.875, 0.61176472902297974, 0.61176472902297974], [1, 0.41960784792900085, 0.41960784792900085]]
    }
  }
};
/**
 *  Generate linearly spaced vectors
*  http://cens.ioc.ee/local/man/matlab/techdoc/ref/linspace.html
 * @param {Number} a A number representing the first vector
 * @param {Number} b A number representing the second vector
 * @param {Number} n The number of linear spaced vectors to generate
 * @returns {Array} An array of points representing linear spaced vectors.
 * @memberof Colors
 */

function linspace(a, b, n) {
  n = n === null ? 100 : n;
  var increment = (b - a) / (n - 1);
  var vector = [];

  while (n-- > 0) {
    vector.push(a);
    a += increment;
  } // Make sure the last item will always be "b" because most of the
  // Time we'll get numbers like 1.0000000000000002 instead of 1.


  vector[vector.length - 1] = b;
  return vector;
}
/**
 * Returns the "rank/index" of the element in a sorted array if found or the highest index if not. Uses (binary search)
 * @param {Array} array A sorted array to search in
 * @param {any} elem the element in the array to search for
 * @returns {number} The rank/index of the element in the given array
 * @memberof Colors
 */


function getRank(array, elem) {
  var left = 0;
  var right = array.length - 1;

  while (left <= right) {
    var mid = left + Math.floor((right - left) / 2);
    var midElem = array[mid];

    if (midElem === elem) {
      return mid;
    } else if (elem < midElem) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return left;
}
/**
 * Find the indices into a sorted array a such that, if the corresponding elements
 * In v were inserted before the indices, the order of a would be preserved.
 *  http://lagrange.univ-lyon1.fr/docs/numpy/1.11.0/reference/generated/numpy.searchsorted.html
 * @param {Array} inputArray The array where the values will be inserted
 * @param {Array} values An array of the values to be inserted into the inputArray
 * @returns {Array} The indices where elements should be inserted to maintain order.
 * @memberof Colors
 */


function searchSorted(inputArray, values) {
  var i;
  var indexes = [];
  var len = values.length;
  inputArray.sort(function (a, b) {
    return a - b;
  });

  for (i = 0; i < len; i++) {
    indexes[i] = getRank(inputArray, values[i]);
  }

  return indexes;
}
/**
 * Creates an *N* -element 1-d lookup table
 * @param {Number} N The number of elements in the result lookup table
 * @param {Array} data represented by a list of x,y0,y1 mapping correspondences. Each element in this
 * List represents how a value between 0 and 1 (inclusive) represented by x is mapped to
 * A corresponding value between 0 and 1 (inclusive). The two values of y are to allow for
 * Discontinuous mapping functions (say as might be found in a sawtooth) where y0 represents
 * The value of y for values of x <= to that given, and y1 is the value to be used for x >
 * Than that given). The list must start with x=0, end with x=1, and all values of x must be
 * In increasing order. Values between the given mapping points are determined by simple linear
 * Interpolation.
 * @param {any} gamma value denotes a "gamma curve" value which adjusts the brightness
 * at the bottom and top of the map.
 * @returns {any[]} an array "result" where result[x*(N-1)] gives the closest value for
 * Values of x between 0 and 1.
 * @memberof Colors
 */


function makeMappingArray(N, data, gamma) {
  var i;
  var x = [];
  var y0 = [];
  var y1 = [];
  var lut = [];
  gamma = gamma === null ? 1 : gamma;

  for (i = 0; i < data.length; i++) {
    var element = data[i];
    x.push((N - 1) * element[0]);
    y0.push(element[1]);
    y1.push(element[1]);
  }

  var xLinSpace = linspace(0, 1, N);

  for (i = 0; i < N; i++) {
    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);
  }

  var xLinSpaceIndexes = searchSorted(x, xLinSpace);

  for (i = 1; i < N - 1; i++) {
    var index = xLinSpaceIndexes[i];
    var colorPercent = (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);
    var colorDelta = y0[index] - y1[index - 1];
    lut[i] = colorPercent * colorDelta + y1[index - 1];
  }

  lut[0] = y1[0];
  lut[N - 1] = y0[data.length - 1];
  return lut;
}
/**
 * Creates a Colormap based on lookup tables using linear segments.
 * @param {{red:Array, green:Array, blue:Array}} segmentedData An object with a red, green and blue entries.
 * Each entry should be a list of x, y0, y1 tuples, forming rows in a table.
 * @param {Number} N The number of elements in the result Colormap
 * @param {any} gamma value denotes a "gamma curve" value which adjusts the brightness
 * at the bottom and top of the Colormap.
 * @returns {Array} The created Colormap object
 * @description The lookup table is generated using linear interpolation for each
 *  Primary color, with the 0-1 domain divided into any number of
 * Segments.
 * https://github.com/stefanv/matplotlib/blob/3f1a23755e86fef97d51e30e106195f34425c9e3/lib/matplotlib/colors.py#L663
 * @memberof Colors
 */


function createLinearSegmentedColormap(segmentedData, N, gamma) {
  var i;
  var lut = [];
  N = N === null ? 256 : N;
  gamma = gamma === null ? 1 : gamma;
  var redLut = makeMappingArray(N, segmentedData.red, gamma);
  var greenLut = makeMappingArray(N, segmentedData.green, gamma);
  var blueLut = makeMappingArray(N, segmentedData.blue, gamma);

  for (i = 0; i < N; i++) {
    var red = Math.round(redLut[i] * 255);
    var green = Math.round(greenLut[i] * 255);
    var blue = Math.round(blueLut[i] * 255);
    var rgba = [red, green, blue, 255];
    lut.push(rgba);
  }

  return lut;
}
/**
 * Return all available colormaps (id and name)
 * @returns {Array<{id,key}>} An array of colormaps with an object containing the "id" and display "name"
 * @memberof Colors
 */


function getColormapsList() {
  var colormaps = [];
  var keys = Object.keys(colormapsData);
  keys.forEach(function (key) {
    if (colormapsData.hasOwnProperty(key)) {
      var colormap = colormapsData[key];
      colormaps.push({
        id: key,
        name: colormap.name
      });
    }
  });
  colormaps.sort(function (a, b) {
    var aName = a.name.toLowerCase();
    var bName = b.name.toLowerCase();

    if (aName === bName) {
      return 0;
    }

    return aName < bName ? -1 : 1;
  });
  return colormaps;
}
/**
 * Return a colorMap object with the provided id and colormapData
 * if the Id matches existent colorMap objects (check colormapsData) the colormapData is ignored.
 * if the colormapData is not empty, the colorMap will be added to the colormapsData list. Otherwise, an empty colorMap object is returned.
 * @param {string} id The ID of the colormap
 * @param {Object} colormapData - An object that can contain a name, numColors, gama, segmentedData and/or colors
 * @returns {*} The Colormap Object
 * @memberof Colors
*/

function getColormap(id, colormapData) {
  var colormap = colormapsData[id];

  if (!colormap) {
    colormap = colormapsData[id] = colormapData || {
      name: '',
      colors: []
    };
  }

  if (!colormap.colors && colormap.segmentedData) {
    colormap.colors = createLinearSegmentedColormap(colormap.segmentedData, colormap.numColors, colormap.gamma);
  }

  return {
    getId: function getId() {
      return id;
    },
    getColorSchemeName: function getColorSchemeName() {
      return colormap.name;
    },
    setColorSchemeName: function setColorSchemeName(name) {
      colormap.name = name;
    },
    getNumberOfColors: function getNumberOfColors() {
      return colormap.colors.length;
    },
    setNumberOfColors: function setNumberOfColors(numColors) {
      while (colormap.colors.length < numColors) {
        colormap.colors.push(COLOR_TRANSPARENT);
      }

      colormap.colors.length = numColors;
    },
    getColor: function getColor(index) {
      if (this.isValidIndex(index)) {
        return colormap.colors[index];
      }

      return COLOR_TRANSPARENT;
    },
    getColorRepeating: function getColorRepeating(index) {
      var numColors = colormap.colors.length;
      index = numColors ? index % numColors : 0;
      return this.getColor(index);
    },
    setColor: function setColor(index, rgba) {
      if (this.isValidIndex(index)) {
        colormap.colors[index] = rgba;
      }
    },
    addColor: function addColor(rgba) {
      colormap.colors.push(rgba);
    },
    insertColor: function insertColor(index, rgba) {
      if (this.isValidIndex(index)) {
        colormap.colors.splice(index, 1, rgba);
      }
    },
    removeColor: function removeColor(index) {
      if (this.isValidIndex(index)) {
        colormap.colors.splice(index, 1);
      }
    },
    clearColors: function clearColors() {
      colormap.colors = [];
    },
    buildLookupTable: function buildLookupTable(lut) {
      if (!lut) {
        return;
      }

      var numColors = colormap.colors.length;
      lut.setNumberOfTableValues(numColors);

      for (var i = 0; i < numColors; i++) {
        lut.setTableValue(i, colormap.colors[i]);
      }
    },
    createLookupTable: function createLookupTable() {
      var lut = new _lookupTable_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
      this.buildLookupTable(lut);
      return lut;
    },
    isValidIndex: function isValidIndex(index) {
      return index >= 0 && index < colormap.colors.length;
    }
  };
}

/***/ }),

/***/ "./colors/index.js":
/*!*************************!*\
  !*** ./colors/index.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colormap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colormap.js */ "./colors/colormap.js");
/* harmony import */ var _lookupTable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lookupTable.js */ "./colors/lookupTable.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  getColormap: _colormap_js__WEBPACK_IMPORTED_MODULE_0__["getColormap"],
  getColormapsList: _colormap_js__WEBPACK_IMPORTED_MODULE_0__["getColormapsList"],
  LookupTable: _lookupTable_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./colors/lookupTable.js":
/*!*******************************!*\
  !*** ./colors/lookupTable.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// This code was created based on vtkLookupTable
// http://www.vtk.org/doc/release/5.0/html/a01697.html
// https://github.com/Kitware/VTK/blob/master/Common/Core/vtkLookupTable.cxx
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
/**
 * Converts an HSV  (Hue, Saturation, Value) color to RGB (Red, Green, Blue) color value
 * @param {Number} hue A number representing the hue color value
 * @param {any} sat A number representing the saturation color value
 * @param {any} val A number representing the value color value
 * @returns {Numberp[]} An RGB color array
 */

function HSVToRGB(hue, sat, val) {
  if (hue > 1) {
    throw new Error('HSVToRGB expects hue < 1');
  }

  var rgb = [];

  if (sat === 0) {
    rgb[0] = val;
    rgb[1] = val;
    rgb[2] = val;
    return rgb;
  }

  var hueCase = Math.floor(hue * 6);
  var frac = 6 * hue - hueCase;
  var lx = val * (1 - sat);
  var ly = val * (1 - sat * frac);
  var lz = val * (1 - sat * (1 - frac));

  switch (hueCase) {
    /* 0<hue<1/6 */
    case 0:
    case 6:
      rgb[0] = val;
      rgb[1] = lz;
      rgb[2] = lx;
      break;

    /* 1/6<hue<2/6 */

    case 1:
      rgb[0] = ly;
      rgb[1] = val;
      rgb[2] = lx;
      break;

    /* 2/6<hue<3/6 */

    case 2:
      rgb[0] = lx;
      rgb[1] = val;
      rgb[2] = lz;
      break;

    /* 3/6<hue/4/6 */

    case 3:
      rgb[0] = lx;
      rgb[1] = ly;
      rgb[2] = val;
      break;

    /* 4/6<hue<5/6 */

    case 4:
      rgb[0] = lz;
      rgb[1] = lx;
      rgb[2] = val;
      break;

    /* 5/6<hue<1 */

    case 5:
      rgb[0] = val;
      rgb[1] = lx;
      rgb[2] = ly;
      break;
  }

  return rgb;
}
/**
 * Maps a value to an index in the table
 * @param {Number} v A double value which table index will be returned.
 * @param {any} p An object that contains the Table "Range", the table "MaxIndex",
 * A "Shift" from first value in the table and the table "Scale" value
 * @returns {Number} The mapped index in the table
 * @memberof Colors
 */


function linearIndexLookupMain(v, p) {
  var dIndex; // NOTE: Added Math.floor since values were not integers? Check VTK source

  if (v < p.Range[0]) {
    dIndex = p.MaxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
  } else if (v > p.Range[1]) {
    dIndex = p.MaxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
  } else {
    dIndex = (v + p.Shift) * p.Scale;
  }

  return Math.floor(dIndex);
}
/**
 * Maps scalar values into colors via a lookup table
 * LookupTable is an object that is used by mapper objects to map scalar values into rgba (red-green-blue-alpha transparency) color specification,
 * or rgba into scalar values. The color table can be created by direct insertion of color values, or by specifying hue, saturation, value, and alpha range and generating a table
 */


var LookupTable =
/*#__PURE__*/
function () {
  /**
   * Creates a default linear LookupTable object with 256 colors.
   */
  function LookupTable() {
    _classCallCheck(this, LookupTable);

    this.NumberOfColors = 256;
    this.Ramp = 'linear';
    this.TableRange = [0, 255];
    this.HueRange = [0, 0.66667];
    this.SaturationRange = [1, 1];
    this.ValueRange = [1, 1];
    this.AlphaRange = [1, 1];
    this.NaNColor = [128, 0, 0, 255];
    this.BelowRangeColor = [0, 0, 0, 255];
    this.UseBelowRangeColor = true;
    this.AboveRangeColor = [255, 255, 255, 255];
    this.UseAboveRangeColor = true;
    this.InputRange = [0, 255];
    this.Table = [];
  }
  /**
   * Specify the number of values (i.e., colors) in the lookup table.
   * @param {Number} number The number of colors in he LookupTable
   * @returns {void}
   * @memberof Colors
   */


  _createClass(LookupTable, [{
    key: "setNumberOfTableValues",
    value: function setNumberOfTableValues(number) {
      this.NumberOfColors = number;
    }
    /**
     * Set the shape of the table ramp to either 'linear', 'scurve' or 'sqrt'
     * @param {String} ramp A string value representing the shape of the table. Allowed values are 'linear', 'scurve' or 'sqrt'
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setRamp",
    value: function setRamp(ramp) {
      this.Ramp = ramp;
    }
    /**
     * Sets the minimum/maximum scalar values for scalar mapping.
     * Scalar values less than minimum range value are clamped to minimum range value.
     * Scalar values greater than maximum range value are clamped to maximum range value.
     * @param {Number} start A double representing the minimum scaler value of the LookupTable
     * @param {any} end A double representing the maximum scaler value of the LookupTable
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setTableRange",
    value: function setTableRange(start, end) {
      this.TableRange[0] = start;
      this.TableRange[1] = end;
    }
    /**
     * Set the range in hue (using automatic generation). Hue ranges between [0,1].
     * @param {Number} start A double representing the minimum hue value in a range. Min. is 0
     * @param {Number} end A double representing the maximum hue value in a range. Max. is 1
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setHueRange",
    value: function setHueRange(start, end) {
      this.HueRange[0] = start;
      this.HueRange[1] = end;
    }
    /**
     * Set the range in saturation (using automatic generation). Saturation ranges between [0,1].
     * @param {Number} start A double representing the minimum Saturation value in a range. Min. is 0
     * @param {Number} end A double representing the maximum Saturation value in a range. Max. is 1
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setSaturationRange",
    value: function setSaturationRange(start, end) {
      this.SaturationRange[0] = start;
      this.SaturationRange[1] = end;
    }
    /**
     * Set the range in value (using automatic generation). Value ranges between [0,1].
     * @param {Numeber } start A double representing the minimum value in a range. Min. is 0
     * @param {Numeber} end A double representing the maximum value in a range. Max. is 1
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(start, end) {
      // Set the range in value (using automatic generation). Value ranges between [0,1].
      this.ValueRange[0] = start;
      this.ValueRange[1] = end;
    }
    /**
     * (Not Used) Sets the range of scalars which will be mapped.
     * @param {Number} start the minimum scalar value in the range
     * @param {Number} end the maximum scalar value in the range
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setRange",
    value: function setRange(start, end) {
      this.InputRange[0] = start;
      this.InputRange[1] = end;
    }
    /**
     * Set the range in alpha (using automatic generation). Alpha ranges from [0,1].
     * @param {Number} start A double representing the minimum alpha value
     * @param {Number} end A double representing the maximum alpha value
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setAlphaRange",
    value: function setAlphaRange(start, end) {
      // Set the range in alpha (using automatic generation). Alpha ranges from [0,1].
      this.AlphaRange[0] = start;
      this.AlphaRange[1] = end;
    }
    /**
     * Map one value through the lookup table and return the color as an
     * RGBA array of doubles between 0 and 1.
     * @param {Number} scalar A double scalar value which will be mapped to a color in the LookupTable
     * @returns {Number[]} An RGBA array of doubles between 0 and 1
     * @memberof Colors
     */

  }, {
    key: "getColor",
    value: function getColor(scalar) {
      return this.mapValue(scalar);
    }
    /**
     * Generate lookup table from hue, saturation, value, alpha min/max values. Table is built from linear ramp of each value.
     * @param {Boolean} force true to force the build of the LookupTable. Otherwie, false. This is useful if a lookup table has been defined manually
     * (using SetTableValue) and then an application decides to rebuild the lookup table using the implicit process.
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "build",
    value: function build(force) {
      if (this.Table.length > 1 && !force) {
        return;
      } // Clear the table


      this.Table = [];
      var maxIndex = this.NumberOfColors - 1;
      var hinc, sinc, vinc, ainc;

      if (maxIndex) {
        hinc = (this.HueRange[1] - this.HueRange[0]) / maxIndex;
        sinc = (this.SaturationRange[1] - this.SaturationRange[0]) / maxIndex;
        vinc = (this.ValueRange[1] - this.ValueRange[0]) / maxIndex;
        ainc = (this.AlphaRange[1] - this.AlphaRange[0]) / maxIndex;
      } else {
        hinc = sinc = vinc = ainc = 0.0;
      }

      for (var i = 0; i <= maxIndex; i++) {
        var hue = this.HueRange[0] + i * hinc;
        var sat = this.SaturationRange[0] + i * sinc;
        var val = this.ValueRange[0] + i * vinc;
        var alpha = this.AlphaRange[0] + i * ainc;
        var rgb = HSVToRGB(hue, sat, val);
        var c_rgba = [];

        switch (this.Ramp) {
          case 'scurve':
            c_rgba[0] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[0]) * Math.PI)));
            c_rgba[1] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[1]) * Math.PI)));
            c_rgba[2] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[2]) * Math.PI)));
            c_rgba[3] = Math.floor(alpha * 255);
            break;

          case 'linear':
            c_rgba[0] = Math.floor(rgb[0] * 255 + 0.5);
            c_rgba[1] = Math.floor(rgb[1] * 255 + 0.5);
            c_rgba[2] = Math.floor(rgb[2] * 255 + 0.5);
            c_rgba[3] = Math.floor(alpha * 255 + 0.5);
            break;

          case 'sqrt':
            c_rgba[0] = Math.floor(Math.sqrt(rgb[0]) * 255 + 0.5);
            c_rgba[1] = Math.floor(Math.sqrt(rgb[1]) * 255 + 0.5);
            c_rgba[2] = Math.floor(Math.sqrt(rgb[2]) * 255 + 0.5);
            c_rgba[3] = Math.floor(Math.sqrt(alpha) * 255 + 0.5);
            break;

          default:
            throw new Error("Invalid Ramp value (".concat(this.Ramp, ")"));
        }

        this.Table.push(c_rgba);
      }

      this.buildSpecialColors();
    }
    /**
     * Ensures the out-of-range colors (Below range and Above range) are set correctly.
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "buildSpecialColors",
    value: function buildSpecialColors() {
      var numberOfColors = this.NumberOfColors;
      var belowRangeColorIndex = numberOfColors + BELOW_RANGE_COLOR_INDEX;
      var aboveRangeColorIndex = numberOfColors + ABOVE_RANGE_COLOR_INDEX;
      var nanColorIndex = numberOfColors + NAN_COLOR_INDEX; // Below range color

      if (this.UseBelowRangeColor || numberOfColors === 0) {
        this.Table[belowRangeColorIndex] = this.BelowRangeColor;
      } else {
        // Duplicate the first color in the table.
        this.Table[belowRangeColorIndex] = this.Table[0];
      } // Above range color


      if (this.UseAboveRangeColor || numberOfColors === 0) {
        this.Table[aboveRangeColorIndex] = this.AboveRangeColor;
      } else {
        // Duplicate the last color in the table.
        this.Table[aboveRangeColorIndex] = this.Table[numberOfColors - 1];
      } // Always use NanColor


      this.Table[nanColorIndex] = this.NaNColor;
    }
    /**
     * Similar to GetColor - Map one value through the lookup table and return the color as an
     * RGBA array of doubles between 0 and 1.
     * @param {Numeber} v A double scalar value which will be mapped to a color in the LookupTable
     * @returns {Number[]} An RGBA array of doubles between 0 and 1
     * @memberof Colors
     */

  }, {
    key: "mapValue",
    value: function mapValue(v) {
      var index = this.getIndex(v);

      if (index < 0) {
        return this.NaNColor;
      } else if (index === 0) {
        if (this.UseBelowRangeColor && v < this.TableRange[0]) {
          return this.BelowRangeColor;
        }
      } else if (index === this.NumberOfColors - 1) {
        if (this.UseAboveRangeColor && v > this.TableRange[1]) {
          return this.AboveRangeColor;
        }
      }

      return this.Table[index];
    }
    /**
     * Return the table index associated with a particular value.
     * @param {Number} v A double value which table index will be returned.
     * @returns {Number} The index in the LookupTable
     * @memberof Colors
     */

  }, {
    key: "getIndex",
    value: function getIndex(v) {
      var p = {};
      p.Range = [];
      p.MaxIndex = this.NumberOfColors - 1; // This was LookupShiftAndScale

      p.Shift = -this.TableRange[0];

      if (this.TableRange[1] <= this.TableRange[0]) {
        p.Scale = Number.MAX_VALUE;
      } else {
        p.Scale = p.MaxIndex / (this.TableRange[1] - this.TableRange[0]);
      }

      p.Range[0] = this.TableRange[0];
      p.Range[1] = this.TableRange[1]; // First, check whether we have a number...

      if (isNaN(v)) {
        // For backwards compatibility
        return -1;
      } // Map to an index:


      var index = linearIndexLookupMain(v, p); // For backwards compatibility, if the index indicates an
      // Out-of-range value, truncate to index range for in-range colors.

      if (index === this.NumberOfColors + BELOW_RANGE_COLOR_INDEX) {
        index = 0;
      } else if (index === this.NumberOfColors + ABOVE_RANGE_COLOR_INDEX) {
        index = this.NumberOfColors - 1;
      }

      return index;
    }
    /**
     * Directly load color into lookup table. Use [0,1] double values for color component specification.
     * Make sure that you've either used the Build() method or used SetNumberOfTableValues() prior to using this method.
     * @param {Number} index The index in the LookupTable of where to insert the color value
     * @param {Number[]} rgba An array of [0,1] double values for an RGBA color component
     * @returns {void}
     * @memberof Colors
     */

  }, {
    key: "setTableValue",
    value: function setTableValue(index, rgba) {
      // Check if it index, red, green, blue and alpha were passed as parameter
      if (arguments.length === 5) {
        rgba = Array.prototype.slice.call(arguments, 1);
      } // Check the index to make sure it is valid


      if (index < 0) {
        throw new Error("Can't set the table value for negative index (".concat(index, ")"));
      }

      if (index >= this.NumberOfColors) {
        new Error("Index ".concat(index, " is greater than the number of colors ").concat(this.NumberOfColors));
      }

      this.Table[index] = rgba;

      if (index === 0 || index === this.NumberOfColors - 1) {
        // This is needed due to the way the special colors are stored in
        // The internal table. If Above/BelowRangeColors are not used and
        // The min/max colors are changed in the table with this member
        // Function, then the colors used for values outside the range may
        // Be incorrect. Calling this here ensures the out-of-range colors
        // Are set correctly.
        this.buildSpecialColors();
      }
    }
  }]);

  return LookupTable;
}();

/* harmony default export */ __webpack_exports__["default"] = (LookupTable);

/***/ }),

/***/ "./disable.js":
/*!********************!*\
  !*** ./disable.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./events.js");



/**
 *  Disable an HTML element for further use in Cornerstone
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @returns {void}
 * @memberof Enable
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  if (element === undefined) {
    throw new Error('disable: element must not be undefined');
  } // Search for this element in this list of enabled elements


  var enabledElements = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElements"])();

  for (var i = 0; i < enabledElements.length; i++) {
    if (enabledElements[i].element === element) {
      // We found it!
      // Fire an event so dependencies can cleanup
      var eventData = {
        element: element
      };
      Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element, _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].ELEMENT_DISABLED, eventData);
      Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_2__["events"], _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].ELEMENT_DISABLED, eventData); // Remove the child DOM elements that we created (e.g.canvas)

      enabledElements[i].element.removeChild(enabledElements[i].canvas);
      enabledElements[i].canvas = undefined; // Remove this element from the list of enabled elements

      enabledElements.splice(i, 1);
      break;
    }
  }
});

/***/ }),

/***/ "./displayImage.js":
/*!*************************!*\
  !*** ./displayImage.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");
/* harmony import */ var _internal_now_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/now.js */ "./internal/now.js");
/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layers.js */ "./layers.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events.js */ "./events.js");







/**
 * Sets a new image object for a given element.
 *
 * Will also apply an optional viewport setting.
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {Object} image An Image loaded by a Cornerstone Image Loader
 * @param {Object} [viewport] A set of Cornerstone viewport parameters
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, image, viewport) {
  if (element === undefined) {
    throw new Error('displayImage: parameter element must not be undefined');
  }

  if (image === undefined) {
    throw new Error('displayImage: parameter image must not be undefined');
  }

  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var oldImage = enabledElement.image;
  enabledElement.image = image;

  if (enabledElement.layers && enabledElement.layers.length) {
    Object(_layers_js__WEBPACK_IMPORTED_MODULE_4__["setLayerImage"])(element, image);
  }

  if (enabledElement.viewport === undefined) {
    enabledElement.viewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement.canvas, image);
  } // Merge viewport


  if (viewport) {
    for (var attrname in viewport) {
      if (viewport[attrname] !== null) {
        enabledElement.viewport[attrname] = viewport[attrname];
      }
    }
  }

  var frameRate;

  if (enabledElement.lastImageTimeStamp !== undefined) {
    var timeSinceLastImage = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])() - enabledElement.lastImageTimeStamp;
    frameRate = (1000 / timeSinceLastImage).toFixed();
  }

  enabledElement.lastImageTimeStamp = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
  var newImageEventData = {
    viewport: enabledElement.viewport,
    element: enabledElement.element,
    image: enabledElement.image,
    oldImage: oldImage,
    enabledElement: enabledElement,
    frameRate: frameRate
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(enabledElement.element, _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].NEW_IMAGE, newImageEventData);
  Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
});

/***/ }),

/***/ "./draw.js":
/*!*****************!*\
  !*** ./draw.js ***!
  \*****************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/drawImage.js */ "./internal/drawImage.js");


/**
 * Immediately draws the enabled element
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);

  if (enabledElement.image === undefined) {
    throw new Error('draw: image has not been loaded yet');
  }

  Object(_internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement);
});

/***/ }),

/***/ "./drawInvalidated.js":
/*!****************************!*\
  !*** ./drawInvalidated.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/drawImage.js */ "./internal/drawImage.js");
/**
 * This module is responsible for drawing invalidated enabled elements
 */


/**
 * Draws all invalidated enabled elements and clears the invalid flag after drawing it
 *
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var enabledElements = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElements"])();

  for (var i = 0; i < enabledElements.length; i++) {
    var ee = enabledElements[i];

    if (ee.invalid === true) {
      Object(_internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(ee, true);
    }
  }
});

/***/ }),

/***/ "./enable.js":
/*!*******************!*\
  !*** ./enable.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _resize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resize.js */ "./resize.js");
/* harmony import */ var _internal_drawImageSync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/drawImageSync.js */ "./internal/drawImageSync.js");
/* harmony import */ var _internal_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/requestAnimationFrame.js */ "./internal/requestAnimationFrame.js");
/* harmony import */ var _internal_tryEnableWebgl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/tryEnableWebgl.js */ "./internal/tryEnableWebgl.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _generateUUID_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./generateUUID.js */ "./generateUUID.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./events.js */ "./events.js");
/* harmony import */ var _internal_getCanvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./internal/getCanvas.js */ "./internal/getCanvas.js");









/**
 * @module Enable
 * This module is responsible for enabling an element to display images with cornerstone
 */

/**
 * Returns whether or not an Enabled Element has either a currently active image or
 * a non-empty Array of Enabled Element Layers.
 *
 * @param {EnabledElement} enabledElement An Enabled Element
 * @return {Boolean} Whether or not the Enabled Element has an active image or valid set of layers
 * @memberof Enable
 */

function hasImageOrLayers(enabledElement) {
  return enabledElement.image !== undefined || enabledElement.layers.length > 0;
}
/**
 * Enable an HTML Element for use in Cornerstone
 *
 * - If there is a Canvas already present within the HTMLElement, and it has the class
 * 'cornerstone-canvas', this function will use this existing Canvas instead of creating
 * a new one. This may be helpful when using libraries (e.g. React, Vue) which don't
 * want third parties to change the DOM.
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {Object} options Options for the enabledElement
 *
 * @return {void}
 * @memberof Enable
 */


/* harmony default export */ __webpack_exports__["default"] = (function (element, options) {
  if (element === undefined) {
    throw new Error('enable: parameter element cannot be undefined');
  } // If this enabled element has the option set for WebGL, we should
  // Check if this device actually supports it


  if (options && options.renderer && options.renderer.toLowerCase() === 'webgl') {
    Object(_internal_tryEnableWebgl_js__WEBPACK_IMPORTED_MODULE_4__["default"])(options);
  }

  var canvas = Object(_internal_getCanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element);
  var enabledElement = {
    element: element,
    canvas: canvas,
    image: undefined,
    // Will be set once image is loaded
    invalid: false,
    // True if image needs to be drawn, false if not
    needsRedraw: true,
    options: options,
    layers: [],
    data: {},
    renderingTools: {},
    uuid: Object(_generateUUID_js__WEBPACK_IMPORTED_MODULE_6__["default"])()
  };
  Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["addEnabledElement"])(enabledElement);
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_7__["events"], _events_js__WEBPACK_IMPORTED_MODULE_7__["default"].ELEMENT_ENABLED, enabledElement);
  Object(_resize_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element, true);
  /**
   * Draw the image immediately
   *
   * @param {DOMHighResTimeStamp} timestamp The current time for when requestAnimationFrame starts to fire callbacks
   * @returns {void}
   * @memberof Drawing
   */

  function draw(timestamp) {
    if (enabledElement.canvas === undefined) {
      return;
    }

    var eventDetails = {
      enabledElement: enabledElement,
      timestamp: timestamp
    };
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(enabledElement.element, _events_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRE_RENDER, eventDetails);

    if (enabledElement.needsRedraw && hasImageOrLayers(enabledElement)) {
      Object(_internal_drawImageSync_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement, enabledElement.invalid);
    }

    Object(_internal_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__["default"])(draw);
  }

  draw();
});

/***/ }),

/***/ "./enabledElementData.js":
/*!*******************************!*\
  !*** ./enabledElementData.js ***!
  \*******************************/
/*! exports provided: getElementData, removeElementData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementData", function() { return getElementData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeElementData", function() { return removeElementData; });
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");

/**
 * Retrieves any data for a Cornerstone enabledElement for a specific string
 * dataType
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {string} dataType A string name for an arbitrary set of data
 * @returns {*} Whatever data is stored for this enabled element
 */

function getElementData(element, dataType) {
  var ee = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);

  if (ee.data.hasOwnProperty(dataType) === false) {
    ee.data[dataType] = {};
  }

  return ee.data[dataType];
}
/**
 * Clears any data for a Cornerstone enabledElement for a specific string
 * dataType
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {string} dataType A string name for an arbitrary set of data
 *
 * @returns {void}
 */

function removeElementData(element, dataType) {
  var ee = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  delete ee.data[dataType];
}

/***/ }),

/***/ "./enabledElements.js":
/*!****************************!*\
  !*** ./enabledElements.js ***!
  \****************************/
/*! exports provided: getEnabledElement, addEnabledElement, getEnabledElementsByImageId, getEnabledElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnabledElement", function() { return getEnabledElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEnabledElement", function() { return addEnabledElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnabledElementsByImageId", function() { return getEnabledElementsByImageId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnabledElements", function() { return getEnabledElements; });
var enabledElements = [];
/**
 * @module EnabledElements
 */

/**
 * @module Objects
 */

/**
 * A two-dimensional vector
 *
 * @typedef {Object} vec2
 * @memberof Objects
 * @param {Number} x - The x distance
 * @param {Number} y - The y distance
 */

/**
 * VOI
 *
 * @typedef {Object} VOI
 * @memberof Objects
 * @param {Number} windowWidth - Window Width for display
 * @param {Number} windowCenter - Window Center for display
 */

/**
 * Lookup Table Array
 *
 * @typedef {Object} LUT
 * @memberof Objects
 * @property {Number} firstValueMapped
 * @property {Number} numBitsPerEntry
 * @property {Array} lut
 */

/**
 * Image Statistics Object
 *
 * @typedef {Object} ImageStats
 * @memberof Objects
 * @property {Number} [lastGetPixelDataTime] The time in ms taken to retrieve stored pixels required to draw the image
 * @property {Number} [lastStoredPixelDataToCanvasImageDataTime] The time in ms taken to map from stored pixel array to canvas pixel array
 * @property {Number} [lastPutImageDataTime] The time in ms taken for putImageData to put the canvas pixel data into the canvas context
 * @property {Number} [lastRenderTime] The total time in ms taken for the entire rendering function to run
 * @property {Number} [lastLutGenerateTime] The time in ms taken to generate the lookup table for the image
 */

/**
 * An Image Object in Cornerstone
 *
 * @typedef {Object} Image
 * @memberof Objects
 * @property {string} imageId - The imageId associated with this image object
 * @property {Number} minPixelValue - the minimum stored pixel value in the image
 * @property {Number} maxPixelValue - the maximum stored pixel value in the image
 * @property {Number} slope - the rescale slope to convert stored pixel values to modality pixel values or 1 if not specified
 * @property {Number} intercept - the rescale intercept used to convert stored pixel values to modality values or 0 if not specified
 * @property {Number} windowCenter - the default windowCenter to apply to the image
 * @property {Number} windowWidth - the default windowWidth to apply to the image
 * @property {function} getPixelData - a function that returns the underlying pixel data. An array of integers for grayscale and an array of RGBA for color
 * @property {function} getImageData - a function that returns a canvas imageData object for the image. This is only needed for color images
 * @property {function} getCanvas - a function that returns a canvas element with the image loaded into it. This is only needed for color images.
 * @property {function} getImage - a function that returns a JavaScript Image object with the image data. This is optional and typically used for images encoded in standard web JPEG and PNG formats
 * @property {Number} rows - number of rows in the image. This is the same as height but duplicated for convenience
 * @property {Number} columns - number of columns in the image. This is the same as width but duplicated for convenience
 * @property {Number} height - the height of the image. This is the same as rows but duplicated for convenience
 * @property {Number} width - the width of the image. This is the same as columns but duplicated for convenience
 * @property {Boolean} color - true if pixel data is RGB, false if grayscale
 * @property {Object} lut - The Lookup Table
 * @property {Boolean} rgba - Is the color pixel data stored in RGBA?
 * @property {Number} columnPixelSpacing - horizontal distance between the middle of each pixel (or width of each pixel) in mm or undefined if not known
 * @property {Number} rowPixelSpacing - vertical distance between the middle of each pixel (or height of each pixel) in mm or undefined if not known
 * @property {Boolean} invert - true if the the image should initially be displayed be inverted, false if not. This is here mainly to support DICOM images with a photometric interpretation of MONOCHROME1
 * @property {Number} sizeInBytes - the number of bytes used to store the pixels for this image.
 * @property {Boolean} [falseColor=false] - Whether or not the image has undergone false color mapping
 * @property {Array} [origPixelData] - Original pixel data for an image after it has undergone false color mapping
 * @property {ImageStats} [stats] - Statistics for the last redraw of the image
 * @property {Object} cachedLut - Cached Lookup Table for this image.
 * @property {String|Colormap} [colormap] - an optional colormap ID or colormap object (from colors/colormap.js). This will be applied during rendering to convert the image to pseudocolor
 * @property {Boolean} [labelmap=false] - whether or not to render this image as a label map (i.e. skip modality and VOI LUT pipelines and use only a color lookup table)
 */

/**
 * A Viewport Settings Object Cornerstone
 *
 * @typedef {Object} Viewport
 * @memberof Objects
 * @property {Number} [scale=1.0] - The scale applied to the image. A scale of 1.0 will display no zoom (one image pixel takes up one screen pixel). A scale of 2.0 will be double zoom and a scale of .5 will be zoomed out by 2x
 * @property {vec2} [translation] - An object with properties x and y which describe the translation to apply in the pixel coordinate system. Note that the image is initially displayed centered in the enabled element with a x and y translation of 0 and 0 respectively.
 * @property {VOI} [voi] - an object with properties windowWidth and windowCenter.
 * @property {boolean} [invert=false] - Whether or not the image is inverted.
 * @property {boolean} [pixelReplication=false] - true if the image smooth / interpolation should be used when zoomed in on the image or false if pixel replication should be used.
 * @property {boolean} [hflip=false] - true if the image is flipped horizontally. Default is false
 * @property {boolean} [vflip=false] - true if the image is flipped vertically. Default is false
 * @property {Number} [rotation=0] - the rotation of the image (90 degree increments). Default is 0
 * @property {LUT} [modalityLUT] - the modality LUT to apply or undefined if none
 * @property {LUT} [voiLUT] - the modality LUT to apply or undefined if none
 * @property {String|Colormap} [colormap] - an optional colormap ID or colormap object (from colors/colormap.js). This will be applied during rendering to convert the image to pseudocolor
 * @property {Boolean} [labelmap=false] - whether or not to render this image as a label map (i.e. skip modality and VOI LUT pipelines and use only a color lookup table)
 */

/**
 * An Enabled Element in Cornerstone
 *
 * @typedef {Object} EnabledElement
 * @memberof Objects
 * @property {HTMLElement} element - The DOM element which has been enabled for use by Cornerstone
 * @property {Image} [image] - The image currently displayed in the enabledElement
 * @property {Viewport} [viewport] - The current viewport settings of the enabledElement
 * @property {HTMLCanvasElement} [canvas] - The current canvas for this enabledElement
 * @property {Boolean} invalid - Whether or not the image pixel data underlying the enabledElement has been changed, necessitating a redraw
 * @property {Boolean} needsRedraw - A flag for triggering a redraw of the canvas without re-retrieving the pixel data, since it remains valid
 * @property {EnabledElementLayer[]} [layers] - The layers that have been added to the enabledElement
 * @property {Boolean} [syncViewports] - Whether or not to synchronize the viewport parameters
 * for each of the enabled element's layers
 * @property {Boolean} [lastSyncViewportsState] - The previous state for the sync viewport boolean
 */

/**
 * An Enabled Element Layer in Cornerstone
 *
 * @typedef {Object} EnabledElementLayer
 * @memberof Objects
 * @property {HTMLElement} element - The DOM element which has been enabled for use by Cornerstone
 * @property {Image} [image] - The image currently displayed in the enabledElement
 * @property {Viewport} [viewport] - The current viewport settings of the enabledElement
 * @property {HTMLCanvasElement} [canvas] - The current canvas for this enabledElement
 * @property {Object} [options] - Layer drawing options
 * @property {Boolean} invalid - Whether or not the image pixel data underlying the enabledElement has been changed, necessitating a redraw
 * @property {Boolean} needsRedraw - A flag for triggering a redraw of the canvas without re-retrieving the pixel data, since it remains valid
 */

/**
 * An Image Load Object
 *
 * @typedef {Object} ImageLoadObject
 * @memberof Objects
 * @property {Promise} promise - The Promise tracking the loading of this image
 * @property {Function|undefined} cancelFn - A function to cancel the image load request
 */

/**
 * Retrieves a Cornerstone Enabled Element object
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 *
 * @returns {EnabledElement} A Cornerstone Enabled Element
 * @memberof EnabledElements
 */

function getEnabledElement(element) {
  if (element === undefined) {
    throw new Error('getEnabledElement: parameter element must not be undefined');
  }

  for (var i = 0; i < enabledElements.length; i++) {
    if (enabledElements[i].element === element) {
      return enabledElements[i];
    }
  }

  throw new Error('element not enabled');
}
/**
 * Adds a Cornerstone Enabled Element object to the central store of enabledElements
 *
 * @param {EnabledElement} enabledElement A Cornerstone enabledElement Object
 * @returns {void}
 * @memberof EnabledElements
 */

function addEnabledElement(enabledElement) {
  if (enabledElement === undefined) {
    throw new Error('getEnabledElement: enabledElement element must not be undefined');
  }

  enabledElements.push(enabledElement);
}
/**
 * Adds a Cornerstone Enabled Element object to the central store of enabledElements
 *
 * @param {string} imageId A Cornerstone Image ID
 * @returns {EnabledElement[]} An Array of Cornerstone enabledElement Objects
 * @memberof EnabledElements
 */

function getEnabledElementsByImageId(imageId) {
  var ees = [];
  enabledElements.forEach(function (enabledElement) {
    if (enabledElement.image && enabledElement.image.imageId === imageId) {
      ees.push(enabledElement);
    }
  });
  return ees;
}
/**
 * Retrieve all of the currently enabled Cornerstone elements
 *
 * @return {EnabledElement[]} An Array of Cornerstone enabledElement Objects
 * @memberof EnabledElements
 */

function getEnabledElements() {
  return enabledElements;
}

/***/ }),

/***/ "./events.js":
/*!*******************!*\
  !*** ./events.js ***!
  \*******************/
/*! exports provided: default, events */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "events", function() { return events; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EVENTS = {
  NEW_IMAGE: 'cornerstonenewimage',
  INVALIDATED: 'cornerstoneinvalidated',
  PRE_RENDER: 'cornerstoneprerender',
  IMAGE_CACHE_MAXIMUM_SIZE_CHANGED: 'cornerstoneimagecachemaximumsizechanged',
  IMAGE_CACHE_PROMISE_REMOVED: 'cornerstoneimagecachepromiseremoved',
  IMAGE_CACHE_FULL: 'cornerstoneimagecachefull',
  IMAGE_CACHE_CHANGED: 'cornerstoneimagecachechanged',
  WEBGL_TEXTURE_REMOVED: 'cornerstonewebgltextureremoved',
  WEBGL_TEXTURE_CACHE_FULL: 'cornerstonewebgltexturecachefull',
  IMAGE_LOADED: 'cornerstoneimageloaded',
  IMAGE_LOAD_FAILED: 'cornerstoneimageloadfailed',
  ELEMENT_RESIZED: 'cornerstoneelementresized',
  IMAGE_RENDERED: 'cornerstoneimagerendered',
  LAYER_ADDED: 'cornerstonelayeradded',
  LAYER_REMOVED: 'cornerstonelayerremoved',
  ACTIVE_LAYER_CHANGED: 'cornerstoneactivelayerchanged',
  ELEMENT_DISABLED: 'cornerstoneelementdisabled',
  ELEMENT_ENABLED: 'cornerstoneelementenabled'
};
/* harmony default export */ __webpack_exports__["default"] = (EVENTS);
/**
 * EventTarget - Provides the [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface
 *
 * @class
 * @memberof Polyfills
 */

var EventTarget =
/*#__PURE__*/
function () {
  function EventTarget() {
    _classCallCheck(this, EventTarget);

    this.listeners = {};
    this.namespaces = {};
  }

  _createClass(EventTarget, [{
    key: "addEventNamespaceListener",
    value: function addEventNamespaceListener(type, callback) {
      if (type.indexOf('.') <= 0) {
        return;
      }

      this.namespaces[type] = callback;
      this.addEventListener(type.split('.')[0], callback);
    }
  }, {
    key: "removeEventNamespaceListener",
    value: function removeEventNamespaceListener(type) {
      if (type.indexOf('.') <= 0 || !this.namespaces[type]) {
        return;
      }

      this.removeEventListener(type.split('.')[0], this.namespaces[type]);
      delete this.namespaces[type];
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, callback) {
      // Check if it is an event namespace
      if (type.indexOf('.') > 0) {
        this.addEventNamespaceListener(type, callback);
        return;
      }

      if (!(type in this.listeners)) {
        this.listeners[type] = [];
      }

      this.listeners[type].push(callback);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback) {
      // Check if it is an event namespace
      if (type.indexOf('.') > 0) {
        this.removeEventNamespaceListener(type);
        return;
      }

      if (!(type in this.listeners)) {
        return;
      }

      var stack = this.listeners[type];

      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i] === callback) {
          stack.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return true;
      }

      var stack = this.listeners[event.type];

      for (var i = 0, l = stack.length; i < l; i++) {
        stack[i].call(this, event);
      }

      return !event.defaultPrevented;
    }
  }]);

  return EventTarget;
}();

var events = new EventTarget();

/***/ }),

/***/ "./falseColorMapping.js":
/*!******************************!*\
  !*** ./falseColorMapping.js ***!
  \******************************/
/*! exports provided: convertImageToFalseColorImage, convertToFalseColorImage, restoreImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertImageToFalseColorImage", function() { return convertImageToFalseColorImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToFalseColorImage", function() { return convertToFalseColorImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restoreImage", function() { return restoreImage; });
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _pixelDataToFalseColorData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pixelDataToFalseColorData.js */ "./pixelDataToFalseColorData.js");
/* harmony import */ var _colors_colormap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors/colormap.js */ "./colors/colormap.js");



/**
 * Retrieves the minimum and maximum pixel values from an Array of pixel data
 *
 * @param {Array} pixelData The input pixel data array
 *
 * @returns {{minPixelValue: Number, maxPixelValue: Number}} The minimum and maximum pixel values in the input Array
 */

function getPixelValues(pixelData) {
  var minPixelValue = Number.MAX_VALUE;
  var maxPixelValue = Number.MIN_VALUE;
  var len = pixelData.length;
  var pixel;

  for (var i = 0; i < len; i++) {
    pixel = pixelData[i];
    minPixelValue = minPixelValue < pixel ? minPixelValue : pixel;
    maxPixelValue = maxPixelValue > pixel ? maxPixelValue : pixel;
  }

  return {
    minPixelValue: minPixelValue,
    maxPixelValue: maxPixelValue
  };
}
/**
 * Retrieve a function that will allow an image object to be reset to its original form
 * after a false color mapping transformation
 *
 * @param {Image} image A Cornerstone Image Object
 *
 * @return {Function} A function for resetting an Image Object to its original form
 */


function getRestoreImageMethod(image) {
  if (image.restore) {
    return image.restore;
  }

  var color = image.color;
  var rgba = image.rgba;
  var cachedLut = image.cachedLut;
  var slope = image.slope;
  var windowWidth = image.windowWidth;
  var windowCenter = image.windowCenter;
  var minPixelValue = image.minPixelValue;
  var maxPixelValue = image.maxPixelValue;
  return function () {
    image.color = color;
    image.rgba = rgba;
    image.cachedLut = cachedLut;
    image.slope = slope;
    image.windowWidth = windowWidth;
    image.windowCenter = windowCenter;
    image.minPixelValue = minPixelValue;
    image.maxPixelValue = maxPixelValue;

    if (image.origPixelData) {
      var pixelData = image.origPixelData;

      image.getPixelData = function () {
        return pixelData;
      };
    } // Remove some attributes added by false color mapping


    image.origPixelData = undefined;
    image.colormapId = undefined;
    image.falseColor = undefined;
  };
} //
// Then we need to make sure it will be converted into a colormap object if it's as string.

/**
 * User can pass a colormap or its id as string to some of these public functions.
 * Then we need to make sure it will be converted into a colormap object if it's a string.
 *
 * @param {*} colormap A colormap ID or Object
 * @return {*} The colormap
 */


function ensuresColormap(colormap) {
  if (colormap && typeof colormap === 'string') {
    colormap = Object(_colors_colormap_js__WEBPACK_IMPORTED_MODULE_2__["getColormap"])(colormap);
  }

  return colormap;
}
/**
 * Restores a false color image to its original version
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Boolean} True if the image object had a valid restore function, which was run. Otherwise, false.
 */


function restoreImage(image) {
  if (image.restore && typeof image.restore === 'function') {
    image.restore();
    return true;
  }

  return false;
}
/**
 * Convert an image to a false color image
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {String|Object} colormap - it can be a colormap object or a colormap id (string)
 *
 * @returns {Boolean} - Whether or not the image has been converted to a false color image
 */


function convertImageToFalseColorImage(image, colormap) {
  if (image.color && !image.falseColor) {
    throw new Error('Color transforms are not implemented yet');
  } // User can pass a colormap id or a colormap object


  colormap = ensuresColormap(colormap);
  var colormapId = colormap.getId(); // Doesn't do anything if colormapId hasn't changed

  if (image.colormapId === colormapId) {
    // It has already being converted into a false color image
    // Using the colormapId passed as parameter
    return false;
  } // Restore the image attributes updated when converting to a false color image


  restoreImage(image); // Convert the image to a false color image

  if (colormapId) {
    var minPixelValue = image.minPixelValue || 0;
    var maxPixelValue = image.maxPixelValue || 255;
    image.restore = getRestoreImageMethod(image);
    var lookupTable = colormap.createLookupTable();
    lookupTable.setTableRange(minPixelValue, maxPixelValue); // Update the pixel data and render the new image

    Object(_pixelDataToFalseColorData_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image, lookupTable); // Update min and max pixel values

    var pixelValues = getPixelValues(image.getPixelData());
    image.minPixelValue = pixelValues.minPixelValue;
    image.maxPixelValue = pixelValues.maxPixelValue;
    image.windowWidth = 255;
    image.windowCenter = 128; // Cache the last colormapId used for performance
    // Then it doesn't need to be re-rendered on next
    // Time if the user hasn't updated it

    image.colormapId = colormapId;
  } // Return `true` to tell the caller that the image has got updated


  return true;
}
/**
 * Convert the image of a element to a false color image
 *
 * @param {HTMLElement} element The Cornerstone element
 * @param {*} colormap - it can be a colormap object or a colormap id (string)
 *
 * @returns {void}
 */


function convertToFalseColorImage(element, colormap) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  return convertImageToFalseColorImage(enabledElement.image, colormap);
}



/***/ }),

/***/ "./fitToWindow.js":
/*!************************!*\
  !*** ./fitToWindow.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");
/* harmony import */ var _internal_getImageFitScale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/getImageFitScale.js */ "./internal/getImageFitScale.js");



/**
 * Adjusts an image's scale and translation so the image is centered and all pixels
 * in the image are viewable.
 *
 * @param {HTMLElement} element The Cornerstone element to update
 * @returns {void}
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var image = enabledElement.image; // The new scale is the minimum of the horizontal and vertical scale values

  enabledElement.viewport.scale = Object(_internal_getImageFitScale_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement.canvas, image, enabledElement.viewport.rotation).scaleFactor;
  enabledElement.viewport.translation.x = 0;
  enabledElement.viewport.translation.y = 0;
  Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
});

/***/ }),

/***/ "./generateUUID.js":
/*!*************************!*\
  !*** ./generateUUID.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
* Generates a UUID for the enabledElement.
*
* @return {String} the UUID.
*/
/* harmony default export */ __webpack_exports__["default"] = (function () {
  // https://stackoverflow.com/a/8809472/9208320 Public Domain/MIT

  /* eslint no-bitwise: ["error", { "allow": ["&","|"] }] */
  var d = new Date().getTime();

  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    d += performance.now(); // Use high-precision timer if available
  }

  return 'x.x.x.x.x.x.xxxx.xxx.x.x.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
});

/***/ }),

/***/ "./getDefaultViewportForImage.js":
/*!***************************************!*\
  !*** ./getDefaultViewportForImage.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");


/**
 * Returns a default viewport for display the specified image on the specified
 * enabled element.  The default viewport is fit to window
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Image} image A Cornerstone Image Object
 *
 * @returns {Viewport} The default viewport for the image
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, image) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  return Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement.canvas, image);
});

/***/ }),

/***/ "./getImage.js":
/*!*********************!*\
  !*** ./getImage.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");

/**
 * Returns the currently displayed image for an element or undefined if no image has
 * been displayed yet
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @returns {Image} The Cornerstone Image Object displayed in this element
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  return enabledElement.image;
});

/***/ }),

/***/ "./getPixels.js":
/*!**********************!*\
  !*** ./getPixels.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _getStoredPixels_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getStoredPixels.js */ "./getStoredPixels.js");
/* harmony import */ var _internal_getModalityLUT_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/getModalityLUT.js */ "./internal/getModalityLUT.js");



/**
 * Retrieves an array of pixels from a rectangular region with modality LUT transformation applied
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Number} x The x coordinate of the top left corner of the sampling rectangle in image coordinates
 * @param {Number} y The y coordinate of the top left corner of the sampling rectangle in image coordinates
 * @param {Number} width The width of the of the sampling rectangle in image coordinates
 * @param {Number} height The height of the of the sampling rectangle in image coordinates
 * @returns {Array} The modality pixel value of the pixels in the sampling rectangle
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, x, y, width, height) {
  var storedPixels = Object(_getStoredPixels_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element, x, y, width, height);
  var ee = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var mlutfn = Object(_internal_getModalityLUT_js__WEBPACK_IMPORTED_MODULE_2__["default"])(ee.image.slope, ee.image.intercept, ee.viewport.modalityLUT);
  return storedPixels.map(mlutfn);
});

/***/ }),

/***/ "./getStoredPixels.js":
/*!****************************!*\
  !*** ./getStoredPixels.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");

/**
 * Retrieves an array of stored pixel values from a rectangular region of an image
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Number} x The x coordinate of the top left corner of the sampling rectangle in image coordinates
 * @param {Number} y The y coordinate of the top left corner of the sampling rectangle in image coordinates
 * @param {Number} width The width of the of the sampling rectangle in image coordinates
 * @param {Number} height The height of the of the sampling rectangle in image coordinates
 * @returns {Array} The stored pixel value of the pixels in the sampling rectangle
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, x, y, width, height) {
  if (element === undefined) {
    throw new Error('getStoredPixels: parameter element must not be undefined');
  }

  x = Math.round(x);
  y = Math.round(y);
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var storedPixels = [];
  var index = 0;
  var pixelData = enabledElement.image.getPixelData();

  for (var row = 0; row < height; row++) {
    for (var column = 0; column < width; column++) {
      var spIndex = (row + y) * enabledElement.image.columns + (column + x);
      storedPixels[index++] = pixelData[spIndex];
    }
  }

  return storedPixels;
});

/***/ }),

/***/ "./getViewport.js":
/*!************************!*\
  !*** ./getViewport.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");

/**
 * Retrieves the viewport for the specified enabled element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @returns {Viewport|undefined} The Cornerstone Viewport settings for this element, if they exist. Otherwise, undefined
 * @memberof ViewportSettings
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var viewport = enabledElement.viewport;

  if (viewport === undefined) {
    return;
  } // Return a copy of the viewport


  return Object.assign({}, viewport);
});

/***/ }),

/***/ "./imageCache.js":
/*!***********************!*\
  !*** ./imageCache.js ***!
  \***********************/
/*! exports provided: cachedImages, setMaximumSizeBytes, putImageLoadObject, getImageLoadObject, removeImageLoadObject, getCacheInfo, purgeCache, changeImageIdCacheSize, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cachedImages", function() { return cachedImages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMaximumSizeBytes", function() { return setMaximumSizeBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "putImageLoadObject", function() { return putImageLoadObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageLoadObject", function() { return getImageLoadObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeImageLoadObject", function() { return removeImageLoadObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCacheInfo", function() { return getCacheInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "purgeCache", function() { return purgeCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeImageIdCacheSize", function() { return changeImageIdCacheSize; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./events.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");


/**
 * This module deals with caching images
 * @module ImageCache
 */

var maximumSizeInBytes = 1024 * 1024 * 1024; // 1 GB

var cacheSizeInBytes = 0; // Dictionary of imageId to cachedImage objects

var imageCacheDict = {}; // Array of cachedImage objects

var cachedImages = [];
function setMaximumSizeBytes(numBytes) {
  if (numBytes === undefined) {
    throw new Error('setMaximumSizeBytes: parameter numBytes must not be undefined');
  }

  if (numBytes.toFixed === undefined) {
    throw new Error('setMaximumSizeBytes: parameter numBytes must be a number');
  }

  maximumSizeInBytes = numBytes;
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_MAXIMUM_SIZE_CHANGED);
  purgeCacheIfNecessary();
}

function purgeCacheIfNecessary() {
  // If max cache size has not been exceeded, do nothing
  if (cacheSizeInBytes <= maximumSizeInBytes) {
    return;
  } // Cache size has been exceeded, create list of images sorted by timeStamp
  // So we can purge the least recently used image


  function compare(a, b) {
    if (a.timeStamp > b.timeStamp) {
      return -1;
    }

    if (a.timeStamp < b.timeStamp) {
      return 1;
    }

    return 0;
  }

  cachedImages.sort(compare); // Remove images as necessary)

  while (cacheSizeInBytes > maximumSizeInBytes) {
    var lastCachedImage = cachedImages[cachedImages.length - 1];
    var imageId = lastCachedImage.imageId;
    removeImageLoadObject(imageId);
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_PROMISE_REMOVED, {
      imageId: imageId
    });
  }

  var cacheInfo = getCacheInfo();
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_FULL, cacheInfo);
}

function putImageLoadObject(imageId, imageLoadObject) {
  if (imageId === undefined) {
    throw new Error('putImageLoadObject: imageId must not be undefined');
  }

  if (imageLoadObject.promise === undefined) {
    throw new Error('putImageLoadObject: imageLoadObject.promise must not be undefined');
  }

  if (imageCacheDict.hasOwnProperty(imageId) === true) {
    throw new Error('putImageLoadObject: imageId already in cache');
  }

  if (imageLoadObject.cancelFn && typeof imageLoadObject.cancelFn !== 'function') {
    throw new Error('putImageLoadObject: imageLoadObject.cancelFn must be a function');
  }

  var cachedImage = {
    loaded: false,
    imageId: imageId,
    sharedCacheKey: undefined,
    // The sharedCacheKey for this imageId.  undefined by default
    imageLoadObject: imageLoadObject,
    timeStamp: Date.now(),
    sizeInBytes: 0
  };
  imageCacheDict[imageId] = cachedImage;
  cachedImages.push(cachedImage);
  imageLoadObject.promise.then(function (image) {
    if (cachedImages.indexOf(cachedImage) === -1) {
      // If the image has been purged before being loaded, we stop here.
      return;
    }

    cachedImage.loaded = true;
    cachedImage.image = image;

    if (image.sizeInBytes === undefined) {
      throw new Error('putImageLoadObject: image.sizeInBytes must not be undefined');
    }

    if (image.sizeInBytes.toFixed === undefined) {
      throw new Error('putImageLoadObject: image.sizeInBytes is not a number');
    }

    cachedImage.sizeInBytes = image.sizeInBytes;
    cacheSizeInBytes += cachedImage.sizeInBytes;
    var eventDetails = {
      action: 'addImage',
      image: cachedImage
    };
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_CHANGED, eventDetails);
    cachedImage.sharedCacheKey = image.sharedCacheKey;
    purgeCacheIfNecessary();
  }, function () {
    var cachedImage = imageCacheDict[imageId];
    cachedImages.splice(cachedImages.indexOf(cachedImage), 1);
    delete imageCacheDict[imageId];
  });
}
function getImageLoadObject(imageId) {
  if (imageId === undefined) {
    throw new Error('getImageLoadObject: imageId must not be undefined');
  }

  var cachedImage = imageCacheDict[imageId];

  if (cachedImage === undefined) {
    return;
  } // Bump time stamp for cached image


  cachedImage.timeStamp = Date.now();
  return cachedImage.imageLoadObject;
}
function removeImageLoadObject(imageId) {
  if (imageId === undefined) {
    throw new Error('removeImageLoadObject: imageId must not be undefined');
  }

  var cachedImage = imageCacheDict[imageId];

  if (cachedImage === undefined) {
    throw new Error('removeImageLoadObject: imageId was not present in imageCache');
  }

  cachedImages.splice(cachedImages.indexOf(cachedImage), 1);
  cacheSizeInBytes -= cachedImage.sizeInBytes;
  var eventDetails = {
    action: 'deleteImage',
    image: cachedImage
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_CHANGED, eventDetails);
  decache(cachedImage.imageLoadObject);
  delete imageCacheDict[imageId];
}
function getCacheInfo() {
  return {
    maximumSizeInBytes: maximumSizeInBytes,
    cacheSizeInBytes: cacheSizeInBytes,
    numberOfImagesCached: cachedImages.length
  };
} // This method should only be called by `removeImageLoadObject` because it's
// The one that knows how to deal with shared cache keys and cache size.

function decache(imageLoadObject) {
  imageLoadObject.promise.then(function () {
    if (imageLoadObject.decache) {
      imageLoadObject.decache();
    }
  }, function () {
    if (imageLoadObject.decache) {
      imageLoadObject.decache();
    }
  });
}

function purgeCache() {
  while (cachedImages.length > 0) {
    var removedCachedImage = cachedImages[0];
    removeImageLoadObject(removedCachedImage.imageId);
  }
}
function changeImageIdCacheSize(imageId, newCacheSize) {
  var cacheEntry = imageCacheDict[imageId];

  if (cacheEntry) {
    cacheEntry.imageLoadObject.promise.then(function (image) {
      var cacheSizeDifference = newCacheSize - image.sizeInBytes;
      image.sizeInBytes = newCacheSize;
      cacheEntry.sizeInBytes = newCacheSize;
      cacheSizeInBytes += cacheSizeDifference;
      var eventDetails = {
        action: 'changeImageSize',
        image: image
      };
      Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE_CACHE_CHANGED, eventDetails);
    });
  }
}
/* harmony default export */ __webpack_exports__["default"] = ({
  imageCache: imageCacheDict,
  cachedImages: cachedImages,
  setMaximumSizeBytes: setMaximumSizeBytes,
  putImageLoadObject: putImageLoadObject,
  getImageLoadObject: getImageLoadObject,
  removeImageLoadObject: removeImageLoadObject,
  getCacheInfo: getCacheInfo,
  purgeCache: purgeCache,
  changeImageIdCacheSize: changeImageIdCacheSize
});

/***/ }),

/***/ "./imageLoader.js":
/*!************************!*\
  !*** ./imageLoader.js ***!
  \************************/
/*! exports provided: loadImage, loadAndCacheImage, registerImageLoader, registerUnknownImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAndCacheImage", function() { return loadAndCacheImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerImageLoader", function() { return registerImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerUnknownImageLoader", function() { return registerUnknownImageLoader; });
/* harmony import */ var _imageCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageCache.js */ "./imageCache.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./events.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");



/**
 * This module deals with ImageLoaders, loading images and caching images
 * @module ImageLoader
 */

var imageLoaders = {};
var unknownImageLoader;
/**
 * Load an image using a registered Cornerstone Image Loader.
 *
 * The image loader that is used will be
 * determined by the image loader scheme matching against the imageId.
 *
 * @param {String} imageId A Cornerstone Image Object's imageId
 * @param {Object} [options] Options to be passed to the Image Loader
 *
 * @returns {ImageLoadObject} An Object which can be used to act after an image is loaded or loading fails
 * @memberof ImageLoader
 */

function loadImageFromImageLoader(imageId, options) {
  var colonIndex = imageId.indexOf(':');
  var scheme = imageId.substring(0, colonIndex);
  var loader = imageLoaders[scheme];

  if (loader === undefined || loader === null) {
    if (unknownImageLoader !== undefined) {
      return unknownImageLoader(imageId);
    }

    throw new Error('loadImageFromImageLoader: no image loader for imageId');
  }

  var imageLoadObject = loader(imageId, options); // Broadcast an image loaded event once the image is loaded

  imageLoadObject.promise.then(function (image) {
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_1__["events"], _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE_LOADED, {
      image: image
    });
  }, function (error) {
    var errorObject = {
      imageId: imageId,
      error: error
    };
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_1__["events"], _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE_LOAD_FAILED, errorObject);
  });
  return imageLoadObject;
}
/**
 * Loads an image given an imageId and optional priority and returns a promise which will resolve to
 * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.
 *
 * @param {String} imageId A Cornerstone Image Object's imageId
 * @param {Object} [options] Options to be passed to the Image Loader
 *
 * @returns {ImageLoadObject} An Object which can be used to act after an image is loaded or loading fails
 * @memberof ImageLoader
 */


function loadImage(imageId, options) {
  if (imageId === undefined) {
    throw new Error('loadImage: parameter imageId must not be undefined');
  }

  var imageLoadObject = Object(_imageCache_js__WEBPACK_IMPORTED_MODULE_0__["getImageLoadObject"])(imageId);

  if (imageLoadObject !== undefined) {
    return imageLoadObject.promise;
  }

  return loadImageFromImageLoader(imageId, options).promise;
} //

/**
 * Loads an image given an imageId and optional priority and returns a promise which will resolve to
 * the loaded image object or fail if an error occurred. The image is stored in the cache.
 *
 * @param {String} imageId A Cornerstone Image Object's imageId
 * @param {Object} [options] Options to be passed to the Image Loader
 *
 * @returns {ImageLoadObject} Image Loader Object
 * @memberof ImageLoader
 */

function loadAndCacheImage(imageId, options) {
  if (imageId === undefined) {
    throw new Error('loadAndCacheImage: parameter imageId must not be undefined');
  }

  var imageLoadObject = Object(_imageCache_js__WEBPACK_IMPORTED_MODULE_0__["getImageLoadObject"])(imageId);

  if (imageLoadObject !== undefined) {
    return imageLoadObject.promise;
  }

  imageLoadObject = loadImageFromImageLoader(imageId, options);
  Object(_imageCache_js__WEBPACK_IMPORTED_MODULE_0__["putImageLoadObject"])(imageId, imageLoadObject);
  return imageLoadObject.promise;
}
/**
 * Registers an imageLoader plugin with cornerstone for the specified scheme
 *
 * @param {String} scheme The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')
 * @param {Function} imageLoader A Cornerstone Image Loader function
 * @returns {void}
 * @memberof ImageLoader
 */

function registerImageLoader(scheme, imageLoader) {
  imageLoaders[scheme] = imageLoader;
}
/**
 * Registers a new unknownImageLoader and returns the previous one
 *
 * @param {Function} imageLoader A Cornerstone Image Loader
 *
 * @returns {Function|Undefined} The previous Unknown Image Loader
 * @memberof ImageLoader
 */

function registerUnknownImageLoader(imageLoader) {
  var oldImageLoader = unknownImageLoader;
  unknownImageLoader = imageLoader;
  return oldImageLoader;
}

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: drawImage, generateLut, getDefaultViewport, requestAnimationFrame, storedPixelDataToCanvasImageData, storedColorPixelDataToCanvasImageData, storedPixelDataToCanvasImageDataColorLUT, storedPixelDataToCanvasImageDataPseudocolorLUT, internal, renderLabelMapImage, renderPseudoColorImage, renderColorImage, renderGrayscaleImage, renderWebImage, renderToCanvas, canvasToPixel, disable, displayImage, draw, drawInvalidated, enable, getElementData, removeElementData, getEnabledElement, addEnabledElement, getEnabledElementsByImageId, getEnabledElements, addLayer, removeLayer, getLayer, getLayers, getVisibleLayers, setActiveLayer, getActiveLayer, purgeLayers, setLayerImage, fitToWindow, getDefaultViewportForImage, getImage, getPixels, getStoredPixels, getViewport, loadImage, loadAndCacheImage, registerImageLoader, registerUnknownImageLoader, invalidate, invalidateImageId, pageToPixel, pixelToCanvas, reset, resize, setToPixelCoordinateSystem, setViewport, updateImage, pixelDataToFalseColorData, rendering, imageCache, metaData, webGL, colors, convertImageToFalseColorImage, convertToFalseColorImage, restoreImage, EVENTS, events, triggerEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/drawImage.js */ "./internal/drawImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawImage", function() { return _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _internal_generateLut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/generateLut.js */ "./internal/generateLut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateLut", function() { return _internal_generateLut_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultViewport", function() { return _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _internal_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/requestAnimationFrame.js */ "./internal/requestAnimationFrame.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return _internal_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _internal_storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/storedPixelDataToCanvasImageData.js */ "./internal/storedPixelDataToCanvasImageData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storedPixelDataToCanvasImageData", function() { return _internal_storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _internal_storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/storedColorPixelDataToCanvasImageData.js */ "./internal/storedColorPixelDataToCanvasImageData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storedColorPixelDataToCanvasImageData", function() { return _internal_storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _internal_storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/storedPixelDataToCanvasImageDataColorLUT.js */ "./internal/storedPixelDataToCanvasImageDataColorLUT.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storedPixelDataToCanvasImageDataColorLUT", function() { return _internal_storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _internal_storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js */ "./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storedPixelDataToCanvasImageDataPseudocolorLUT", function() { return _internal_storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./internal/index.js */ "./internal/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "internal", function() { return _internal_index_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rendering/renderLabelMapImage.js */ "./rendering/renderLabelMapImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderLabelMapImage", function() { return _rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_9__["renderLabelMapImage"]; });

/* harmony import */ var _rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rendering/renderPseudoColorImage.js */ "./rendering/renderPseudoColorImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderPseudoColorImage", function() { return _rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_10__["renderPseudoColorImage"]; });

/* harmony import */ var _rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rendering/renderColorImage.js */ "./rendering/renderColorImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderColorImage", function() { return _rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_11__["renderColorImage"]; });

/* harmony import */ var _rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./rendering/renderGrayscaleImage.js */ "./rendering/renderGrayscaleImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderGrayscaleImage", function() { return _rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_12__["renderGrayscaleImage"]; });

/* harmony import */ var _rendering_renderWebImage_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./rendering/renderWebImage.js */ "./rendering/renderWebImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderWebImage", function() { return _rendering_renderWebImage_js__WEBPACK_IMPORTED_MODULE_13__["renderWebImage"]; });

/* harmony import */ var _rendering_renderToCanvas_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rendering/renderToCanvas.js */ "./rendering/renderToCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderToCanvas", function() { return _rendering_renderToCanvas_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _canvasToPixel_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canvasToPixel.js */ "./canvasToPixel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canvasToPixel", function() { return _canvasToPixel_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _disable_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./disable.js */ "./disable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disable", function() { return _disable_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _displayImage_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./displayImage.js */ "./displayImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "displayImage", function() { return _displayImage_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _draw_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./draw.js */ "./draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return _draw_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _drawInvalidated_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./drawInvalidated.js */ "./drawInvalidated.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawInvalidated", function() { return _drawInvalidated_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _enable_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./enable.js */ "./enable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enable", function() { return _enable_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _enabledElementData_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./enabledElementData.js */ "./enabledElementData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getElementData", function() { return _enabledElementData_js__WEBPACK_IMPORTED_MODULE_21__["getElementData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeElementData", function() { return _enabledElementData_js__WEBPACK_IMPORTED_MODULE_21__["removeElementData"]; });

/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEnabledElement", function() { return _enabledElements_js__WEBPACK_IMPORTED_MODULE_22__["getEnabledElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addEnabledElement", function() { return _enabledElements_js__WEBPACK_IMPORTED_MODULE_22__["addEnabledElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEnabledElementsByImageId", function() { return _enabledElements_js__WEBPACK_IMPORTED_MODULE_22__["getEnabledElementsByImageId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEnabledElements", function() { return _enabledElements_js__WEBPACK_IMPORTED_MODULE_22__["getEnabledElements"]; });

/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./layers.js */ "./layers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addLayer", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["addLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeLayer", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["removeLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLayer", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["getLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLayers", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["getLayers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getVisibleLayers", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["getVisibleLayers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setActiveLayer", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["setActiveLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getActiveLayer", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["getActiveLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "purgeLayers", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["purgeLayers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setLayerImage", function() { return _layers_js__WEBPACK_IMPORTED_MODULE_23__["setLayerImage"]; });

/* harmony import */ var _fitToWindow_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./fitToWindow.js */ "./fitToWindow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fitToWindow", function() { return _fitToWindow_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _getDefaultViewportForImage_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./getDefaultViewportForImage.js */ "./getDefaultViewportForImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultViewportForImage", function() { return _getDefaultViewportForImage_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _getImage_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./getImage.js */ "./getImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImage", function() { return _getImage_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _getPixels_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./getPixels.js */ "./getPixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPixels", function() { return _getPixels_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _getStoredPixels_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./getStoredPixels.js */ "./getStoredPixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStoredPixels", function() { return _getStoredPixels_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _getViewport_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./getViewport.js */ "./getViewport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getViewport", function() { return _getViewport_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _imageLoader_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./imageLoader.js */ "./imageLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _imageLoader_js__WEBPACK_IMPORTED_MODULE_30__["loadImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAndCacheImage", function() { return _imageLoader_js__WEBPACK_IMPORTED_MODULE_30__["loadAndCacheImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerImageLoader", function() { return _imageLoader_js__WEBPACK_IMPORTED_MODULE_30__["registerImageLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerUnknownImageLoader", function() { return _imageLoader_js__WEBPACK_IMPORTED_MODULE_30__["registerUnknownImageLoader"]; });

/* harmony import */ var _invalidate_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./invalidate.js */ "./invalidate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invalidate", function() { return _invalidate_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _invalidateImageId_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./invalidateImageId.js */ "./invalidateImageId.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invalidateImageId", function() { return _invalidateImageId_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _pageToPixel_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./pageToPixel.js */ "./pageToPixel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pageToPixel", function() { return _pageToPixel_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _pixelToCanvas_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./pixelToCanvas.js */ "./pixelToCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pixelToCanvas", function() { return _pixelToCanvas_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _reset_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./reset.js */ "./reset.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return _reset_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _resize_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./resize.js */ "./resize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return _resize_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setToPixelCoordinateSystem", function() { return _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _setViewport_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./setViewport.js */ "./setViewport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setViewport", function() { return _setViewport_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "updateImage", function() { return _updateImage_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _pixelDataToFalseColorData_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./pixelDataToFalseColorData.js */ "./pixelDataToFalseColorData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pixelDataToFalseColorData", function() { return _pixelDataToFalseColorData_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _rendering_index_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./rendering/index.js */ "./rendering/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rendering", function() { return _rendering_index_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _imageCache_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./imageCache.js */ "./imageCache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageCache", function() { return _imageCache_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _metaData_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./metaData.js */ "./metaData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metaData", function() { return _metaData_js__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _webgl_index_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./webgl/index.js */ "./webgl/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webGL", function() { return _webgl_index_js__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./colors/index.js */ "./colors/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colors", function() { return _colors_index_js__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _falseColorMapping_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./falseColorMapping.js */ "./falseColorMapping.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertImageToFalseColorImage", function() { return _falseColorMapping_js__WEBPACK_IMPORTED_MODULE_46__["convertImageToFalseColorImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToFalseColorImage", function() { return _falseColorMapping_js__WEBPACK_IMPORTED_MODULE_46__["convertToFalseColorImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restoreImage", function() { return _falseColorMapping_js__WEBPACK_IMPORTED_MODULE_46__["restoreImage"]; });

/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./events.js */ "./events.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EVENTS", function() { return _events_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "events", function() { return _events_js__WEBPACK_IMPORTED_MODULE_47__["events"]; });

/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triggerEvent", function() { return _triggerEvent_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

// Internal (some of these are from old internal/legacy expose)








 // Rendering







/**
 * @module PixelCoordinateSystem
 */

/**
 * @module ViewportSettings
 */




































/***/ }),

/***/ "./internal/calculateTransform.js":
/*!****************************************!*\
  !*** ./internal/calculateTransform.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./internal/transform.js");

/**
 * Calculate the transform for a Cornerstone enabled element
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element
 * @param {Number} [scale] The viewport scale
 * @return {Transform} The current transform
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, scale) {
  var transform = new _transform_js__WEBPACK_IMPORTED_MODULE_0__["Transform"](); // Move to center of canvas

  transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2); // Apply the rotation before scaling for non square pixels

  var angle = enabledElement.viewport.rotation;

  if (angle !== 0) {
    transform.rotate(angle * Math.PI / 180);
  } // Apply the scale


  var widthScale = enabledElement.viewport.scale;
  var heightScale = enabledElement.viewport.scale;
  var width = enabledElement.viewport.displayedArea.brhc.x - (enabledElement.viewport.displayedArea.tlhc.x - 1);
  var height = enabledElement.viewport.displayedArea.brhc.y - (enabledElement.viewport.displayedArea.tlhc.y - 1);

  if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {
    if (enabledElement.image.rowPixelSpacing < enabledElement.image.columnPixelSpacing) {
      widthScale *= enabledElement.image.columnPixelSpacing / enabledElement.image.rowPixelSpacing;
    } else if (enabledElement.image.columnPixelSpacing < enabledElement.image.rowPixelSpacing) {
      heightScale *= enabledElement.image.rowPixelSpacing / enabledElement.image.columnPixelSpacing;
    }
  } else {
    // These should be good for "TRUE SIZE" and "MAGNIFY"
    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;
    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;

    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'SCALE TO FIT') {
      // Fit TRUE IMAGE image (width/height) to window
      var verticalScale = enabledElement.canvas.height / (height * heightScale);
      var horizontalScale = enabledElement.canvas.width / (width * widthScale); // Apply new scale

      widthScale = heightScale = Math.min(horizontalScale, verticalScale);

      if (enabledElement.viewport.displayedArea.rowPixelSpacing < enabledElement.viewport.displayedArea.columnPixelSpacing) {
        widthScale *= enabledElement.viewport.displayedArea.columnPixelSpacing / enabledElement.viewport.displayedArea.rowPixelSpacing;
      } else if (enabledElement.viewport.displayedArea.columnPixelSpacing < enabledElement.viewport.displayedArea.rowPixelSpacing) {
        heightScale *= enabledElement.viewport.displayedArea.rowPixelSpacing / enabledElement.viewport.displayedArea.columnPixelSpacing;
      }
    }
  }

  transform.scale(widthScale, heightScale); // Unrotate to so we can translate unrotated

  if (angle !== 0) {
    transform.rotate(-angle * Math.PI / 180);
  } // Apply the pan offset


  transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y); // Rotate again so we can apply general scale

  if (angle !== 0) {
    transform.rotate(angle * Math.PI / 180);
  }

  if (scale !== undefined) {
    // Apply the font scale
    transform.scale(scale, scale);
  } // Apply Flip if required


  if (enabledElement.viewport.hflip) {
    transform.scale(-1, 1);
  }

  if (enabledElement.viewport.vflip) {
    transform.scale(1, -1);
  } // Move back from center of image


  transform.translate(-width / 2, -height / 2);
  return transform;
});

/***/ }),

/***/ "./internal/computeAutoVoi.js":
/*!************************************!*\
  !*** ./internal/computeAutoVoi.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeAutoVoi; });
/**
 * Computes the VOI to display all the pixels if no VOI LUT data (Window Width/Window Center or voiLUT) exists on the viewport object.
 *
 * @param {Viewport} viewport - Object containing the viewport properties
 * @param {Object} image An Image loaded by a Cornerstone Image Loader
 * @returns {void}
 * @memberof Internal
 */
function computeAutoVoi(viewport, image) {
  if (hasVoi(viewport)) {
    return;
  }

  var maxVoi = image.maxPixelValue * image.slope + image.intercept;
  var minVoi = image.minPixelValue * image.slope + image.intercept;
  var ww = maxVoi - minVoi;
  var wc = (maxVoi + minVoi) / 2;

  if (viewport.voi === undefined) {
    viewport.voi = {
      windowWidth: ww,
      windowCenter: wc
    };
  } else {
    viewport.voi.windowWidth = ww;
    viewport.voi.windowCenter = wc;
  }
}
/**
 * Check if viewport has voi LUT data
 * @param {any} viewport The viewport to check for voi LUT data
 * @returns {Boolean} true viewport has LUT data (Window Width/Window Center or voiLUT). Otherwise, false.
 * @memberof Internal
 */

function hasVoi(viewport) {
  var hasLut = viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;
  return hasLut || viewport.voi.windowWidth !== undefined && viewport.voi.windowCenter !== undefined;
}

/***/ }),

/***/ "./internal/drawCompositeImage.js":
/*!****************************************!*\
  !*** ./internal/drawCompositeImage.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../layers.js */ "./layers.js");
/* harmony import */ var _rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderGrayscaleImage.js */ "./rendering/renderGrayscaleImage.js");
/* harmony import */ var _rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderColorImage.js */ "./rendering/renderColorImage.js");
/* harmony import */ var _rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rendering/renderPseudoColorImage.js */ "./rendering/renderPseudoColorImage.js");
/* harmony import */ var _rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rendering/renderLabelMapImage.js */ "./rendering/renderLabelMapImage.js");
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");







function getViewportRatio(baseLayer, targetLayer) {
  if (!baseLayer.syncProps) {
    updateLayerSyncProps(baseLayer);
  }

  if (!targetLayer.syncProps) {
    updateLayerSyncProps(targetLayer);
  }

  return targetLayer.syncProps.originalScale / baseLayer.syncProps.originalScale;
}

function updateLayerSyncProps(layer) {
  var syncProps = layer.syncProps || {}; // This is used to keep each of the layers' viewports in sync with the active layer

  syncProps.originalScale = layer.viewport.scale;
  layer.syncProps = syncProps;
} // Sync all viewports based on active layer's viewport


function syncViewports(layers, activeLayer) {
  // If we intend to keep the viewport's scale, translation and rotation in sync,
  // loop through the layers
  layers.forEach(function (layer) {
    // Don't do anything to the active layer
    // Don't do anything if this layer has no viewport
    if (layer === activeLayer || !layer.viewport || !activeLayer.viewport) {
      return;
    }

    if (!layer.syncProps) {
      updateLayerSyncProps(layer);
    }

    var viewportRatio = getViewportRatio(activeLayer, layer); // Update the layer's translation and scale to keep them in sync with the first image
    // based on the ratios between the images

    layer.viewport.scale = activeLayer.viewport.scale * viewportRatio;
    layer.viewport.rotation = activeLayer.viewport.rotation;
    layer.viewport.translation = {
      x: activeLayer.viewport.translation.x / viewportRatio,
      y: activeLayer.viewport.translation.y / viewportRatio
    };
    layer.viewport.hflip = activeLayer.viewport.hflip;
    layer.viewport.vflip = activeLayer.viewport.vflip;
  });
}
/**
 * Internal function to render all layers for a Cornerstone enabled element
 *
 * @param {CanvasRenderingContext2D} context Canvas context to draw upon
 * @param {EnabledElementLayer[]} layers The array of all layers for this enabled element
 * @param {Boolean} invalidated A boolean whether or not this image has been invalidated and must be redrawn
 * @returns {void}
 * @memberof Internal
 */


function renderLayers(context, layers, invalidated) {
  // Loop through each layer and draw it to the canvas
  layers.forEach(function (layer, index) {
    if (!layer.image) {
      return;
    }

    context.save(); // Set the layer's canvas to the pixel coordinate system

    layer.canvas = context.canvas;
    Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_5__["default"])(layer, context); // Render into the layer's canvas

    var colormap = layer.viewport.colormap || layer.options.colormap;
    var labelmap = layer.viewport.labelmap;
    var isInvalid = layer.invalid || invalidated;

    if (colormap && colormap !== '' && labelmap === true) {
      Object(_rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_4__["addLabelMapLayer"])(layer, isInvalid);
    } else if (colormap && colormap !== '') {
      Object(_rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_3__["addPseudoColorLayer"])(layer, isInvalid);
    } else if (layer.image.color === true) {
      Object(_rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_2__["addColorLayer"])(layer, isInvalid);
    } else {
      // If this is the base layer, use the alpha channel for rendering of the grayscale image
      var useAlphaChannel = index === 0;
      Object(_rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_1__["addGrayscaleLayer"])(layer, isInvalid, useAlphaChannel);
    } // Apply any global opacity settings that have been defined for this layer


    if (layer.options && layer.options.opacity) {
      context.globalAlpha = layer.options.opacity;
    } else {
      context.globalAlpha = 1;
    }

    if (layer.options && layer.options.fillStyle) {
      context.fillStyle = layer.options.fillStyle;
    } // Set the pixelReplication property before drawing from the layer into the
    // composite canvas


    context.imageSmoothingEnabled = !layer.viewport.pixelReplication;
    context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Draw from the current layer's canvas onto the enabled element's canvas

    var sx = layer.viewport.displayedArea.tlhc.x - 1;
    var sy = layer.viewport.displayedArea.tlhc.y - 1;
    var width = layer.viewport.displayedArea.brhc.x - sx;
    var height = layer.viewport.displayedArea.brhc.y - sy;
    context.drawImage(layer.canvas, sx, sy, width, height, 0, 0, width, height);
    context.restore();
    layer.invalid = false;
  });
}
/**
 * Internal API function to draw a composite image to a given enabled element
 *
 * @param {EnabledElement} enabledElement An enabled element to draw into
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 */


/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, invalidated) {
  var element = enabledElement.element;
  var allLayers = Object(_layers_js__WEBPACK_IMPORTED_MODULE_0__["getLayers"])(element);
  var activeLayer = Object(_layers_js__WEBPACK_IMPORTED_MODULE_0__["getActiveLayer"])(element);
  var visibleLayers = Object(_layers_js__WEBPACK_IMPORTED_MODULE_0__["getVisibleLayers"])(element);
  var resynced = !enabledElement.lastSyncViewportsState && enabledElement.syncViewports; // This state will help us to determine if the user has re-synced the
  // layers allowing us to make a new copy of the viewports

  enabledElement.lastSyncViewportsState = enabledElement.syncViewports; // Stores a copy of all viewports if the user has just synced them then we can use the
  // copies to calculate anything later (ratio, translation offset, rotation offset, etc)

  if (resynced) {
    allLayers.forEach(function (layer) {
      if (layer.viewport) {
        updateLayerSyncProps(layer);
      }
    });
  } // Sync all viewports in case it's activated


  if (enabledElement.syncViewports === true) {
    syncViewports(visibleLayers, activeLayer);
  } // Get the enabled element's canvas so we can draw to it


  var context = enabledElement.canvas.getContext('2d');
  context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

  context.fillStyle = 'black';
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Render all visible layers

  renderLayers(context, visibleLayers, invalidated);
});

/***/ }),

/***/ "./internal/drawImage.js":
/*!*******************************!*\
  !*** ./internal/drawImage.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Internal API function to draw an image to a given enabled element
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} [invalidated] - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof Internal
 */
/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement) {
  var invalidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  enabledElement.needsRedraw = true;

  if (invalidated) {
    enabledElement.invalid = true;
  }
});

/***/ }),

/***/ "./internal/drawImageSync.js":
/*!***********************************!*\
  !*** ./internal/drawImageSync.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");
/* harmony import */ var _drawCompositeImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawCompositeImage.js */ "./internal/drawCompositeImage.js");
/* harmony import */ var _rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderColorImage.js */ "./rendering/renderColorImage.js");
/* harmony import */ var _rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rendering/renderGrayscaleImage.js */ "./rendering/renderGrayscaleImage.js");
/* harmony import */ var _rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rendering/renderPseudoColorImage.js */ "./rendering/renderPseudoColorImage.js");
/* harmony import */ var _rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rendering/renderLabelMapImage.js */ "./rendering/renderLabelMapImage.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events.js */ "./events.js");








/**
 * Draw an image to a given enabled element synchronously
 *
 * @param {EnabledElement} enabledElement An enabled element to draw into
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, invalidated) {
  var image = enabledElement.image;
  var element = enabledElement.element;
  var layers = enabledElement.layers || []; // Check if enabledElement can be redrawn

  if (!enabledElement.canvas || !(enabledElement.image || layers.length)) {
    return;
  } // Start measuring the time needed to draw the image/layers


  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  image.stats = {
    lastGetPixelDataTime: -1.0,
    lastStoredPixelDataToCanvasImageDataTime: -1.0,
    lastPutImageDataTime: -1.0,
    lastRenderTime: -1.0,
    lastLutGenerateTime: -1.0
  };

  if (layers && layers.length) {
    Object(_drawCompositeImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement, invalidated);
  } else if (image) {
    var render = image.render;

    if (!render) {
      if (enabledElement.viewport.colormap && enabledElement.viewport.colormap !== '' && enabledElement.image.labelmap === true) {
        render = _rendering_renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_5__["renderLabelMapImage"];
      } else if (enabledElement.viewport.colormap && enabledElement.viewport.colormap !== '') {
        render = _rendering_renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_4__["renderPseudoColorImage"];
      } else if (image.color) {
        render = _rendering_renderColorImage_js__WEBPACK_IMPORTED_MODULE_2__["renderColorImage"];
      } else {
        render = _rendering_renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_3__["renderGrayscaleImage"];
      }
    }

    render(enabledElement, invalidated);
  } // Calculate how long it took to draw the image/layers


  var renderTimeInMs = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var eventData = {
    viewport: enabledElement.viewport,
    element: element,
    image: image,
    enabledElement: enabledElement,
    canvasContext: enabledElement.canvas.getContext('2d'),
    renderTimeInMs: renderTimeInMs
  };
  image.stats.lastRenderTime = renderTimeInMs;
  enabledElement.invalid = false;
  enabledElement.needsRedraw = false;
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element, _events_js__WEBPACK_IMPORTED_MODULE_7__["default"].IMAGE_RENDERED, eventData);
});

/***/ }),

/***/ "./internal/generateColorLut.js":
/*!**************************************!*\
  !*** ./internal/generateColorLut.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getVOILut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVOILut.js */ "./internal/getVOILut.js");

/**
 * Creates a LUT used while rendering to convert stored pixel values to
 * display pixels
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Number} windowWidth The Window Width
 * @param {Number} windowCenter The Window Center
 * @param {Boolean} invert A boolean describing whether or not the image has been inverted
 * @param {Array} [voiLUT] A Volume of Interest Lookup Table
 *
 * @returns {Uint8ClampedArray} A lookup table to apply to the image
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, windowWidth, windowCenter, invert, voiLUT) {
  var maxPixelValue = image.maxPixelValue;
  var minPixelValue = image.minPixelValue;
  var offset = Math.min(minPixelValue, 0);

  if (image.cachedLut === undefined) {
    var length = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length);
  }

  var lut = image.cachedLut.lutArray;
  var vlutfn = Object(_getVOILut_js__WEBPACK_IMPORTED_MODULE_0__["default"])(windowWidth, windowCenter, voiLUT);

  if (invert === true) {
    for (var storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = 255 - vlutfn(storedValue);
    }
  } else {
    for (var _storedValue = minPixelValue; _storedValue <= maxPixelValue; _storedValue++) {
      lut[_storedValue + -offset] = vlutfn(_storedValue);
    }
  }

  return lut;
});

/***/ }),

/***/ "./internal/generateLut.js":
/*!*********************************!*\
  !*** ./internal/generateLut.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getModalityLUT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getModalityLUT.js */ "./internal/getModalityLUT.js");
/* harmony import */ var _getVOILut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVOILut.js */ "./internal/getVOILut.js");


/**
 * Creates a LUT used while rendering to convert stored pixel values to
 * display pixels
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Number} windowWidth The Window Width
 * @param {Number} windowCenter The Window Center
 * @param {Boolean} invert A boolean describing whether or not the image has been inverted
 * @param {Array} [modalityLUT] A modality Lookup Table
 * @param {Array} [voiLUT] A Volume of Interest Lookup Table
 *
 * @returns {Uint8ClampedArray} A lookup table to apply to the image
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, windowWidth, windowCenter, invert, modalityLUT, voiLUT) {
  var maxPixelValue = image.maxPixelValue;
  var minPixelValue = image.minPixelValue;
  var offset = Math.min(minPixelValue, 0);

  if (image.cachedLut === undefined) {
    var length = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length);
  }

  var lut = image.cachedLut.lutArray;
  var mlutfn = Object(_getModalityLUT_js__WEBPACK_IMPORTED_MODULE_0__["default"])(image.slope, image.intercept, modalityLUT);
  var vlutfn = Object(_getVOILut_js__WEBPACK_IMPORTED_MODULE_1__["default"])(windowWidth, windowCenter, voiLUT);

  if (invert === true) {
    for (var storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));
    }
  } else {
    for (var _storedValue = minPixelValue; _storedValue <= maxPixelValue; _storedValue++) {
      lut[_storedValue + -offset] = vlutfn(mlutfn(_storedValue));
    }
  }

  return lut;
});

/***/ }),

/***/ "./internal/getCanvas.js":
/*!*******************************!*\
  !*** ./internal/getCanvas.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCanvas; });
var CANVAS_CSS_CLASS = 'cornerstone-canvas';
/**
 * Create a canvas and append it to the element
 *
 * @param {HTMLElement} element An HTML Element
 * @return {HTMLElement} canvas A Canvas DOM element
 */

function createCanvas(element) {
  var canvas = document.createElement('canvas');
  canvas.style.display = 'block';
  canvas.classList.add(CANVAS_CSS_CLASS);
  element.appendChild(canvas);
  return canvas;
}
/**
 * Create a canvas or returns the one that already exists for a given element
 *
 * @param {HTMLElement} element An HTML Element
 * @return {HTMLElement} canvas A Canvas DOM element
 */


function getCanvas(element) {
  var selector = "canvas.".concat(CANVAS_CSS_CLASS);
  return element.querySelector(selector) || createCanvas(element);
}

/***/ }),

/***/ "./internal/getDefaultViewport.js":
/*!****************************************!*\
  !*** ./internal/getDefaultViewport.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getImageFitScale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getImageFitScale.js */ "./internal/getImageFitScale.js");

/**
 * Creates a new viewport object containing default values
 *
 * @returns {Viewport} viewport object
 * @memberof Internal
 */

function createViewport() {
  var displayedArea = createDefaultDisplayedArea();
  return {
    scale: 1,
    translation: {
      x: 0,
      y: 0
    },
    voi: {
      windowWidth: undefined,
      windowCenter: undefined
    },
    invert: false,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: undefined,
    voiLUT: undefined,
    colormap: undefined,
    labelmap: false,
    displayedArea: displayedArea
  };
}
/**
 * Creates the default displayed area.
 * C.10.4 Displayed Area Module: This Module describes Attributes required to define a Specified Displayed Area space.
 *
 * @returns {tlhc: {x,y}, brhc: {x, y},rowPixelSpacing: Number, columnPixelSpacing: Number, presentationSizeMode: Number} displayedArea object
 * @memberof Internal
 */


function createDefaultDisplayedArea() {
  return {
    // Top Left Hand Corner
    tlhc: {
      x: 1,
      y: 1
    },
    // Bottom Right Hand Corner
    brhc: {
      x: 1,
      y: 1
    },
    rowPixelSpacing: 1,
    columnPixelSpacing: 1,
    presentationSizeMode: 'NONE'
  };
}
/**
 * Creates a new viewport object containing default values for the image and canvas
 *
 * @param {HTMLElement} canvas A Canvas DOM element
 * @param {Image} image A Cornerstone Image Object
 * @returns {Viewport} viewport object
 * @memberof Internal
 */


/* harmony default export */ __webpack_exports__["default"] = (function (canvas, image) {
  if (canvas === undefined) {
    throw new Error('getDefaultViewport: parameter canvas must not be undefined');
  }

  if (image === undefined) {
    return createViewport();
  } // Fit image to window


  var scale = Object(_getImageFitScale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(canvas, image, 0).scaleFactor;
  return {
    scale: scale,
    translation: {
      x: 0,
      y: 0
    },
    voi: {
      windowWidth: image.windowWidth,
      windowCenter: image.windowCenter
    },
    invert: image.invert,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: image.modalityLUT,
    voiLUT: image.voiLUT,
    colormap: image.colormap,
    labelmap: Boolean(image.labelmap),
    displayedArea: {
      tlhc: {
        x: 1,
        y: 1
      },
      brhc: {
        x: image.columns,
        y: image.rows
      },
      rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,
      columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,
      presentationSizeMode: 'NONE'
    }
  };
});

/***/ }),

/***/ "./internal/getImageFitScale.js":
/*!**************************************!*\
  !*** ./internal/getImageFitScale.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validator.js */ "./internal/validator.js");
/* harmony import */ var _getImageSize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getImageSize.js */ "./internal/getImageSize.js");


/**
 * Calculates the horizontal, vertical and minimum scale factor for an image
   @param {{width, height}} windowSize The window size where the image is displayed. This can be any HTML element or structure with a width, height fields (e.g. canvas).
 * @param {any} image The cornerstone image object
 * @param {Number} rotation Optional. The rotation angle of the image.
 * @return {{horizontalScale, verticalScale, scaleFactor}} The calculated horizontal, vertical and minimum scale factor
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (windowSize, image) {
  var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  Object(_validator_js__WEBPACK_IMPORTED_MODULE_0__["validateParameterUndefinedOrNull"])(windowSize, 'getImageScale: parameter windowSize must not be undefined');
  Object(_validator_js__WEBPACK_IMPORTED_MODULE_0__["validateParameterUndefinedOrNull"])(image, 'getImageScale: parameter image must not be undefined');
  var imageSize = Object(_getImageSize_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image, rotation);
  var rowPixelSpacing = image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing;
  var columnPixelSpacing = image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing;
  var verticalRatio = 1;
  var horizontalRatio = 1;

  if (rowPixelSpacing < columnPixelSpacing) {
    horizontalRatio = columnPixelSpacing / rowPixelSpacing;
  } else {
    // even if they are equal we want to calculate this ratio (the ration might be 0.5)
    verticalRatio = rowPixelSpacing / columnPixelSpacing;
  }

  var verticalScale = windowSize.height / imageSize.height / verticalRatio;
  var horizontalScale = windowSize.width / imageSize.width / horizontalRatio; // Fit image to window

  return {
    verticalScale: verticalScale,
    horizontalScale: horizontalScale,
    scaleFactor: Math.min(horizontalScale, verticalScale)
  };
});

/***/ }),

/***/ "./internal/getImageSize.js":
/*!**********************************!*\
  !*** ./internal/getImageSize.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validator.js */ "./internal/validator.js");

/**
 * Check if the angle is rotated
 * @param {Number} rotation the rotation angle
 * @returns {Boolean} true if the angle is rotated; Otherwise, false.
 * @memberof Internal
 */

function isRotated(rotation) {
  return !(rotation === null || rotation === undefined || rotation === 0 || rotation === 180);
}
/**
 * Retrieves the current image dimensions given an enabled element
 *
 * @param {any} image The Cornerstone image.
 * @param {Number} rotation Optional. The rotation angle of the image.
 * @return {{width:Number, height:Number}} The Image dimensions
 * @memberof Internal
 */


/* harmony default export */ __webpack_exports__["default"] = (function (image) {
  var rotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  Object(_validator_js__WEBPACK_IMPORTED_MODULE_0__["validateParameterUndefinedOrNull"])(image, 'getImageSize: parameter image must not be undefined');
  Object(_validator_js__WEBPACK_IMPORTED_MODULE_0__["validateParameterUndefinedOrNull"])(image.width, 'getImageSize: parameter image must have width');
  Object(_validator_js__WEBPACK_IMPORTED_MODULE_0__["validateParameterUndefinedOrNull"])(image.height, 'getImageSize: parameter image must have height');

  if (isRotated(rotation)) {
    return {
      height: image.width,
      width: image.height
    };
  }

  return {
    width: image.width,
    height: image.height
  };
});

/***/ }),

/***/ "./internal/getModalityLUT.js":
/*!************************************!*\
  !*** ./internal/getModalityLUT.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Generates a linear modality transformation function
 *
 * See DICOM PS3.3 C.11.1 Modality LUT Module
 *
 * http://dicom.nema.org/medical/Dicom/current/output/chtml/part03/sect_C.11.html
 *
 * @param {Number} slope m in the equation specified by Rescale Intercept (0028,1052).
 * @param {Number} intercept The value b in relationship between stored values (SV) and the output units specified in Rescale Type (0028,1054).

 Output units = m*SV + b.
 * @return {function(*): *} A linear modality LUT function. Given a stored pixel it returns the modality pixel value
 * @memberof Internal
 */
function generateLinearModalityLUT(slope, intercept) {
  return function (storedPixelValue) {
    return storedPixelValue * slope + intercept;
  };
}

function generateNonLinearModalityLUT(modalityLUT) {
  var minValue = modalityLUT.lut[0];
  var maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];
  var maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;
  return function (storedPixelValue) {
    if (storedPixelValue < modalityLUT.firstValueMapped) {
      return minValue;
    } else if (storedPixelValue >= maxValueMapped) {
      return maxValue;
    }

    return modalityLUT.lut[storedPixelValue];
  };
}
/**
 * Get the appropriate Modality LUT for the current situation.
 *
 * @param {Number} [slope] m in the equation specified by Rescale Intercept (0028,1052).
 * @param {Number} [intercept] The value b in relationship between stored values (SV) and the output units specified in Rescale Type (0028,1054).
 * @param {Function} [modalityLUT] A modality LUT function. Given a stored pixel it returns the modality pixel value.
 *
 * @return {function(*): *} A modality LUT function. Given a stored pixel it returns the modality pixel value.
 * @memberof Internal
 */


/* harmony default export */ __webpack_exports__["default"] = (function (slope, intercept, modalityLUT) {
  if (modalityLUT) {
    return generateNonLinearModalityLUT(modalityLUT);
  }

  return generateLinearModalityLUT(slope, intercept);
});

/***/ }),

/***/ "./internal/getTransform.js":
/*!**********************************!*\
  !*** ./internal/getTransform.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _calculateTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculateTransform.js */ "./internal/calculateTransform.js");

/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement) {
  // For now we will calculate it every time it is requested.
  // In the future, we may want to cache it in the enabled element to speed things up.
  return Object(_calculateTransform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement);
});

/***/ }),

/***/ "./internal/getVOILut.js":
/*!*******************************!*\
  !*** ./internal/getVOILut.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/* eslint no-bitwise: 0 */

/**
 * Volume of Interest Lookup Table Function
 *
 * @typedef {Function} VOILUTFunction
 *
 * @param {Number} modalityLutValue
 * @returns {Number} transformed value
 * @memberof Objects
 */

/**
 * @module: VOILUT
 */

/**
 *
 * @param {Number} windowWidth Window Width
 * @param {Number} windowCenter Window Center
 * @returns {VOILUTFunction} VOI LUT mapping function
 * @memberof VOILUT
 */
function generateLinearVOILUT(windowWidth, windowCenter) {
  return function (modalityLutValue) {
    return ((modalityLutValue - windowCenter) / windowWidth + 0.5) * 255.0;
  };
}
/**
 * Generate a non-linear volume of interest lookup table
 *
 * @param {LUT} voiLUT Volume of Interest Lookup Table Object
 *
 * @returns {VOILUTFunction} VOI LUT mapping function
 * @memberof VOILUT
 */


function generateNonLinearVOILUT(voiLUT) {
  // We don't trust the voiLUT.numBitsPerEntry, mainly thanks to Agfa!
  var bitsPerEntry = Math.max.apply(Math, _toConsumableArray(voiLUT.lut)).toString(2).length;
  var shift = bitsPerEntry - 8;
  var minValue = voiLUT.lut[0] >> shift;
  var maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;
  var maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;
  return function (modalityLutValue) {
    if (modalityLutValue < voiLUT.firstValueMapped) {
      return minValue;
    } else if (modalityLutValue >= maxValueMapped) {
      return maxValue;
    }

    return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;
  };
}
/**
 * Retrieve a VOI LUT mapping function given the current windowing settings
 * and the VOI LUT for the image
 *
 * @param {Number} windowWidth Window Width
 * @param {Number} windowCenter Window Center
 * @param {LUT} [voiLUT] Volume of Interest Lookup Table Object
 *
 * @return {VOILUTFunction} VOI LUT mapping function
 * @memberof VOILUT
 */


/* harmony default export */ __webpack_exports__["default"] = (function (windowWidth, windowCenter, voiLUT) {
  if (voiLUT) {
    return generateNonLinearVOILUT(voiLUT);
  }

  return generateLinearVOILUT(windowWidth, windowCenter);
});

/***/ }),

/***/ "./internal/guid.js":
/*!**************************!*\
  !*** ./internal/guid.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function s4() {
  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
}
/**
 * Generate a unique identifier
 *
 * @return {string} A unique identifier
 * @memberof Internal
 */


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return "".concat(s4() + s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4()).concat(s4()).concat(s4());
});

/***/ }),

/***/ "./internal/index.js":
/*!***************************!*\
  !*** ./internal/index.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drawImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawImage.js */ "./internal/drawImage.js");
/* harmony import */ var _generateLut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateLut.js */ "./internal/generateLut.js");
/* harmony import */ var _getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requestAnimationFrame.js */ "./internal/requestAnimationFrame.js");
/* harmony import */ var _storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storedPixelDataToCanvasImageData.js */ "./internal/storedPixelDataToCanvasImageData.js");
/* harmony import */ var _storedPixelDataToCanvasImageDataRGBA_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storedPixelDataToCanvasImageDataRGBA.js */ "./internal/storedPixelDataToCanvasImageDataRGBA.js");
/* harmony import */ var _storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storedColorPixelDataToCanvasImageData.js */ "./internal/storedColorPixelDataToCanvasImageData.js");
/* harmony import */ var _storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./storedPixelDataToCanvasImageDataColorLUT.js */ "./internal/storedPixelDataToCanvasImageDataColorLUT.js");
/* harmony import */ var _storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./storedPixelDataToCanvasImageDataPseudocolorLUT.js */ "./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js");
/* harmony import */ var _getTransform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getTransform.js */ "./internal/getTransform.js");
/* harmony import */ var _calculateTransform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./calculateTransform.js */ "./internal/calculateTransform.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform.js */ "./internal/transform.js");












/**
 * @module Internal
 */

/* harmony default export */ __webpack_exports__["default"] = ({
  drawImage: _drawImage_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  generateLut: _generateLut_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  getDefaultViewport: _getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  requestAnimationFrame: _requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  storedPixelDataToCanvasImageData: _storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  storedPixelDataToCanvasImageDataRGBA: _storedPixelDataToCanvasImageDataRGBA_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  storedPixelDataToCanvasImageDataColorLUT: _storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  storedPixelDataToCanvasImageDataPseudocolorLUT: _storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  storedColorPixelDataToCanvasImageData: _storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  getTransform: _getTransform_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  calculateTransform: _calculateTransform_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  Transform: _transform_js__WEBPACK_IMPORTED_MODULE_11__["Transform"]
});

/***/ }),

/***/ "./internal/now.js":
/*!*************************!*\
  !*** ./internal/now.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module Polyfills
 */

/**
 * Use the performance.now() method if possible, and if not, use Date.now()
 *
 * @return {number} Time elapsed since the time origin
 * @memberof Polyfills
 */
/* harmony default export */ __webpack_exports__["default"] = (function () {
  if (window.performance) {
    return performance.now();
  }

  return Date.now();
});

/***/ }),

/***/ "./internal/requestAnimationFrame.js":
/*!*******************************************!*\
  !*** ./internal/requestAnimationFrame.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function requestFrame(callback) {
  window.setTimeout(callback, 1000 / 60);
}
/**
 * Polyfills requestAnimationFrame for older browsers.
 *
 * @param {Function} callback A parameter specifying a function to call when it's time to update your animation for the next repaint. The callback has one single argument, a DOMHighResTimeStamp, which indicates the current time (the time returned from performance.now() ) for when requestAnimationFrame starts to fire callbacks.
 *
 * @return {Number} A long integer value, the request id, that uniquely identifies the entry in the callback list. This is a non-zero value, but you may not make any other assumptions about its value. You can pass this value to window.cancelAnimationFrame() to cancel the refresh callback request.
 * @memberof Polyfills
 */


/* harmony default export */ __webpack_exports__["default"] = (function (callback) {
  return window.requestAnimationFrame(callback) || window.webkitRequestAnimationFrame(callback) || window.mozRequestAnimationFrame(callback) || window.oRequestAnimationFrame(callback) || window.msRequestAnimationFrame(callback) || requestFrame(callback);
});

/***/ }),

/***/ "./internal/storedColorPixelDataToCanvasImageData.js":
/*!***********************************************************!*\
  !*** ./internal/storedColorPixelDataToCanvasImageData.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");

/**
 * Converts stored color pixel values to display pixel values using a LUT.
 *
 * Note: Skips alpha value for any input image pixel data.
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Array} lut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, lut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var numPixels = pixelData.length; // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.
  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement

  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Red

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Green

      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex] + -minPixelValue]; // Blue

      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]]; // Red

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]]; // Green

      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex]]; // Blue

      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
});

/***/ }),

/***/ "./internal/storedPixelDataToCanvasImageData.js":
/*!******************************************************!*\
  !*** ./internal/storedPixelDataToCanvasImageData.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");

/**
 * This function transforms stored pixel values into a canvas image data buffer
 * by using a LUT.  This is the most performance sensitive code in cornerstone and
 * we use a special trick to make this go as fast as possible.  Specifically we
 * use the alpha channel only to control the luminance rather than the red, green and
 * blue channels which makes it over 3x faster. The canvasImageDataData buffer needs
 * to be previously filled with white pixels.
 *
 * NOTE: Attribution would be appreciated if you use this technique!
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Array} lut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, lut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var numPixels = pixelData.length;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 3;
  var storedPixelDataIndex = 0; // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.
  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement
  // Added two paths (Int16Array, Uint16Array) to avoid polymorphic deoptimization in chrome.

  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Alpha

        canvasImageDataIndex += 4;
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]]; // Alpha

        canvasImageDataIndex += 4;
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]]; // Alpha

      canvasImageDataIndex += 4;
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Alpha

      canvasImageDataIndex += 4;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]]; // Alpha

      canvasImageDataIndex += 4;
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
});

/***/ }),

/***/ "./internal/storedPixelDataToCanvasImageDataColorLUT.js":
/*!**************************************************************!*\
  !*** ./internal/storedPixelDataToCanvasImageDataColorLUT.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors/index.js */ "./colors/index.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");


/**
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {LookupTable|Array} colorLut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

function storedPixelDataToCanvasImageDataColorLUT(image, colorLut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  var numPixels = pixelData.length;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var rgba;
  var clut;
  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  if (colorLut instanceof _colors_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].LookupTable) {
    clut = colorLut.Table;
  } else {
    clut = colorLut;
  }

  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      rgba = clut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      rgba = clut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
}

/* harmony default export */ __webpack_exports__["default"] = (storedPixelDataToCanvasImageDataColorLUT);

/***/ }),

/***/ "./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js":
/*!********************************************************************!*\
  !*** ./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors/index.js */ "./colors/index.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");


/**
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Array} grayscaleLut Lookup table array
 * @param {LookupTable|Array} colorLut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

function storedPixelDataToCanvasImageDataPseudocolorLUT(image, grayscaleLut, colorLut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  var numPixels = pixelData.length;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var grayscale;
  var rgba;
  var clut;
  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  if (colorLut instanceof _colors_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].LookupTable) {
    clut = colorLut.Table;
  } else {
    clut = colorLut;
  }

  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
}

/* harmony default export */ __webpack_exports__["default"] = (storedPixelDataToCanvasImageDataPseudocolorLUT);

/***/ }),

/***/ "./internal/storedPixelDataToCanvasImageDataRGBA.js":
/*!**********************************************************!*\
  !*** ./internal/storedPixelDataToCanvasImageDataRGBA.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");

/**
 * This function transforms stored pixel values into a canvas image data buffer
 * by using a LUT.
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Array} lut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, lut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var numPixels = pixelData.length;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var pixelValue; // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.
  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement
  // Added two paths (Int16Array, Uint16Array) to avoid polymorphic deoptimization in chrome.

  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++]];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
});

/***/ }),

/***/ "./internal/storedRGBAPixelDataToCanvasImageData.js":
/*!**********************************************************!*\
  !*** ./internal/storedRGBAPixelDataToCanvasImageData.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./internal/now.js");

/**
 * Converts stored RGBA color pixel values to display pixel values using a LUT.
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Array} lut Lookup table array
 * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels
 *
 * @returns {void}
 * @memberof Internal
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, lut, canvasImageDataData) {
  var start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var numPixels = pixelData.length; // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.
  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement

  start = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Red

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Green

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Blue

      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]]; // Red

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]]; // Green

      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]]; // Blue

      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  }

  image.stats.lastStoredPixelDataToCanvasImageDataTime = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
});

/***/ }),

/***/ "./internal/transform.js":
/*!*******************************!*\
  !*** ./internal/transform.js ***!
  \*******************************/
/*! exports provided: Transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// By Simon Sarris
// Www.simonsarris.com
// Sarris@acm.org
//
// Free to use and distribute at will
// So long as you are nice to people, etc
// Simple class for keeping track of the current transformation matrix
// For instance:
//    Var t = new Transform();
//    T.rotate(5);
//    Var m = t.m;
//    Ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
// Is equivalent to:
//    Ctx.rotate(5);
// But now you can retrieve it :)
// Remember that this does not account for any CSS transforms applied to the canvas
var Transform =
/*#__PURE__*/
function () {
  function Transform() {
    _classCallCheck(this, Transform);

    this.reset();
  }

  _createClass(Transform, [{
    key: "reset",
    value: function reset() {
      this.m = [1, 0, 0, 1, 0, 0];
    }
  }, {
    key: "clone",
    value: function clone() {
      var transform = new Transform();
      transform.m[0] = this.m[0];
      transform.m[1] = this.m[1];
      transform.m[2] = this.m[2];
      transform.m[3] = this.m[3];
      transform.m[4] = this.m[4];
      transform.m[5] = this.m[5];
      return transform;
    }
  }, {
    key: "multiply",
    value: function multiply(matrix) {
      var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
      var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
      var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
      var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
      var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
      var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      this.m[4] = dx;
      this.m[5] = dy;
    }
  }, {
    key: "invert",
    value: function invert() {
      var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
      var m0 = this.m[3] * d;
      var m1 = -this.m[1] * d;
      var m2 = -this.m[2] * d;
      var m3 = this.m[0] * d;
      var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
      var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
    }
  }, {
    key: "rotate",
    value: function rotate(rad) {
      var c = Math.cos(rad);
      var s = Math.sin(rad);
      var m11 = this.m[0] * c + this.m[2] * s;
      var m12 = this.m[1] * c + this.m[3] * s;
      var m21 = this.m[0] * -s + this.m[2] * c;
      var m22 = this.m[1] * -s + this.m[3] * c;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
    }
  }, {
    key: "translate",
    value: function translate(x, y) {
      this.m[4] += this.m[0] * x + this.m[2] * y;
      this.m[5] += this.m[1] * x + this.m[3] * y;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      this.m[0] *= sx;
      this.m[1] *= sx;
      this.m[2] *= sy;
      this.m[3] *= sy;
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(px, py) {
      var x = px;
      var y = py;
      px = x * this.m[0] + y * this.m[2] + this.m[4];
      py = x * this.m[1] + y * this.m[3] + this.m[5];
      return {
        x: px,
        y: py
      };
    }
  }]);

  return Transform;
}();

/***/ }),

/***/ "./internal/tryEnableWebgl.js":
/*!************************************!*\
  !*** ./internal/tryEnableWebgl.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/index.js */ "./webgl/index.js");

/**
 * Checks if webGL is supported and initializes the rendering engine.
 * @param {any} options Options to check if webgl rendering is requested (e.g. enable webgl by passing {renderer: 'webgl'})
 * @returns {Boolean} true if webgl rendering has been successfully initialized. Otherwise, false.
 */

/* harmony default export */ __webpack_exports__["default"] = (function (options) {
  if (_webgl_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].renderer.isWebGLAvailable()) {
    // If WebGL is available on the device, initialize the renderer
    // And return the renderCanvas from the WebGL rendering path
    _webgl_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].renderer.initRenderer();
    options.renderer = 'webgl';
    return true;
  } // If WebGL is not available on this device, we will fall back
  // To using the Canvas renderer


  console.error('WebGL not available, falling back to Canvas renderer');
  delete options.renderer;
  return false;
});

/***/ }),

/***/ "./internal/validator.js":
/*!*******************************!*\
  !*** ./internal/validator.js ***!
  \*******************************/
/*! exports provided: validateParameterUndefined, validateParameterUndefinedOrNull */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateParameterUndefined", function() { return validateParameterUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateParameterUndefinedOrNull", function() { return validateParameterUndefinedOrNull; });
/**
 * Check if the supplied parameter is undefined and throws and error
 * @param {any} checkParam the parameter to validate for undefined
 * @param {any} errorMsg the error message to be thrown
 * @returns {void}
 * @memberof internal
 */
function validateParameterUndefined(checkParam, errorMsg) {
  if (checkParam === undefined) {
    throw new Error(errorMsg);
  }
}
/**
 * Check if the supplied parameter is undefined or null and throws and error
 * @param {any} checkParam the parameter to validate for undefined
 * @param {any} errorMsg the error message to be thrown
 * @returns {void}
 * @memberof internal
 */

function validateParameterUndefinedOrNull(checkParam, errorMsg) {
  if (checkParam === undefined || checkParam === null) {
    throw new Error(errorMsg);
  }
}

/***/ }),

/***/ "./invalidate.js":
/*!***********************!*\
  !*** ./invalidate.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./events.js");



/**
 * Sets the invalid flag on the enabled element and fire an event
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  enabledElement.invalid = true;
  enabledElement.needsRedraw = true;
  var eventData = {
    element: element
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element, _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].INVALIDATED, eventData);
});

/***/ }),

/***/ "./invalidateImageId.js":
/*!******************************!*\
  !*** ./invalidateImageId.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/drawImage.js */ "./internal/drawImage.js");


/**
 * Forces the image to be updated/redrawn for the all enabled elements
 * displaying the specified imageId
 *
 * @param {string} imageId The imageId of the Cornerstone Image Object to redraw
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function (imageId) {
  var enabledElements = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElementsByImageId"])(imageId);
  enabledElements.forEach(function (enabledElement) {
    Object(_internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement, true);
  });
});

/***/ }),

/***/ "./layers.js":
/*!*******************!*\
  !*** ./layers.js ***!
  \*******************/
/*! exports provided: rescaleImage, addLayer, removeLayer, getLayer, getLayers, getVisibleLayers, setActiveLayer, setLayerImage, getActiveLayer, purgeLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rescaleImage", function() { return rescaleImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayer", function() { return addLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeLayer", function() { return removeLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayer", function() { return getLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayers", function() { return getLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVisibleLayers", function() { return getVisibleLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setActiveLayer", function() { return setActiveLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLayerImage", function() { return setLayerImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActiveLayer", function() { return getActiveLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "purgeLayers", function() { return purgeLayers; });
/* harmony import */ var _internal_guid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/guid.js */ "./internal/guid.js");
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events.js */ "./events.js");






/**
 * @module EnabledElementLayers
 */

/**
 * Helper function to trigger an event on a Cornerstone element with
 * a specific layerId
 *
 * @param {String} eventName The event name (e.g. CornerstoneLayerAdded)
 * @param {EnabledElement} enabledElement The Cornerstone enabled element
 * @param {String} layerId The layer's unique identifier
 * @returns {void}
 * @memberof EnabledElementLayers
 */

function triggerEventForLayer(eventName, enabledElement, layerId) {
  var element = enabledElement.element;
  var eventData = {
    viewport: enabledElement.viewport,
    element: enabledElement.element,
    image: enabledElement.image,
    enabledElement: enabledElement,
    layerId: layerId
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element, eventName, eventData);
}
/**
 * Rescale the target layer to the base layer based on the
 * relative size of each image and their pixel dimensions.
 *
 * This function will update the Viewport parameters of the
 * target layer to a new scale.
 *
 * @param {EnabledElementLayer} baseLayer The base layer
 * @param {EnabledElementLayer} targetLayer The target layer to rescale
 * @returns {void}
 * @memberof EnabledElementLayers
 */


function rescaleImage(baseLayer, targetLayer) {
  if (baseLayer.layerId === targetLayer.layerId) {
    throw new Error('rescaleImage: both arguments represent the same layer');
  }

  var baseImage = baseLayer.image;
  var targetImage = targetLayer.image; // Return if these images don't have an imageId (e.g. for dynamic images)

  if (!baseImage.imageId || !targetImage.imageId) {
    return;
  } // Column pixel spacing need to be considered when calculating the
  // ratio between the layer added and base layer images


  var colRelative = targetLayer.viewport.displayedArea.columnPixelSpacing * targetImage.width / (baseLayer.viewport.displayedArea.columnPixelSpacing * baseImage.width);
  var viewportRatio = targetLayer.viewport.scale / baseLayer.viewport.scale * colRelative;
  targetLayer.viewport.scale = baseLayer.viewport.scale * viewportRatio;
}
/**
 * Add a layer to a Cornerstone element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Image} image A Cornerstone Image object to add as a new layer
 * @param {Object} options Options for the layer
 *
 * @returns {String} layerId The new layer's unique identifier
 * @memberof EnabledElementLayers
 */

function addLayer(element, image, options) {
  var layerId = Object(_internal_guid_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  var layers = enabledElement.layers;
  var viewport;

  if (image) {
    viewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement.canvas, image); // Override the defaults if any optional viewport settings
    // have been specified

    if (options && options.viewport) {
      viewport = Object.assign(viewport, options.viewport);
    }
  } // Set syncViewports to true by default when a new layer is added


  if (enabledElement.syncViewports !== false) {
    enabledElement.syncViewports = true;
  }

  var newLayer = {
    image: image,
    layerId: layerId,
    viewport: viewport,
    options: options || {},
    renderingTools: {}
  }; // Rescale the new layer based on the base layer to make sure
  // they will have a proportional size (pixel spacing)

  if (layers.length && image) {
    rescaleImage(layers[0], newLayer);
  }

  layers.push(newLayer);
  triggerEventForLayer(_events_js__WEBPACK_IMPORTED_MODULE_5__["default"].LAYER_ADDED, enabledElement, layerId); // Set the layer as active if it's the first layer added

  if (layers.length === 1 && image) {
    setActiveLayer(element, layerId);
  }

  return layerId;
}
/**
 * Remove a layer from a Cornerstone element given a layer ID
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {String} layerId The unique identifier for the layer
 * @returns {void}
 * @memberof EnabledElementLayers
 */

function removeLayer(element, layerId) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  var layers = enabledElement.layers;
  var index = enabledElement.layers.findIndex(function (layer) {
    return layer.layerId === layerId;
  });

  if (index !== -1) {
    layers.splice(index, 1); // If the current layer is active, and we have other layers,
    // switch to the first layer that remains in the array

    if (layerId === enabledElement.activeLayerId && layers.length) {
      setActiveLayer(element, layers[0].layerId);
    }

    triggerEventForLayer(_events_js__WEBPACK_IMPORTED_MODULE_5__["default"].LAYER_REMOVED, enabledElement, layerId);
  }
}
/**
 * Retrieve a layer from a Cornerstone element given a layer ID
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {String} layerId The unique identifier for the layer
 * @return {EnabledElementLayer} The layer
 * @memberof EnabledElementLayers
 */

function getLayer(element, layerId) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  return enabledElement.layers.find(function (layer) {
    return layer.layerId === layerId;
  });
}
/**
 * Retrieve all layers for a Cornerstone element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 *
 * @return {EnabledElementLayer[]} An array of layers
 * @memberof EnabledElementLayers
 */

function getLayers(element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  return enabledElement.layers;
}
/**
 * Retrieve all visible layers for a Cornerstone element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 *
 * @return {EnabledElementLayer[]} An array of layers
 * @memberof EnabledElementLayers
 */

function getVisibleLayers(element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  return enabledElement.layers.filter(function (layer) {
    return layer.options && layer.options.visible !== false && layer.options.opacity !== 0;
  });
}
/**
 * Set the active layer for a Cornerstone element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {String} layerId The unique identifier for the layer
 * @returns {void}
 * @memberof EnabledElementLayers
 */

function setActiveLayer(element, layerId) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element); // Stop here if this layer is already active

  if (enabledElement.activeLayerId === layerId) {
    return;
  }

  var index = enabledElement.layers.findIndex(function (layer) {
    return layer.layerId === layerId;
  });

  if (index === -1) {
    throw new Error('setActiveLayer: layer not found in layers array');
  }

  var layer = enabledElement.layers[index];

  if (!layer.image) {
    throw new Error('setActiveLayer: layer with undefined image cannot be set as active.');
  }

  enabledElement.activeLayerId = layerId;
  enabledElement.image = layer.image;
  enabledElement.viewport = layer.viewport;
  Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  triggerEventForLayer(_events_js__WEBPACK_IMPORTED_MODULE_5__["default"].ACTIVE_LAYER_CHANGED, enabledElement, layerId);
}
/**
 * Set a new image for a specific layerId
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Image} image The image to be displayed in this layer
 * @param {String} [layerId] The unique identifier for the layer
 * @returns {void}
 * @memberof EnabledElementLayers
 */

function setLayerImage(element, image, layerId) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  var baseLayer = enabledElement.layers[0];
  var layer;

  if (layerId) {
    layer = getLayer(element, layerId);
  } else {
    layer = getActiveLayer(element);
  }

  if (!layer) {
    throw new Error('setLayerImage: Layer not found');
  }

  layer.image = image;

  if (!image) {
    layer.viewport = undefined;
    return;
  }

  if (!layer.viewport) {
    var defaultViewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement.canvas, image); // Override the defaults if any optional viewport settings
    // have been specified

    if (layer.options && layer.options.viewport) {
      layer.viewport = Object.assign(defaultViewport, layer.options.viewport);
    }

    if (baseLayer.layerId !== layerId) {
      rescaleImage(baseLayer, layer);
    }
  }
}
/**
 * Retrieve the currently active layer for a Cornerstone element
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @return {EnabledElementLayer} The currently active layer
 * @memberof EnabledElementLayers
 */

function getActiveLayer(element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  return enabledElement.layers.find(function (layer) {
    return layer.layerId === enabledElement.activeLayerId;
  });
}
/**
 * Purge the layers
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 *
 * @returns {void}
 */

function purgeLayers(element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element);
  enabledElement.layers = [];
  delete enabledElement.activeLayerId;
  delete enabledElement.lastSyncViewportsState;
}

/***/ }),

/***/ "./metaData.js":
/*!*********************!*\
  !*** ./metaData.js ***!
  \*********************/
/*! exports provided: addProvider, removeProvider, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProvider", function() { return addProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeProvider", function() { return removeProvider; });
// This module defines a way to access various metadata about an imageId.  This layer of abstraction exists
// So metadata can be provided in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)
var providers = [];
/**
 * @module Metadata
 */

/**
 * Adds a metadata provider with the specified priority
 * @param {Function} provider Metadata provider function
 * @param {Number} [priority=0] - 0 is default/normal, > 0 is high, < 0 is low
 *
 * @returns {void}
 * @memberof Metadata
 */

function addProvider(provider) {
  var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var i; // Find the right spot to insert this provider based on priority

  for (i = 0; i < providers.length; i++) {
    if (providers[i].priority <= priority) {
      break;
    }
  } // Insert the decode task at position i


  providers.splice(i, 0, {
    priority: priority,
    provider: provider
  });
}
/**
 * Removes the specified provider
 *
 * @param {Function} provider Metadata provider function
 *
 * @returns {void}
 * @memberof Metadata
 */

function removeProvider(provider) {
  for (var i = 0; i < providers.length; i++) {
    if (providers[i].provider === provider) {
      providers.splice(i, 1);
      break;
    }
  }
}
/**
 * Gets metadata from the registered metadata providers.  Will call each one from highest priority to lowest
 * until one responds
 *
 * @param {String} type The type of metadata requested from the metadata store
 * @param {String} imageId The Cornerstone Image Object's imageId
 *
 * @returns {*} The metadata retrieved from the metadata store
 * @memberof Metadata
 */

function getMetaData(type, imageId) {
  // Invoke each provider in priority order until one returns something
  for (var i = 0; i < providers.length; i++) {
    var result = providers[i].provider(type, imageId);

    if (result !== undefined) {
      return result;
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  addProvider: addProvider,
  removeProvider: removeProvider,
  get: getMetaData
});

/***/ }),

/***/ "./pageToPixel.js":
/*!************************!*\
  !*** ./pageToPixel.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getTransform.js */ "./internal/getTransform.js");


/**
 * Converts a point in the page coordinate system to the pixel coordinate
 * system
 *
 * @param {HTMLElement} element The Cornerstone element within which the input point lies
 * @param {Number} pageX The x value in the page coordinate system
 * @param {Number} pageY The y value in the page coordinate system
 *
 * @returns {{x: Number, y: Number}} The transformed point in the pixel coordinate system
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, pageX, pageY) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);

  if (enabledElement.image === undefined) {
    throw new Error('image has not been loaded yet');
  } // Convert the pageX and pageY to the canvas client coordinates


  var rect = element.getBoundingClientRect();
  var clientX = pageX - rect.left - window.pageXOffset;
  var clientY = pageY - rect.top - window.pageYOffset;
  var pt = {
    x: clientX,
    y: clientY
  };
  var transform = Object(_internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement);
  transform.invert();
  return transform.transformPoint(pt.x, pt.y);
});

/***/ }),

/***/ "./pixelDataToFalseColorData.js":
/*!**************************************!*\
  !*** ./pixelDataToFalseColorData.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pixelDataToFalseColorData; });
/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors/index.js */ "./colors/index.js");

/**
 * Converts the image pixel data into a false color data
 *
 * @param {Image} image A Cornerstone Image Object
 * @param {Object} lookupTable A lookup table Object
 *
 * @returns {void}
 * @deprecated This function is superseded by the ability to set the Viewport parameters
 * to include colormaps.
 */

function pixelDataToFalseColorData(image, lookupTable) {
  if (image.color && !image.falseColor) {
    throw new Error('Color transforms are not implemented yet');
  }

  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0;
  var numPixels = image.width * image.height;
  var origPixelData = image.origPixelData || image.getPixelData();
  var storedColorPixelData = new Uint8Array(numPixels * 4);
  var sp;
  var mapped;
  image.color = true;
  image.falseColor = true;
  image.origPixelData = origPixelData;

  if (lookupTable instanceof _colors_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].LookupTable) {
    lookupTable.build();

    while (storedPixelDataIndex < numPixels) {
      sp = origPixelData[storedPixelDataIndex++];
      mapped = lookupTable.mapValue(sp);
      storedColorPixelData[canvasImageDataIndex++] = mapped[0];
      storedColorPixelData[canvasImageDataIndex++] = mapped[1];
      storedColorPixelData[canvasImageDataIndex++] = mapped[2];
      storedColorPixelData[canvasImageDataIndex++] = mapped[3];
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      sp = origPixelData[storedPixelDataIndex++];
      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp + -minPixelValue][0]; // Red

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp + -minPixelValue][1]; // Green

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp + -minPixelValue][2]; // Blue

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp + -minPixelValue][3]; // Alpha
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      sp = origPixelData[storedPixelDataIndex++];
      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp][0]; // Red

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp][1]; // Green

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp][2]; // Blue

      storedColorPixelData[canvasImageDataIndex++] = lookupTable[sp][3]; // Alpha
    }
  }

  image.rgba = true;
  image.cachedLut = undefined;
  image.render = undefined;
  image.slope = 1;
  image.intercept = 0;
  image.minPixelValue = 0;
  image.maxPixelValue = 255;
  image.windowWidth = 255;
  image.windowCenter = 128;

  image.getPixelData = function () {
    return storedColorPixelData;
  };
}

/***/ }),

/***/ "./pixelToCanvas.js":
/*!**************************!*\
  !*** ./pixelToCanvas.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getTransform.js */ "./internal/getTransform.js");


/**
 * Converts a point in the pixel coordinate system to the canvas coordinate system
 * system.  This can be used to render using canvas context without having the weird
 * side effects that come from scaling and non square pixels
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {{x: Number, y: Number}} pt The transformed point in the pixel coordinate system
 *
 * @returns {{x: Number, y: Number}} The input point in the canvas coordinate system
 * @memberof PixelCoordinateSystem
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, pt) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var transform = Object(_internal_getTransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement);
  return transform.transformPoint(pt.x, pt.y);
});

/***/ }),

/***/ "./rendering/doesImageNeedToBeRendered.js":
/*!************************************************!*\
  !*** ./rendering/doesImageNeedToBeRendered.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Determine whether or not an Enabled Element needs to be re-rendered.
 *
 * If the imageId has changed, or if any of the last rendered viewport
 * parameters have changed, this function will return true.
 *
 * @param {EnabledElement} enabledElement An Enabled Element
 * @param {Image} image An Image
 * @return {boolean} Whether or not the Enabled Element needs to re-render its image
 * @memberof rendering
 */
/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, image) {
  var lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;
  var lastRenderedViewport = enabledElement.renderingTools.lastRenderedViewport;
  return image.imageId !== lastRenderedImageId || !lastRenderedViewport || lastRenderedViewport.windowCenter !== enabledElement.viewport.voi.windowCenter || lastRenderedViewport.windowWidth !== enabledElement.viewport.voi.windowWidth || lastRenderedViewport.invert !== enabledElement.viewport.invert || lastRenderedViewport.rotation !== enabledElement.viewport.rotation || lastRenderedViewport.hflip !== enabledElement.viewport.hflip || lastRenderedViewport.vflip !== enabledElement.viewport.vflip || lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT || lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT || lastRenderedViewport.colormap !== enabledElement.viewport.colormap;
});

/***/ }),

/***/ "./rendering/getLut.js":
/*!*****************************!*\
  !*** ./rendering/getLut.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_computeAutoVoi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/computeAutoVoi.js */ "./internal/computeAutoVoi.js");
/* harmony import */ var _lutMatches_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lutMatches.js */ "./rendering/lutMatches.js");
/* harmony import */ var _internal_generateLut_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/generateLut.js */ "./internal/generateLut.js");



/**
 * Retrieve or generate a LUT Array for an Image and Viewport
 *
 * @param {Image} image An Image Object
 * @param {Viewport} viewport An Viewport Object
 * @param {Boolean} invalidated Whether or not the LUT data has been invalidated
 * (e.g. by a change to the windowWidth, windowCenter, or invert viewport parameters).
 * @return {Uint8ClampedArray} LUT Array
 */

/* harmony default export */ __webpack_exports__["default"] = (function (image, viewport, invalidated) {
  // If we have a cached lut and it has the right values, return it immediately
  if (image.cachedLut !== undefined && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && Object(_lutMatches_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image.cachedLut.modalityLUT, viewport.modalityLUT) && Object(_lutMatches_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image.cachedLut.voiLUT, viewport.voiLUT) && image.cachedLut.invert === viewport.invert && invalidated !== true) {
    return image.cachedLut.lutArray;
  }

  Object(_internal_computeAutoVoi_js__WEBPACK_IMPORTED_MODULE_0__["default"])(viewport, image); // Lut is invalid or not present, regenerate it and cache it

  Object(_internal_generateLut_js__WEBPACK_IMPORTED_MODULE_2__["default"])(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  image.cachedLut.voiLUT = viewport.voiLUT;
  image.cachedLut.modalityLUT = viewport.modalityLUT;
  return image.cachedLut.lutArray;
});

/***/ }),

/***/ "./rendering/index.js":
/*!****************************!*\
  !*** ./rendering/index.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderColorImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderColorImage.js */ "./rendering/renderColorImage.js");
/* harmony import */ var _renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderGrayscaleImage.js */ "./rendering/renderGrayscaleImage.js");
/* harmony import */ var _renderWebImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderWebImage.js */ "./rendering/renderWebImage.js");
/* harmony import */ var _renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderPseudoColorImage.js */ "./rendering/renderPseudoColorImage.js");
/* harmony import */ var _renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderLabelMapImage.js */ "./rendering/renderLabelMapImage.js");
/* harmony import */ var _renderToCanvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderToCanvas.js */ "./rendering/renderToCanvas.js");






/**
 * @module rendering
 */

/* harmony default export */ __webpack_exports__["default"] = ({
  colorImage: _renderColorImage_js__WEBPACK_IMPORTED_MODULE_0__["renderColorImage"],
  grayscaleImage: _renderGrayscaleImage_js__WEBPACK_IMPORTED_MODULE_1__["renderGrayscaleImage"],
  webImage: _renderWebImage_js__WEBPACK_IMPORTED_MODULE_2__["renderWebImage"],
  pseudoColorImage: _renderPseudoColorImage_js__WEBPACK_IMPORTED_MODULE_3__["renderPseudoColorImage"],
  labelMapImage: _renderLabelMapImage_js__WEBPACK_IMPORTED_MODULE_4__["renderLabelMapImage"],
  toCanvas: _renderToCanvas_js__WEBPACK_IMPORTED_MODULE_5__["default"]
});

/***/ }),

/***/ "./rendering/initializeRenderCanvas.js":
/*!*********************************************!*\
  !*** ./rendering/initializeRenderCanvas.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, image) {
  var renderCanvas = enabledElement.renderingTools.renderCanvas; // Resize the canvas

  renderCanvas.width = image.width;
  renderCanvas.height = image.height;
  var canvasContext = renderCanvas.getContext('2d'); // NOTE - we need to fill the render canvas with white pixels since we
  // control the luminance using the alpha channel to improve rendering performance.

  canvasContext.fillStyle = 'white';
  canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
  var renderCanvasData = canvasContext.getImageData(0, 0, image.width, image.height);
  enabledElement.renderingTools.renderCanvasContext = canvasContext;
  enabledElement.renderingTools.renderCanvasData = renderCanvasData;
});

/***/ }),

/***/ "./rendering/lutMatches.js":
/*!*********************************!*\
  !*** ./rendering/lutMatches.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Check if two lookup tables match
 *
 * @param {LUT} a A lookup table function
 * @param {LUT} b Another lookup table function
 * @return {boolean} Whether or not they match
 * @memberof rendering
 */
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  // If undefined, they are equal
  if (!a && !b) {
    return true;
  } // If one is undefined, not equal


  if (!a || !b) {
    return false;
  } // Check the unique ids


  return a.id === b.id;
});

/***/ }),

/***/ "./rendering/renderColorImage.js":
/*!***************************************!*\
  !*** ./rendering/renderColorImage.js ***!
  \***************************************/
/*! exports provided: renderColorImage, addColorLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderColorImage", function() { return renderColorImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addColorLayer", function() { return addColorLayer; });
/* harmony import */ var _internal_now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/now.js */ "./internal/now.js");
/* harmony import */ var _internal_generateColorLut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/generateColorLut.js */ "./internal/generateColorLut.js");
/* harmony import */ var _internal_storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/storedColorPixelDataToCanvasImageData.js */ "./internal/storedColorPixelDataToCanvasImageData.js");
/* harmony import */ var _internal_storedRGBAPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/storedRGBAPixelDataToCanvasImageData.js */ "./internal/storedRGBAPixelDataToCanvasImageData.js");
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony import */ var _webgl_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/index.js */ "./webgl/index.js");
/* harmony import */ var _doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./doesImageNeedToBeRendered.js */ "./rendering/doesImageNeedToBeRendered.js");
/* harmony import */ var _initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./initializeRenderCanvas.js */ "./rendering/initializeRenderCanvas.js");
/* harmony import */ var _saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./saveLastRendered.js */ "./rendering/saveLastRendered.js");










function getLut(image, viewport) {
  // If we have a cached lut and it has the right values, return it immediately
  if (image.cachedLut !== undefined && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && image.cachedLut.invert === viewport.invert) {
    return image.cachedLut.lutArray;
  } // Lut is invalid or not present, regenerate it and cache it


  Object(_internal_generateColorLut_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  return image.cachedLut.lutArray;
}

function getRenderCanvas(enabledElement, image, invalidated) {
  var canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor === true;

  if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement('canvas');
  }

  var renderCanvas = enabledElement.renderingTools.renderCanvas; // The ww/wc is identity and not inverted - get a canvas with the image rendered into it for
  // Fast drawing

  if (enabledElement.viewport.voi.windowWidth === 255 && enabledElement.viewport.voi.windowCenter === 128 && enabledElement.viewport.invert === false && image.getCanvas && image.getCanvas()) {
    return image.getCanvas();
  } // Apply the lut to the stored pixel data onto the render canvas


  if (Object(_doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_6__["default"])(enabledElement, image) === false && invalidated !== true) {
    return renderCanvas;
  } // If our render canvas does not match the size of this image reset it
  // NOTE: This might be inefficient if we are updating multiple images of different
  // Sizes frequently.


  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    Object(_initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"])(enabledElement, image);
  } // Get the lut to use


  var start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var colorLut = getLut(image, enabledElement.viewport);
  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  var renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  var renderCanvasContext = enabledElement.renderingTools.renderCanvasContext; // The color image voi/invert has been modified - apply the lut to the underlying
  // Pixel data and put it into the renderCanvas

  if (image.rgba) {
    Object(_internal_storedRGBAPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_3__["default"])(image, colorLut, renderCanvasData.data);
  } else {
    Object(_internal_storedColorPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_2__["default"])(image, colorLut, renderCanvasData.data);
  }

  start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])() - start;
  return renderCanvas;
}
/**
 * API function to render a color image to an enabled element
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof rendering
 */


function renderColorImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error('renderColorImage: enabledElement parameter must not be undefined');
  }

  var image = enabledElement.image;

  if (image === undefined) {
    throw new Error('renderColorImage: image must be loaded before it can be drawn');
  } // Get the canvas context and reset the transform


  var context = enabledElement.canvas.getContext('2d');
  context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

  context.fillStyle = 'black';
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Save the canvas context state and apply the viewport properties

  Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__["default"])(enabledElement, context);
  var renderCanvas;

  if (enabledElement.options && enabledElement.options.renderer && enabledElement.options.renderer.toLowerCase() === 'webgl') {
    // If this enabled element has the option set for WebGL, we should
    // User it as our renderer.
    renderCanvas = _webgl_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].renderer.render(enabledElement);
  } else {
    // If no options are set we will retrieve the renderCanvas through the
    // Normal Canvas rendering path
    renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  }

  var sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  var sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  var width = enabledElement.viewport.displayedArea.brhc.x - sx;
  var height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__["default"])(enabledElement);
}
function addColorLayer(layer, invalidated) {
  if (layer === undefined) {
    throw new Error('addColorLayer: layer parameter must not be undefined');
  }

  var image = layer.image;

  if (image === undefined) {
    throw new Error('addColorLayer: image must be loaded before it can be drawn');
  } // All multi-layer images should include the alpha value


  image.rgba = true;
  layer.canvas = getRenderCanvas(layer, image, invalidated);
  var context = layer.canvas.getContext('2d'); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !layer.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled;
  layer.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__["default"])(layer);
}

/***/ }),

/***/ "./rendering/renderGrayscaleImage.js":
/*!*******************************************!*\
  !*** ./rendering/renderGrayscaleImage.js ***!
  \*******************************************/
/*! exports provided: renderGrayscaleImage, addGrayscaleLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderGrayscaleImage", function() { return renderGrayscaleImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addGrayscaleLayer", function() { return addGrayscaleLayer; });
/* harmony import */ var _internal_storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/storedPixelDataToCanvasImageData.js */ "./internal/storedPixelDataToCanvasImageData.js");
/* harmony import */ var _internal_storedPixelDataToCanvasImageDataRGBA_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/storedPixelDataToCanvasImageDataRGBA.js */ "./internal/storedPixelDataToCanvasImageDataRGBA.js");
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony import */ var _internal_now_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/now.js */ "./internal/now.js");
/* harmony import */ var _webgl_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/index.js */ "./webgl/index.js");
/* harmony import */ var _getLut_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getLut.js */ "./rendering/getLut.js");
/* harmony import */ var _doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./doesImageNeedToBeRendered.js */ "./rendering/doesImageNeedToBeRendered.js");
/* harmony import */ var _initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./initializeRenderCanvas.js */ "./rendering/initializeRenderCanvas.js");
/* harmony import */ var _saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./saveLastRendered.js */ "./rendering/saveLastRendered.js");










function getRenderCanvas(enabledElement, image, invalidated) {
  var useAlphaChannel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor === true;

  if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement('canvas');
    Object(_initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"])(enabledElement, image);
  }

  var renderCanvas = enabledElement.renderingTools.renderCanvas;

  if (Object(_doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_6__["default"])(enabledElement, image) === false && invalidated !== true) {
    return renderCanvas;
  } // If our render canvas does not match the size of this image reset it
  // NOTE: This might be inefficient if we are updating multiple images of different
  // Sizes frequently.


  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    Object(_initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"])(enabledElement, image);
  } // Get the lut to use


  var start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
  var lut = Object(_getLut_js__WEBPACK_IMPORTED_MODULE_5__["default"])(image, enabledElement.viewport, invalidated);
  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])() - start;
  var renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  var renderCanvasContext = enabledElement.renderingTools.renderCanvasContext; // Gray scale image - apply the lut and put the resulting image onto the render canvas

  if (useAlphaChannel) {
    Object(_internal_storedPixelDataToCanvasImageData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(image, lut, renderCanvasData.data);
  } else {
    Object(_internal_storedPixelDataToCanvasImageDataRGBA_js__WEBPACK_IMPORTED_MODULE_1__["default"])(image, lut, renderCanvasData.data);
  }

  start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_3__["default"])() - start;
  return renderCanvas;
}
/**
 * API function to draw a grayscale image to a given enabledElement
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof rendering
 */


function renderGrayscaleImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error('drawImage: enabledElement parameter must not be undefined');
  }

  var image = enabledElement.image;

  if (image === undefined) {
    throw new Error('drawImage: image must be loaded before it can be drawn');
  } // Get the canvas context and reset the transform


  var context = enabledElement.canvas.getContext('2d');
  context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

  context.fillStyle = 'black';
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Save the canvas context state and apply the viewport properties

  Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement, context);
  var renderCanvas;

  if (enabledElement.options && enabledElement.options.renderer && enabledElement.options.renderer.toLowerCase() === 'webgl') {
    // If this enabled element has the option set for WebGL, we should
    // User it as our renderer.
    renderCanvas = _webgl_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].renderer.render(enabledElement);
  } else {
    // If no options are set we will retrieve the renderCanvas through the
    // Normal Canvas rendering path
    renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  }

  var sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  var sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  var width = enabledElement.viewport.displayedArea.brhc.x - sx;
  var height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__["default"])(enabledElement);
}
/**
 * API function to draw a grayscale image to a given layer
 *
 * @param {EnabledElementLayer} layer The layer that the image will be added to
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @param {Boolean} [useAlphaChannel] - Whether or not to render the grayscale image using only the alpha channel.
                                        This does not work if this layer is not the first layer in the enabledElement.
 * @returns {void}
 */

function addGrayscaleLayer(layer, invalidated) {
  var useAlphaChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (layer === undefined) {
    throw new Error('addGrayscaleLayer: layer parameter must not be undefined');
  }

  var image = layer.image;

  if (image === undefined) {
    throw new Error('addGrayscaleLayer: image must be loaded before it can be drawn');
  }

  layer.canvas = getRenderCanvas(layer, image, invalidated, useAlphaChannel);
  var context = layer.canvas.getContext('2d'); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !layer.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled;
  layer.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_8__["default"])(layer);
}

/***/ }),

/***/ "./rendering/renderLabelMapImage.js":
/*!******************************************!*\
  !*** ./rendering/renderLabelMapImage.js ***!
  \******************************************/
/*! exports provided: renderLabelMapImage, addLabelMapLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLabelMapImage", function() { return renderLabelMapImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLabelMapLayer", function() { return addLabelMapLayer; });
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony import */ var _internal_now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/now.js */ "./internal/now.js");
/* harmony import */ var _initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeRenderCanvas.js */ "./rendering/initializeRenderCanvas.js");
/* harmony import */ var _saveLastRendered_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./saveLastRendered.js */ "./rendering/saveLastRendered.js");
/* harmony import */ var _doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./doesImageNeedToBeRendered.js */ "./rendering/doesImageNeedToBeRendered.js");
/* harmony import */ var _internal_storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../internal/storedPixelDataToCanvasImageDataColorLUT.js */ "./internal/storedPixelDataToCanvasImageDataColorLUT.js");
/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../colors/index.js */ "./colors/index.js");








function getRenderCanvas(enabledElement, image, invalidated) {
  if (!enabledElement.renderingTools.renderCanvas) {
    enabledElement.renderingTools.renderCanvas = document.createElement('canvas');
  }

  var renderCanvas = enabledElement.renderingTools.renderCanvas; // TODO: Deprecate enabledElement.options.colormap

  var colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;

  if (colormap && typeof colormap === 'string') {
    colormap = _colors_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].getColormap(colormap);
  }

  if (!colormap) {
    throw new Error('renderLabelMapImage: colormap not found.');
  }

  var colormapId = colormap.getId();

  if (Object(_doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_4__["default"])(enabledElement, image) === false && invalidated !== true && enabledElement.renderingTools.colormapId === colormapId) {
    return renderCanvas;
  } // If our render canvas does not match the size of this image reset it
  // NOTE: This might be inefficient if we are updating multiple images of different
  // Sizes frequently.


  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    Object(_initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement, image);
  } // Get the lut to use


  var start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  if (!enabledElement.renderingTools.colorLut || invalidated || enabledElement.renderingTools.colormapId !== colormapId) {
    enabledElement.renderingTools.colorLut = colormap.createLookupTable();
    enabledElement.renderingTools.colormapId = colormapId;
  }

  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  var colorLut = enabledElement.renderingTools.colorLut;
  var renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  var renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  Object(_internal_storedPixelDataToCanvasImageDataColorLUT_js__WEBPACK_IMPORTED_MODULE_5__["default"])(image, colorLut, renderCanvasData.data);
  start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  return renderCanvas;
}
/**
 * API function to draw a label map image to a given enabledElement
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof rendering
 */


function renderLabelMapImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error('renderLabelMapImage: enabledElement parameter must not be undefined');
  }

  var image = enabledElement.image;

  if (image === undefined) {
    throw new Error('renderLabelMapImage: image must be loaded before it can be drawn');
  } // Get the canvas context and reset the transform


  var context = enabledElement.canvas.getContext('2d');
  context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

  context.fillStyle = 'black';
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Save the canvas context state and apply the viewport properties

  Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement, context); // If no options are set we will retrieve the renderCanvas through the
  // Normal Canvas rendering path
  // TODO: Add WebGL support for label map pipeline

  var renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  var sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  var sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  var width = enabledElement.viewport.displayedArea.brhc.x - sx;
  var height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_3__["default"])(enabledElement);
}
/**
 * API function to draw a pseudo-color image to a given layer
 *
 * @param {EnabledElementLayer} layer The layer that the image will be added to
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 */

function addLabelMapLayer(layer, invalidated) {
  if (layer === undefined) {
    throw new Error('addLabelMapLayer: layer parameter must not be undefined');
  }

  var image = layer.image;

  if (image === undefined) {
    throw new Error('addLabelMapLayer: image must be loaded before it can be drawn');
  }

  layer.canvas = getRenderCanvas(layer, image, invalidated);
  var context = layer.canvas.getContext('2d'); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !layer.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled;
  layer.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_3__["default"])(layer);
}

/***/ }),

/***/ "./rendering/renderPseudoColorImage.js":
/*!*********************************************!*\
  !*** ./rendering/renderPseudoColorImage.js ***!
  \*********************************************/
/*! exports provided: renderPseudoColorImage, addPseudoColorLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderPseudoColorImage", function() { return renderPseudoColorImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPseudoColorLayer", function() { return addPseudoColorLayer; });
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony import */ var _internal_now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/now.js */ "./internal/now.js");
/* harmony import */ var _initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeRenderCanvas.js */ "./rendering/initializeRenderCanvas.js");
/* harmony import */ var _getLut_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getLut.js */ "./rendering/getLut.js");
/* harmony import */ var _saveLastRendered_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./saveLastRendered.js */ "./rendering/saveLastRendered.js");
/* harmony import */ var _doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./doesImageNeedToBeRendered.js */ "./rendering/doesImageNeedToBeRendered.js");
/* harmony import */ var _internal_storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js */ "./internal/storedPixelDataToCanvasImageDataPseudocolorLUT.js");
/* harmony import */ var _colors_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../colors/index.js */ "./colors/index.js");









function getRenderCanvas(enabledElement, image, invalidated) {
  if (!enabledElement.renderingTools.renderCanvas) {
    enabledElement.renderingTools.renderCanvas = document.createElement('canvas');
  }

  var renderCanvas = enabledElement.renderingTools.renderCanvas; // TODO: Deprecate enabledElement.options.colormap

  var colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;

  if (colormap && typeof colormap === 'string') {
    colormap = _colors_index_js__WEBPACK_IMPORTED_MODULE_7__["default"].getColormap(colormap);
  }

  if (!colormap) {
    throw new Error('renderPseudoColorImage: colormap not found.');
  }

  var colormapId = colormap.getId();

  if (Object(_doesImageNeedToBeRendered_js__WEBPACK_IMPORTED_MODULE_5__["default"])(enabledElement, image) === false && invalidated !== true && enabledElement.renderingTools.colormapId === colormapId) {
    return renderCanvas;
  } // If our render canvas does not match the size of this image reset it
  // NOTE: This might be inefficient if we are updating multiple images of different
  // Sizes frequently.


  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    Object(_initializeRenderCanvas_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElement, image);
  } // Get the lut to use


  var start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  if (!enabledElement.renderingTools.colorLut || invalidated || enabledElement.renderingTools.colormapId !== colormapId) {
    colormap.setNumberOfColors(256);
    enabledElement.renderingTools.colorLut = colormap.createLookupTable();
    enabledElement.renderingTools.colormapId = colormapId;
  }

  var lut = Object(_getLut_js__WEBPACK_IMPORTED_MODULE_3__["default"])(image, enabledElement.viewport, invalidated);
  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  var colorLut = enabledElement.renderingTools.colorLut;
  var renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  var renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  Object(_internal_storedPixelDataToCanvasImageDataPseudocolorLUT_js__WEBPACK_IMPORTED_MODULE_6__["default"])(image, lut, colorLut, renderCanvasData.data);
  start = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = Object(_internal_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - start;
  return renderCanvas;
}
/**
 * API function to draw a pseudo-color image to a given enabledElement
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof rendering
 */


function renderPseudoColorImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error('drawImage: enabledElement parameter must not be undefined');
  }

  var image = enabledElement.image;

  if (image === undefined) {
    throw new Error('drawImage: image must be loaded before it can be drawn');
  } // Get the canvas context and reset the transform


  var context = enabledElement.canvas.getContext('2d');
  context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

  context.fillStyle = 'black';
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Save the canvas context state and apply the viewport properties

  Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement, context); // If no options are set we will retrieve the renderCanvas through the
  // Normal Canvas rendering path
  // TODO: Add WebGL support for pseudocolor pipeline

  var renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  var sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  var sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  var width = enabledElement.viewport.displayedArea.brhc.x - sx;
  var height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_4__["default"])(enabledElement);
}
/**
 * API function to draw a pseudo-color image to a given layer
 *
 * @param {EnabledElementLayer} layer The layer that the image will be added to
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 */

function addPseudoColorLayer(layer, invalidated) {
  if (layer === undefined) {
    throw new Error('addPseudoColorLayer: layer parameter must not be undefined');
  }

  var image = layer.image;

  if (image === undefined) {
    throw new Error('addPseudoColorLayer: image must be loaded before it can be drawn');
  }

  layer.canvas = getRenderCanvas(layer, image, invalidated);
  var context = layer.canvas.getContext('2d'); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

  context.imageSmoothingEnabled = !layer.viewport.pixelReplication;
  context.mozImageSmoothingEnabled = context.imageSmoothingEnabled;
  layer.renderingTools = Object(_saveLastRendered_js__WEBPACK_IMPORTED_MODULE_4__["default"])(layer);
}

/***/ }),

/***/ "./rendering/renderToCanvas.js":
/*!*************************************!*\
  !*** ./rendering/renderToCanvas.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./events.js");
/* harmony import */ var _internal_drawImageSync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/drawImageSync.js */ "./internal/drawImageSync.js");
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _internal_tryEnableWebgl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/tryEnableWebgl.js */ "./internal/tryEnableWebgl.js");





/**
 * creates a dummy enabled element
 *
 * @param {any} canvas the canvas that will be assigned to the enabled element.
 * @param {any} image An Image loaded by a Cornerstone Image Loader
 * @param { any } options Options for rendering the image (e.g.enable webgl by {renderer: 'webgl' })
 * @param { any } viewport A set of Cornerstone viewport parameters
 * @returns { element, canvas,image, invalid: Boolean, needsRedraw: Booleans, options, layers: [], data, renderingTools, viewport} a dummy enabled element
 * @memberof rendering
 */

function createEnabledElementStub(canvas, image, options, viewport) {
  return {
    element: canvas,
    canvas: canvas,
    image: image,
    invalid: true,
    // True if image needs to be drawn, false if not
    needsRedraw: true,
    options: options,
    layers: [],
    data: {},
    renderingTools: {},
    viewport: viewport
  };
}
/**
 * Render the image to the provided canvas immediately.
 * @param {any} canvas The HTML canvas where the image will be rendered.
 * @param {any} image An Image loaded by a Cornerstone Image Loader
 * @param {any} viewport A set of Cornerstone viewport parameters
 * @param {any} options Options for rendering the image (e.g. enable webgl by {renderer: 'webgl'})
 * @returns {void}
 * @memberof rendering
 */


/* harmony default export */ __webpack_exports__["default"] = (function (canvas, image) {
  var viewport = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  if (canvas === undefined) {
    throw new Error('renderToCanvas: parameter canvas cannot be undefined');
  } // If this enabled element has the option set for WebGL, we should
  // Check if this device actually supports it


  if (options && options.renderer && options.renderer.toLowerCase() === 'webgl') {
    Object(_internal_tryEnableWebgl_js__WEBPACK_IMPORTED_MODULE_4__["default"])(options);
  }

  var defaultViewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])(canvas, image);

  if (viewport) {
    Object.assign(defaultViewport, viewport);
  }

  var enabledElementStub = createEnabledElementStub(canvas, image, options, defaultViewport);
  var eventDetails = {
    enabledElement: enabledElementStub,
    timestamp: Date.now()
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElementStub.element, _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRE_RENDER, eventDetails);
  Object(_internal_drawImageSync_js__WEBPACK_IMPORTED_MODULE_2__["default"])(enabledElementStub, enabledElementStub.invalid);
});

/***/ }),

/***/ "./rendering/renderWebImage.js":
/*!*************************************!*\
  !*** ./rendering/renderWebImage.js ***!
  \*************************************/
/*! exports provided: renderWebImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderWebImage", function() { return renderWebImage; });
/* harmony import */ var _setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../setToPixelCoordinateSystem.js */ "./setToPixelCoordinateSystem.js");
/* harmony import */ var _renderColorImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderColorImage.js */ "./rendering/renderColorImage.js");


/**
 * API function to draw a standard web image (PNG, JPG) to an enabledImage
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw
 * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used
 * @returns {void}
 * @memberof rendering
 */

function renderWebImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error('renderWebImage: enabledElement parameter must not be undefined');
  }

  var image = enabledElement.image;

  if (image === undefined) {
    throw new Error('renderWebImage: image must be loaded before it can be drawn');
  } // If the viewport ww/wc and invert all match the initial state of the image, we can draw the image
  // Directly. If any of those are changed, we call renderColorImage() to apply the lut


  if (enabledElement.viewport.voi.windowWidth === enabledElement.image.windowWidth && enabledElement.viewport.voi.windowCenter === enabledElement.image.windowCenter && enabledElement.viewport.invert === false) {
    // Get the canvas context and reset the transform
    var context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0); // Clear the canvas

    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height); // Turn off image smooth/interpolation if pixelReplication is set in the viewport

    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    context.mozImageSmoothingEnabled = context.imageSmoothingEnabled; // Save the canvas context state and apply the viewport properties

    Object(_setToPixelCoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement, context);
    var sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    var sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    var width = enabledElement.viewport.displayedArea.brhc.x - sx;
    var height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(image.getImage(), sx, sy, width, height, 0, 0, width, height);
  } else {
    Object(_renderColorImage_js__WEBPACK_IMPORTED_MODULE_1__["renderColorImage"])(enabledElement, invalidated);
  }
}

/***/ }),

/***/ "./rendering/saveLastRendered.js":
/*!***************************************!*\
  !*** ./rendering/saveLastRendered.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement) {
  var imageId = enabledElement.image.imageId;
  var viewport = enabledElement.viewport;
  var isColor = enabledElement.image.color;
  enabledElement.renderingTools.lastRenderedImageId = imageId;
  enabledElement.renderingTools.lastRenderedIsColor = isColor;
  enabledElement.renderingTools.lastRenderedViewport = {
    windowCenter: viewport.voi.windowCenter,
    windowWidth: viewport.voi.windowWidth,
    invert: viewport.invert,
    rotation: viewport.rotation,
    hflip: viewport.hflip,
    vflip: viewport.vflip,
    modalityLUT: viewport.modalityLUT,
    voiLUT: viewport.voiLUT,
    colormap: viewport.colormap
  };
  return enabledElement.renderingTools;
});

/***/ }),

/***/ "./reset.js":
/*!******************!*\
  !*** ./reset.js ***!
  \******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");



/**
 * Resets the viewport to the default settings
 *
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @returns {void}
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  enabledElement.viewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement.canvas, enabledElement.image);
  Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
});

/***/ }),

/***/ "./resize.js":
/*!*******************!*\
  !*** ./resize.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _fitToWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitToWindow.js */ "./fitToWindow.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./triggerEvent.js */ "./triggerEvent.js");
/* harmony import */ var _internal_getImageSize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/getImageSize.js */ "./internal/getImageSize.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events.js */ "./events.js");






/**
 * This module is responsible for enabling an element to display images with cornerstone
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {HTMLElement} canvas The Canvas DOM element within the DOM element enabled for Cornerstone
 * @returns {void}
 */

function setCanvasSize(element, canvas) {
  // The device pixel ratio is 1.0 for normal displays and > 1.0
  // For high DPI displays like Retina

  /*
      This functionality is disabled due to buggy behavior on systems with mixed DPI's.  If the canvas
    is created on a display with high DPI (e.g. 2.0) and then the browser window is dragged to
    a different display with a different DPI (e.g. 1.0), the canvas is not recreated so the pageToPixel
    produces incorrect results.  I couldn't find any way to determine when the DPI changed other than
    by polling which is not very clean.  If anyone has any ideas here, please let me know, but for now
    we will disable this functionality.  We may want
    to add a mechanism to optionally enable this functionality if we can determine it is safe to do
    so (e.g. iPad or iPhone or perhaps enumerate the displays on the system.  I am choosing
    to be cautious here since I would rather not have bug reports or safety issues related to this
    scenario.
      var devicePixelRatio = window.devicePixelRatio;
    if(devicePixelRatio === undefined) {
        devicePixelRatio = 1.0;
    }
    */
  // Avoid setting the same value because it flashes the canvas with IE and Edge
  if (canvas.width !== element.clientWidth) {
    canvas.width = element.clientWidth;
    canvas.style.width = "".concat(element.clientWidth, "px");
  } // Avoid setting the same value because it flashes the canvas with IE and Edge


  if (canvas.height !== element.clientHeight) {
    canvas.height = element.clientHeight;
    canvas.style.height = "".concat(element.clientHeight, "px");
  }
}
/**
 * Checks if the image of a given enabled element fitted the window
 * before the resize
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element
 * @param {number} oldCanvasWidth The width of the canvas before the resize
 * @param {number} oldCanvasHeight The height of the canvas before the resize
 * @return {Boolean} true if it fitted the windows, false otherwise
 */


function wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  var scale = enabledElement.viewport.scale;
  var imageSize = Object(_internal_getImageSize_js__WEBPACK_IMPORTED_MODULE_4__["default"])(enabledElement.image, enabledElement.viewport.rotation);
  var imageWidth = Math.round(imageSize.width * scale);
  var imageHeight = Math.round(imageSize.height * scale);
  var x = enabledElement.viewport.translation.x;
  var y = enabledElement.viewport.translation.y;
  return imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight || imageWidth <= oldCanvasWidth && imageHeight === oldCanvasHeight && x === 0 && y === 0;
}
/**
 * Rescale the image relative to the changed size of the canvas
 *
 * @param {EnabledElement} enabledElement The Cornerstone Enabled Element
 * @param {number} oldCanvasWidth The width of the canvas before the resize
 * @param {number} oldCanvasHeight The height of the canvas before the resize
 * @return {void}
 */


function relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  var scale = enabledElement.viewport.scale;
  var canvasWidth = enabledElement.canvas.width;
  var canvasHeight = enabledElement.canvas.height;
  var relWidthChange = canvasWidth / oldCanvasWidth;
  var relHeightChange = canvasHeight / oldCanvasHeight;
  var relChange = Math.sqrt(relWidthChange * relHeightChange);
  enabledElement.viewport.scale = relChange * scale;
}
/**
 * Resizes an enabled element and optionally fits the image to window
 *
 * @param {HTMLElement} element The DOM element enabled for Cornerstone
 * @param {Boolean} forceFitToWindow true to to force a refit, false to rescale accordingly
 * @returns {void}
 */


/* harmony default export */ __webpack_exports__["default"] = (function (element, forceFitToWindow) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);
  var oldCanvasWidth = enabledElement.canvas.width;
  var oldCanvasHeight = enabledElement.canvas.height;
  setCanvasSize(element, enabledElement.canvas);
  var eventData = {
    element: element
  };
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].ELEMENT_RESIZED, eventData);

  if (enabledElement.image === undefined) {
    return;
  }

  if (forceFitToWindow || wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)) {
    // Fit the image to the window again if it fitted before the resize
    Object(_fitToWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  } else {
    // Adapt the scale of a zoomed or panned image relative to the size change
    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);
    Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  }
});

/***/ }),

/***/ "./setToPixelCoordinateSystem.js":
/*!***************************************!*\
  !*** ./setToPixelCoordinateSystem.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_calculateTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/calculateTransform.js */ "./internal/calculateTransform.js");

/**
 * Sets the canvas context transformation matrix to the pixel coordinate system.  This allows
 * geometry to be driven using the canvas context using coordinates in the pixel coordinate system
 * @param {EnabledElement} enabledElement The
 * @param {CanvasRenderingContext2D} context The CanvasRenderingContext2D for the enabledElement's Canvas
 * @param {Number} [scale] Optional scale to apply
 * @returns {void}
 */

/* harmony default export */ __webpack_exports__["default"] = (function (enabledElement, context, scale) {
  if (enabledElement === undefined) {
    throw new Error('setToPixelCoordinateSystem: parameter enabledElement must not be undefined');
  }

  if (context === undefined) {
    throw new Error('setToPixelCoordinateSystem: parameter context must not be undefined');
  }

  var transform = Object(_internal_calculateTransform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement, scale);
  context.setTransform(transform.m[0], transform.m[1], transform.m[2], transform.m[3], transform.m[4], transform.m[5]);
});

/***/ }),

/***/ "./setViewport.js":
/*!************************!*\
  !*** ./setViewport.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/getDefaultViewport.js */ "./internal/getDefaultViewport.js");
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _updateImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateImage.js */ "./updateImage.js");



var MIN_WINDOW_WIDTH = 0.000001;
var MIN_VIEWPORT_SCALE = 0.0001;
/**
 * Sets/updates viewport of a given enabled element
 *
 * @param {HTMLElement} element - DOM element of the enabled element
 * @param {Viewport} [viewport] - Object containing the viewport properties
 * @returns {void}
 * @memberof ViewportSettings
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element, viewport) {
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_1__["getEnabledElement"])(element); // If viewport is not already set, start with default and merge new
  // viewport options later

  if (enabledElement.viewport === undefined) {
    enabledElement.viewport = Object(_internal_getDefaultViewport_js__WEBPACK_IMPORTED_MODULE_0__["default"])(enabledElement.canvas);
  } // Merge viewport


  if (viewport) {
    for (var attrname in viewport) {
      if (viewport[attrname] !== null) {
        enabledElement.viewport[attrname] = viewport[attrname];
      }
    }
  } // Prevent window width from being too small (note that values close to zero are valid and can occur with
  // PET images in particular)


  if (enabledElement.viewport.voi.windowWidth) {
    enabledElement.viewport.voi.windowWidth = Math.max(viewport.voi.windowWidth, MIN_WINDOW_WIDTH);
  } // Prevent scale from getting too small


  if (enabledElement.viewport.scale) {
    enabledElement.viewport.scale = Math.max(viewport.scale, MIN_VIEWPORT_SCALE);
  } // Normalize the rotation value to a positive rotation in degrees


  enabledElement.viewport.rotation %= 360;

  if (enabledElement.viewport.rotation < 0) {
    enabledElement.viewport.rotation += 360;
  }

  if (enabledElement.image) {
    // Force the image to be updated since the viewport has been modified
    Object(_updateImage_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  }
});

/***/ }),

/***/ "./triggerEvent.js":
/*!*************************!*\
  !*** ./triggerEvent.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return triggerEvent; });
/**
 * Trigger a CustomEvent
 *
 * @param {EventTarget} el The element or EventTarget to trigger the event upon
 * @param {String} type The event type name
 * @param {Object|null} detail=null The event data to be sent
 * @returns {Boolean} The return value is false if at least one event listener called preventDefault(). Otherwise it returns true.
 */
function triggerEvent(el, type) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var event; // This check is needed to polyfill CustomEvent on IE11-

  if (typeof window.CustomEvent === 'function') {
    event = new CustomEvent(type, {
      detail: detail,
      cancelable: true
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, detail);
  }

  return el.dispatchEvent(event);
}

/***/ }),

/***/ "./updateImage.js":
/*!************************!*\
  !*** ./updateImage.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enabledElements_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enabledElements.js */ "./enabledElements.js");
/* harmony import */ var _internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/drawImage.js */ "./internal/drawImage.js");


/**
 * Forces the image to be updated/redrawn for the specified enabled element
 * @param {HTMLElement} element An HTML Element enabled for Cornerstone
 * @param {Boolean} [invalidated=false] Whether or not the image pixel data has been changed, necessitating a redraw
 *
 * @returns {void}
 * @memberof Drawing
 */

/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  var invalidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var enabledElement = Object(_enabledElements_js__WEBPACK_IMPORTED_MODULE_0__["getEnabledElement"])(element);

  if (enabledElement.image === undefined && !enabledElement.layers.length) {
    throw new Error('updateImage: image has not been loaded yet');
  }

  Object(_internal_drawImage_js__WEBPACK_IMPORTED_MODULE_1__["default"])(enabledElement, invalidated);
});

/***/ }),

/***/ "./webgl/createProgramFromString.js":
/*!******************************************!*\
  !*** ./webgl/createProgramFromString.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Creates and compiles a shader.
 *
 * @param {!WebGLRenderingContext} gl The WebGL Context.
 * @param {string} shaderSource The GLSL source code for the shader.
 * @param {number} shaderType The type of shader, VERTEX_SHADER or FRAGMENT_SHADER.
 *
 * @return {!WebGLShader} The shader.
 * @memberof WebGLRendering
 */
function compileShader(gl, shaderSource, shaderType) {
  // Create the shader object
  var shader = gl.createShader(shaderType); // Set the shader source code.

  gl.shaderSource(shader, shaderSource); // Compile the shader

  gl.compileShader(shader); // Check if it compiled

  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (!success && !gl.isContextLost()) {
    // Something went wrong during compilation; get the error
    var infoLog = gl.getShaderInfoLog(shader);
    console.error("Could not compile shader:\n".concat(infoLog));
  }

  return shader;
}
/**
 * Creates a program from 2 shaders.
 *
 * @param {!WebGLRenderingContext} gl The WebGL context.
 * @param {!WebGLShader} vertexShader A vertex shader.
 * @param {!WebGLShader} fragmentShader A fragment shader.
 * @return {!WebGLProgram} A program.
 * @memberof WebGLRendering
 */


function createProgram(gl, vertexShader, fragmentShader) {
  // Create a program.
  var program = gl.createProgram(); // Attach the shaders.

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader); // Link the program.

  gl.linkProgram(program); // Check if it linked.

  var success = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (!success && !gl.isContextLost()) {
    // Something went wrong with the link
    var infoLog = gl.getProgramInfoLog(program);
    console.error("WebGL program filed to link:\n".concat(infoLog));
  }

  return program;
}
/**
 * Creates a program from 2 shaders source (Strings)
 * @param  {!WebGLRenderingContext} gl              The WebGL context.
 * @param  {!WebGLShader} vertexShaderSrc   Vertex shader string
 * @param  {!WebGLShader} fragShaderSrc Fragment shader string
 * @return {!WebGLProgram}                 A program
 * @memberof WebGLRendering
 */


/* harmony default export */ __webpack_exports__["default"] = (function (gl, vertexShaderSrc, fragShaderSrc) {
  var vertexShader = compileShader(gl, vertexShaderSrc, gl.VERTEX_SHADER);
  var fragShader = compileShader(gl, fragShaderSrc, gl.FRAGMENT_SHADER);
  return createProgram(gl, vertexShader, fragShader);
});

/***/ }),

/***/ "./webgl/index.js":
/*!************************!*\
  !*** ./webgl/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ "./webgl/renderer.js");
/* harmony import */ var _createProgramFromString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createProgramFromString.js */ "./webgl/createProgramFromString.js");
/* harmony import */ var _textureCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textureCache.js */ "./webgl/textureCache.js");



/**
 * @module WebGLRendering
 */

var mod = {
  createProgramFromString: _createProgramFromString_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  renderer: {
    render: _renderer_js__WEBPACK_IMPORTED_MODULE_0__["render"],
    initRenderer: _renderer_js__WEBPACK_IMPORTED_MODULE_0__["initRenderer"],
    getRenderCanvas: _renderer_js__WEBPACK_IMPORTED_MODULE_0__["getRenderCanvas"],
    isWebGLAvailable: _renderer_js__WEBPACK_IMPORTED_MODULE_0__["isWebGLAvailable"]
  },
  textureCache: _textureCache_js__WEBPACK_IMPORTED_MODULE_2__["default"]
};
Object.defineProperty(mod, 'isWebGLInitialized', {
  enumerable: true,
  configurable: false,
  get: function get() {
    return _renderer_js__WEBPACK_IMPORTED_MODULE_0__["isWebGLInitialized"];
  }
});
/* harmony default export */ __webpack_exports__["default"] = (mod);

/***/ }),

/***/ "./webgl/renderer.js":
/*!***************************!*\
  !*** ./webgl/renderer.js ***!
  \***************************/
/*! exports provided: isWebGLInitialized, getRenderCanvas, initRenderer, render, isWebGLAvailable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGLInitialized", function() { return isWebGLInitialized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRenderCanvas", function() { return getRenderCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initRenderer", function() { return initRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGLAvailable", function() { return isWebGLAvailable; });
/* harmony import */ var _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/index.js */ "./webgl/shaders/index.js");
/* harmony import */ var _vertexShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vertexShader.js */ "./webgl/vertexShader.js");
/* harmony import */ var _textureCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textureCache.js */ "./webgl/textureCache.js");
/* harmony import */ var _createProgramFromString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createProgramFromString.js */ "./webgl/createProgramFromString.js");
/* eslint no-bitwise: 0 */




var renderCanvas = document.createElement('canvas');
var gl;
var texCoordBuffer;
var positionBuffer;
var isWebGLInitialized = false;

function getRenderCanvas() {
  return renderCanvas;
}

function initShaders() {
  for (var id in _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["shaders"]) {
    // Console.log("WEBGL: Loading shader", id);
    var shader = _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["shaders"][id];
    shader.attributes = {};
    shader.uniforms = {};
    shader.vert = _vertexShader_js__WEBPACK_IMPORTED_MODULE_1__["vertexShader"];
    shader.program = Object(_createProgramFromString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(gl, shader.vert, shader.frag);
    shader.attributes.texCoordLocation = gl.getAttribLocation(shader.program, 'a_texCoord');
    gl.enableVertexAttribArray(shader.attributes.texCoordLocation);
    shader.attributes.positionLocation = gl.getAttribLocation(shader.program, 'a_position');
    gl.enableVertexAttribArray(shader.attributes.positionLocation);
    shader.uniforms.resolutionLocation = gl.getUniformLocation(shader.program, 'u_resolution');
  }
}

function initRenderer() {
  if (isWebGLInitialized === true) {
    // Console.log("WEBGL Renderer already initialized");
    return;
  }

  if (initWebGL(renderCanvas)) {
    initBuffers();
    initShaders(); // Console.log("WEBGL Renderer initialized!");

    isWebGLInitialized = true;
  }
}

function updateRectangle(gl, width, height) {
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([width, height, 0, height, width, 0, 0, 0]), gl.STATIC_DRAW);
}

function handleLostContext(event) {
  event.preventDefault();
  console.warn('WebGL Context Lost!');
}

function handleRestoredContext(event) {
  event.preventDefault();
  isWebGLInitialized = false;
  _textureCache_js__WEBPACK_IMPORTED_MODULE_2__["default"].purgeCache();
  initRenderer(); // Console.log('WebGL Context Restored.');
}

function initWebGL(canvas) {
  gl = null;

  try {
    // Try to grab the standard context. If it fails, fallback to experimental.
    var options = {
      preserveDrawingBuffer: true // Preserve buffer so we can copy to display canvas element

    }; // ---------------- Testing purposes -------------
    // If (debug === true && WebGLDebugUtils) {
    //    RenderCanvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(renderCanvas);
    // }
    // ---------------- Testing purposes -------------

    gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options); // Set up event listeners for context lost / context restored

    canvas.removeEventListener('webglcontextlost', handleLostContext, false);
    canvas.addEventListener('webglcontextlost', handleLostContext, false);
    canvas.removeEventListener('webglcontextrestored', handleRestoredContext, false);
    canvas.addEventListener('webglcontextrestored', handleRestoredContext, false);
  } catch (error) {
    throw new Error('Error creating WebGL context');
  } // If we don't have a GL context, give up now


  if (!gl) {
    console.error('Unable to initialize WebGL. Your browser may not support it.');
    gl = null;
  }

  return gl;
}
/**
 * Returns the image data type as a string representation.
 * @param {any} image The cornerstone image object
 * @returns {string} image data type (rgb, iint16, uint16, int8 and uint8)
 * @memberof WebGLRendering
 */


function getImageDataType(image) {
  if (image.color) {
    return 'rgb';
  }

  var pixelData = image.getPixelData();

  if (pixelData instanceof Int16Array) {
    return 'int16';
  }

  if (pixelData instanceof Uint16Array) {
    return 'uint16';
  }

  if (pixelData instanceof Int8Array) {
    return 'int8';
  }

  return 'uint8';
}

function getShaderProgram(image) {
  var datatype = getImageDataType(image); // We need a mechanism for
  // Choosing the shader based on the image datatype
  // Console.log("Datatype: " + datatype);

  if (_shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["shaders"].hasOwnProperty(datatype)) {
    return _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["shaders"][datatype];
  }

  return _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["shaders"].rgb;
}

function generateTexture(image) {
  var TEXTURE_FORMAT = {
    uint8: gl.LUMINANCE,
    int8: gl.LUMINANCE_ALPHA,
    uint16: gl.LUMINANCE_ALPHA,
    int16: gl.RGB,
    rgb: gl.RGB
  };
  var TEXTURE_BYTES = {
    int8: 1,
    // Luminance
    uint16: 2,
    // Luminance + Alpha
    int16: 3,
    // RGB
    rgb: 3 // RGB

  };
  var imageDataType = getImageDataType(image);
  var format = TEXTURE_FORMAT[imageDataType]; // GL texture configuration

  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  var imageData = _shaders_index_js__WEBPACK_IMPORTED_MODULE_0__["dataUtilities"][imageDataType].storedPixelDataToImageData(image, image.width, image.height);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, image.width, image.height, 0, format, gl.UNSIGNED_BYTE, imageData); // Calculate the size in bytes of this image in memory

  var sizeInBytes = image.width * image.height * TEXTURE_BYTES[imageDataType];
  return {
    texture: texture,
    sizeInBytes: sizeInBytes
  };
}

function getImageTexture(image) {
  var imageTexture = _textureCache_js__WEBPACK_IMPORTED_MODULE_2__["default"].getImageTexture(image.imageId);

  if (!imageTexture) {
    // Console.log("Generating texture for imageid: ", image.imageId);
    imageTexture = generateTexture(image);
    _textureCache_js__WEBPACK_IMPORTED_MODULE_2__["default"].putImageTexture(image, imageTexture);
  }

  return imageTexture.texture;
}

function initBuffers() {
  positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 0, 1, 1, 0, 0, 0]), gl.STATIC_DRAW);
  texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0]), gl.STATIC_DRAW);
}

function renderQuad(shader, parameters, texture, width, height) {
  gl.clearColor(1.0, 0.0, 0.0, 1.0);
  gl.viewport(0, 0, width, height);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.useProgram(shader.program);
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.vertexAttribPointer(shader.attributes.texCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(shader.attributes.positionLocation, 2, gl.FLOAT, false, 0, 0);

  for (var key in parameters) {
    var uniformLocation = gl.getUniformLocation(shader.program, key);

    if (!uniformLocation) {
      continue; // Disabling this error for now since RGB requires minPixelValue
      // but the other shaders do not.
      // throw `Could not access location for uniform: ${key}`;
    }

    var uniform = parameters[key];
    var type = uniform.type;
    var value = uniform.value;

    if (type === 'i') {
      gl.uniform1i(uniformLocation, value);
    } else if (type === 'f') {
      gl.uniform1f(uniformLocation, value);
    } else if (type === '2f') {
      gl.uniform2f(uniformLocation, value[0], value[1]);
    }
  }

  updateRectangle(gl, width, height);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function render(enabledElement) {
  // Resize the canvas
  var image = enabledElement.image;
  renderCanvas.width = image.width;
  renderCanvas.height = image.height;
  var viewport = enabledElement.viewport; // Render the current image

  var shader = getShaderProgram(image);
  var texture = getImageTexture(image);
  var parameters = {
    u_resolution: {
      type: '2f',
      value: [image.width, image.height]
    },
    wc: {
      type: 'f',
      value: viewport.voi.windowCenter
    },
    ww: {
      type: 'f',
      value: viewport.voi.windowWidth
    },
    slope: {
      type: 'f',
      value: image.slope
    },
    intercept: {
      type: 'f',
      value: image.intercept
    },
    minPixelValue: {
      type: 'f',
      value: image.minPixelValue
    },
    invert: {
      type: 'i',
      value: viewport.invert ? 1 : 0
    }
  };
  renderQuad(shader, parameters, texture, image.width, image.height);
  return renderCanvas;
}
function isWebGLAvailable() {
  // Adapted from
  // http://stackoverflow.com/questions/9899807/three-js-detect-webgl-support-and-fallback-to-regular-canvas
  var options = {
    failIfMajorPerformanceCaveat: true
  };

  try {
    var canvas = document.createElement('canvas');
    return Boolean(window.WebGLRenderingContext) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "./webgl/shaders/index.js":
/*!********************************!*\
  !*** ./webgl/shaders/index.js ***!
  \********************************/
/*! exports provided: shaders, dataUtilities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shaders", function() { return shaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataUtilities", function() { return dataUtilities; });
/* harmony import */ var _int16_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./int16.js */ "./webgl/shaders/int16.js");
/* harmony import */ var _int8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./int8.js */ "./webgl/shaders/int8.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rgb.js */ "./webgl/shaders/rgb.js");
/* harmony import */ var _uint16_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uint16.js */ "./webgl/shaders/uint16.js");
/* harmony import */ var _uint8_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uint8.js */ "./webgl/shaders/uint8.js");





var shaders = {
  int16: _int16_js__WEBPACK_IMPORTED_MODULE_0__["int16Shader"],
  int8: _int8_js__WEBPACK_IMPORTED_MODULE_1__["int8Shader"],
  rgb: _rgb_js__WEBPACK_IMPORTED_MODULE_2__["rgbShader"],
  uint16: _uint16_js__WEBPACK_IMPORTED_MODULE_3__["uint16Shader"],
  uint8: _uint8_js__WEBPACK_IMPORTED_MODULE_4__["uint8Shader"]
};
var dataUtilities = {
  int16: _int16_js__WEBPACK_IMPORTED_MODULE_0__["int16DataUtilities"],
  int8: _int8_js__WEBPACK_IMPORTED_MODULE_1__["int8DataUtilities"],
  rgb: _rgb_js__WEBPACK_IMPORTED_MODULE_2__["rgbDataUtilities"],
  uint16: _uint16_js__WEBPACK_IMPORTED_MODULE_3__["uint16DataUtilities"],
  uint8: _uint8_js__WEBPACK_IMPORTED_MODULE_4__["uint8DataUtilities"]
};


/***/ }),

/***/ "./webgl/shaders/int16.js":
/*!********************************!*\
  !*** ./webgl/shaders/int16.js ***!
  \********************************/
/*! exports provided: int16DataUtilities, int16Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int16DataUtilities", function() { return int16DataUtilities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int16Shader", function() { return int16Shader; });
/* eslint no-bitwise: 0 */
var int16Shader = {};
/**
 * Convert stored pixel data to image data.
 *
 * Pack int16 into three uint8 channels (r, g, b)
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Uint8Array} The image data for use by the WebGL shader
 * @memberof WebGLRendering
 */

function storedPixelDataToImageData(image) {
  // Transfer image data to alpha and luminance channels of WebGL texture
  // Credit to @jpambrun and @fernandojsg
  // Pack int16 into three uint8 channels (r, g, b)
  var pixelData = image.getPixelData();
  var numberOfChannels = 3;
  var data = new Uint8Array(image.width * image.height * numberOfChannels);
  var offset = 0;

  for (var i = 0; i < pixelData.length; i++) {
    var val = Math.abs(pixelData[i]);
    data[offset++] = val & 0xFF;
    data[offset++] = val >> 8;
    data[offset++] = pixelData[i] < 0 ? 0 : 1; // 0 For negative, 1 for positive
  }

  return data;
}

var int16DataUtilities = {
  storedPixelDataToImageData: storedPixelDataToImageData
};
int16Shader.frag = 'precision mediump float;' + 'uniform sampler2D u_image;' + 'uniform float ww;' + 'uniform float wc;' + 'uniform float slope;' + 'uniform float intercept;' + 'uniform int invert;' + 'varying vec2 v_texCoord;' + 'void main() {' + // Get texture
'vec4 color = texture2D(u_image, v_texCoord);' + // Calculate luminance from packed texture
'float intensity = color.r*256.0 + color.g*65536.0;' + 'if (color.b == 0.0)' + 'intensity = -intensity;' + // Rescale based on slope and window settings
'intensity = intensity * slope + intercept;' + 'float center0 = wc - 0.5;' + 'float width0 = max(ww, 1.0);' + 'intensity = (intensity - center0) / width0 + 0.5;' + // Clamp intensity
'intensity = clamp(intensity, 0.0, 1.0);' + // RGBA output
'gl_FragColor = vec4(intensity, intensity, intensity, 1.0);' + // Apply any inversion necessary
'if (invert == 1)' + 'gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;' + '}';


/***/ }),

/***/ "./webgl/shaders/int8.js":
/*!*******************************!*\
  !*** ./webgl/shaders/int8.js ***!
  \*******************************/
/*! exports provided: int8DataUtilities, int8Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int8DataUtilities", function() { return int8DataUtilities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int8Shader", function() { return int8Shader; });
var int8Shader = {};
/**
 * Convert stored pixel data to image data.
 *
 * Store data in Uint8Array
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Uint8Array} The image data for use by the WebGL shader
 * @memberof WebGLRendering
 */

function storedPixelDataToImageData(image) {
  // Transfer image data to alpha channel of WebGL texture
  // Store data in Uint8Array
  var pixelData = image.getPixelData();
  var numberOfChannels = 2;
  var data = new Uint8Array(image.width * image.height * numberOfChannels);
  var offset = 0;

  for (var i = 0; i < pixelData.length; i++) {
    data[offset++] = pixelData[i];
    data[offset++] = pixelData[i] < 0 ? 0 : 1; // 0 For negative, 1 for positive
  }

  return data;
}

var int8DataUtilities = {
  storedPixelDataToImageData: storedPixelDataToImageData
};
int8Shader.frag = 'precision mediump float;' + 'uniform sampler2D u_image;' + 'uniform float ww;' + 'uniform float wc;' + 'uniform float slope;' + 'uniform float intercept;' + 'uniform int invert;' + 'varying vec2 v_texCoord;' + 'void main() {' + // Get texture
'vec4 color = texture2D(u_image, v_texCoord);' + // Calculate luminance from packed texture
'float intensity = color.r*256.;' + 'if (color.a == 0.0)' + 'intensity = -intensity;' + // Rescale based on slope and window settings
'intensity = intensity * slope + intercept;' + 'float center0 = wc - 0.5;' + 'float width0 = max(ww, 1.0);' + 'intensity = (intensity - center0) / width0 + 0.5;' + // Clamp intensity
'intensity = clamp(intensity, 0.0, 1.0);' + // RGBA output
'gl_FragColor = vec4(intensity, intensity, intensity, 1.0);' + // Apply any inversion necessary
'if (invert == 1)' + 'gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;' + '}';


/***/ }),

/***/ "./webgl/shaders/rgb.js":
/*!******************************!*\
  !*** ./webgl/shaders/rgb.js ***!
  \******************************/
/*! exports provided: rgbDataUtilities, rgbShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbDataUtilities", function() { return rgbDataUtilities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbShader", function() { return rgbShader; });
var rgbShader = {};
/**
 * Convert stored pixel data to image data.
 *
 * Pack RGB images into a 3-channel RGB texture
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Uint8Array} The image data for use by the WebGL shader
 * @memberof WebGLRendering
 */

function storedPixelDataToImageData(image) {
  var minPixelValue = image.minPixelValue;
  var canvasImageDataIndex = 0;
  var storedPixelDataIndex = 0; // Only 3 channels, since we use WebGL's RGB texture format

  var numStoredPixels = image.width * image.height * 4;
  var numOutputPixels = image.width * image.height * 3;
  var storedPixelData = image.getPixelData();
  var data = new Uint8Array(numOutputPixels); // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.
  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement

  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numStoredPixels) {
      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + -minPixelValue; // Red

      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + -minPixelValue; // Green

      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + -minPixelValue; // Blue

      storedPixelDataIndex += 1; // The stored pixel data has 4 channels
    }
  } else {
    while (storedPixelDataIndex < numStoredPixels) {
      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; // Red

      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; // Green

      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; // Blue

      storedPixelDataIndex += 1; // The stored pixel data has 4 channels
    }
  }

  return data;
}

var rgbDataUtilities = {
  storedPixelDataToImageData: storedPixelDataToImageData
};
rgbShader.frag = 'precision mediump float;' + 'uniform sampler2D u_image;' + 'uniform float ww;' + 'uniform float wc;' + 'uniform float slope;' + 'uniform float intercept;' + 'uniform float minPixelValue;' + 'uniform int invert;' + 'varying vec2 v_texCoord;' + 'void main() {' + // Get texture
'vec3 color = texture2D(u_image, v_texCoord).xyz;' + // Rescale based on slope and intercept
'color = color * 256.0 * slope + intercept;' + // Apply window settings
'float center0 = wc - 0.5 - minPixelValue;' + 'float width0 = max(ww, 1.0);' + 'color = (color - center0) / width0 + 0.5;' + // RGBA output
'gl_FragColor = vec4(color, 1);' + // Apply any inversion necessary
'if (invert == 1)' + 'gl_FragColor.rgb = 1. - gl_FragColor.rgb;' + '}';


/***/ }),

/***/ "./webgl/shaders/uint16.js":
/*!*********************************!*\
  !*** ./webgl/shaders/uint16.js ***!
  \*********************************/
/*! exports provided: uint16DataUtilities, uint16Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint16DataUtilities", function() { return uint16DataUtilities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint16Shader", function() { return uint16Shader; });
/* eslint no-bitwise: 0 */
var uint16Shader = {};
/**
 * Convert stored pixel data to image data.
 *
 * For uint16 pack uint16 into two uint8 channels (r and a).
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Uint8Array} The image data for use by the WebGL shader
 * @memberof WebGLRendering
 */

function storedPixelDataToImageData(image) {
  // Transfer image data to alpha and luminance channels of WebGL texture
  // Credit to @jpambrun and @fernandojsg
  // Pack uint16 into two uint8 channels (r and a)
  var pixelData = image.getPixelData();
  var numberOfChannels = 2;
  var data = new Uint8Array(image.width * image.height * numberOfChannels);
  var offset = 0;

  for (var i = 0; i < pixelData.length; i++) {
    var val = pixelData[i];
    data[offset++] = val & 0xFF;
    data[offset++] = val >> 8;
  }

  return data;
}

var uint16DataUtilities = {
  storedPixelDataToImageData: storedPixelDataToImageData
};
uint16Shader.frag = 'precision mediump float;' + 'uniform sampler2D u_image;' + 'uniform float ww;' + 'uniform float wc;' + 'uniform float slope;' + 'uniform float intercept;' + 'uniform int invert;' + 'varying vec2 v_texCoord;' + 'void main() {' + // Get texture
'vec4 color = texture2D(u_image, v_texCoord);' + // Calculate luminance from packed texture
'float intensity = color.r*256.0 + color.a*65536.0;' + // Rescale based on slope and window settings
'intensity = intensity * slope + intercept;' + 'float center0 = wc - 0.5;' + 'float width0 = max(ww, 1.0);' + 'intensity = (intensity - center0) / width0 + 0.5;' + // Clamp intensity
'intensity = clamp(intensity, 0.0, 1.0);' + // RGBA output
'gl_FragColor = vec4(intensity, intensity, intensity, 1.0);' + // Apply any inversion necessary
'if (invert == 1)' + 'gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;' + '}';


/***/ }),

/***/ "./webgl/shaders/uint8.js":
/*!********************************!*\
  !*** ./webgl/shaders/uint8.js ***!
  \********************************/
/*! exports provided: uint8DataUtilities, uint8Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8DataUtilities", function() { return uint8DataUtilities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8Shader", function() { return uint8Shader; });
var uint8Shader = {};
/**
 * Convert stored pixel data to image data. Here we will store
 * all data in the alpha channel.
 *
 * @param {Image} image A Cornerstone Image Object
 * @returns {Uint8Array} The image data for use by the WebGL shader
 * @memberof WebGLRendering
 */

function storedPixelDataToImageData(image) {
  // Transfer image data to alpha channel of WebGL texture
  return image.getPixelData();
}

var uint8DataUtilities = {
  storedPixelDataToImageData: storedPixelDataToImageData
};
uint8Shader.frag = 'precision mediump float;' + 'uniform sampler2D u_image;' + 'uniform float ww;' + 'uniform float wc;' + 'uniform float slope;' + 'uniform float intercept;' + 'uniform int invert;' + 'varying vec2 v_texCoord;' + 'void main() {' + // Get texture
'vec4 color = texture2D(u_image, v_texCoord);' + // Calculate luminance from packed texture
'float intensity = color.r*256.0;' + // Rescale based on slope and window settings
'intensity = intensity * slope + intercept;' + 'float center0 = wc - 0.5;' + 'float width0 = max(ww, 1.0);' + 'intensity = (intensity - center0) / width0 + 0.5;' + // Clamp intensity
'intensity = clamp(intensity, 0.0, 1.0);' + // RGBA output
'gl_FragColor = vec4(intensity, intensity, intensity, 1.0);' + // Apply any inversion necessary
'if (invert == 1)' + 'gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;' + '}';


/***/ }),

/***/ "./webgl/textureCache.js":
/*!*******************************!*\
  !*** ./webgl/textureCache.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./events.js");
/* harmony import */ var _triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triggerEvent.js */ "./triggerEvent.js");


/**
 * This module deals with caching image textures in VRAM for WebGL
 * @module WebGLTextureCache
 */

var imageCache = {};
var cachedImages = [];
var maximumSizeInBytes = 1024 * 1024 * 256; // 256 MB

var cacheSizeInBytes = 0;

function getCacheInfo() {
  return {
    maximumSizeInBytes: maximumSizeInBytes,
    cacheSizeInBytes: cacheSizeInBytes,
    numberOfImagesCached: cachedImages.length
  };
}

function purgeCacheIfNecessary() {
  // If max cache size has not been exceeded, do nothing
  if (cacheSizeInBytes <= maximumSizeInBytes) {
    return;
  } // Cache size has been exceeded, create list of images sorted by timeStamp
  // So we can purge the least recently used image


  function compare(a, b) {
    if (a.timeStamp > b.timeStamp) {
      return -1;
    }

    if (a.timeStamp < b.timeStamp) {
      return 1;
    }

    return 0;
  }

  cachedImages.sort(compare); // Remove images as necessary

  while (cacheSizeInBytes > maximumSizeInBytes) {
    var lastCachedImage = cachedImages[cachedImages.length - 1];
    cacheSizeInBytes -= lastCachedImage.sizeInBytes;
    delete imageCache[lastCachedImage.imageId];
    cachedImages.pop();
    Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_TEXTURE_REMOVED, {
      imageId: lastCachedImage.imageId
    });
  }

  var cacheInfo = getCacheInfo();
  Object(_triggerEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_events_js__WEBPACK_IMPORTED_MODULE_0__["events"], _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_TEXTURE_CACHE_FULL, cacheInfo);
}

function setMaximumSizeBytes(numBytes) {
  if (numBytes === undefined) {
    throw new Error('setMaximumSizeBytes: parameter numBytes must not be undefined');
  }

  if (numBytes.toFixed === undefined) {
    throw new Error('setMaximumSizeBytes: parameter numBytes must be a number');
  }

  maximumSizeInBytes = numBytes;
  purgeCacheIfNecessary();
}

function putImageTexture(image, imageTexture) {
  var imageId = image.imageId;

  if (image === undefined) {
    throw new Error('putImageTexture: image must not be undefined');
  }

  if (imageId === undefined) {
    throw new Error('putImageTexture: imageId must not be undefined');
  }

  if (imageTexture === undefined) {
    throw new Error('putImageTexture: imageTexture must not be undefined');
  }

  if (Object.prototype.hasOwnProperty.call(imageCache, imageId) === true) {
    throw new Error('putImageTexture: imageId already in cache');
  }

  var cachedImage = {
    imageId: imageId,
    imageTexture: imageTexture,
    timeStamp: new Date(),
    sizeInBytes: imageTexture.sizeInBytes
  };
  imageCache[imageId] = cachedImage;
  cachedImages.push(cachedImage);

  if (imageTexture.sizeInBytes === undefined) {
    throw new Error('putImageTexture: imageTexture.sizeInBytes must not be undefined');
  }

  if (imageTexture.sizeInBytes.toFixed === undefined) {
    throw new Error('putImageTexture: imageTexture.sizeInBytes is not a number');
  }

  cacheSizeInBytes += cachedImage.sizeInBytes;
  purgeCacheIfNecessary();
}

function getImageTexture(imageId) {
  if (imageId === undefined) {
    throw new Error('getImageTexture: imageId must not be undefined');
  }

  var cachedImage = imageCache[imageId];

  if (cachedImage === undefined) {
    return;
  } // Bump time stamp for cached image


  cachedImage.timeStamp = new Date();
  return cachedImage.imageTexture;
}

function removeImageTexture(imageId) {
  if (imageId === undefined) {
    throw new Error('removeImageTexture: imageId must not be undefined');
  }

  var cachedImage = imageCache[imageId];

  if (cachedImage === undefined) {
    throw new Error('removeImageTexture: imageId must not be undefined');
  }

  cachedImages.splice(cachedImages.indexOf(cachedImage), 1);
  cacheSizeInBytes -= cachedImage.sizeInBytes;
  delete imageCache[imageId];
  return cachedImage.imageTexture;
}

function purgeCache() {
  while (cachedImages.length > 0) {
    var removedCachedImage = cachedImages.pop();
    delete imageCache[removedCachedImage.imageId];
  }

  cacheSizeInBytes = 0;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  purgeCache: purgeCache,
  getImageTexture: getImageTexture,
  putImageTexture: putImageTexture,
  removeImageTexture: removeImageTexture,
  setMaximumSizeBytes: setMaximumSizeBytes
});

/***/ }),

/***/ "./webgl/vertexShader.js":
/*!*******************************!*\
  !*** ./webgl/vertexShader.js ***!
  \*******************************/
/*! exports provided: vertexShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return vertexShader; });
var vertexShader = 'attribute vec2 a_position;' + 'attribute vec2 a_texCoord;' + 'uniform vec2 u_resolution;' + 'varying vec2 v_texCoord;' + 'void main() {' + 'vec2 zeroToOne = a_position / u_resolution;' + 'vec2 zeroToTwo = zeroToOne * 2.0;' + 'vec2 clipSpace = zeroToTwo - 1.0;' + 'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' + 'v_texCoord = a_texCoord;' + '}';

/***/ })

/******/ });
});
//# sourceMappingURL=cornerstone.js.map
},{}],3:[function(require,module,exports){
/*! cornerstone-math - 0.1.6 - 2017-06-09 | (c) 2017 Chris Hafey | https://github.com/chafey/cornerstoneTools */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("cornerstoneMath",[],e):"object"==typeof exports?exports.cornerstoneMath=e():t.cornerstoneMath=e()}(this,function(){return function(t){function e(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:i})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=9)}([function(t,e,n){"use strict";function i(t,e,n){return t<e?e:t>n?n:t}function r(t){return t*(Math.PI/180)}function o(t){return t*(180/Math.PI)}function s(t){return"number"==typeof t?t?t<0?-1:1:t===t?0:NaN:NaN}Object.defineProperty(e,"__esModule",{value:!0}),e.clamp=i,e.degToRad=r,e.radToDeg=o,e.sign=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(3),r=function(t){return t&&t.__esModule?t:{default:t}}(i),o=n(0),s=function(t,e,n){this.x=t||0,this.y=e||0,this.z=n||0};s.prototype={constructor:s,set:function(t,e,n){return this.x=t,this.y=e,this.z=n,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setZ:function(t){return this.z=t,this},setComponent:function(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}},getComponent:function(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}},copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this},add:function(t,e){return void 0!==e?(console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)},addScalar:function(t){return this.x+=t,this.y+=t,this.z+=t,this},addVectors:function(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this},sub:function(t,e){return void 0!==e?(console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)},subVectors:function(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this},multiply:function(t,e){return void 0!==e?(console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)},multiplyScalar:function(t){return this.x*=t,this.y*=t,this.z*=t,this},multiplyVectors:function(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this},applyAxisAngle:function(){var t=void 0;return function(e,n){return void 0===t&&(t=new r.default),this.applyQuaternion(t.setFromAxisAngle(e,n)),this}}(),applyMatrix3:function(t){var e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this},applyMatrix4:function(t){var e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i+r[12],this.y=r[1]*e+r[5]*n+r[9]*i+r[13],this.z=r[2]*e+r[6]*n+r[10]*i+r[14],this},applyProjection:function(t){var e=this.x,n=this.y,i=this.z,r=t.elements,o=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*o,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*o,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*o,this},applyQuaternion:function(t){var e=this.x,n=this.y,i=this.z,r=t.x,o=t.y,s=t.z,a=t.w,h=a*e+o*i-s*n,u=a*n+s*e-r*i,c=a*i+r*n-o*e,l=-r*e-o*n-s*i;return this.x=h*a+l*-r+u*-s-c*-o,this.y=u*a+l*-o+c*-r-h*-s,this.z=c*a+l*-s+h*-o-u*-r,this},transformDirection:function(t){var e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize(),this},divide:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this},divideScalar:function(t){if(0!==t){var e=1/t;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return this},min:function(t){return this.x>t.x&&(this.x=t.x),this.y>t.y&&(this.y=t.y),this.z>t.z&&(this.z=t.z),this},max:function(t){return this.x<t.x&&(this.x=t.x),this.y<t.y&&(this.y=t.y),this.z<t.z&&(this.z=t.z),this},clamp:function(t,e){return this.x<t.x?this.x=t.x:this.x>e.x&&(this.x=e.x),this.y<t.y?this.y=t.y:this.y>e.y&&(this.y=e.y),this.z<t.z?this.z=t.z:this.z>e.z&&(this.z=e.z),this},clampScalar:function(){var t=void 0,e=void 0;return function(n,i){return void 0===t&&(t=new s,e=new s),t.set(n,n,n),e.set(i,i,i),this.clamp(t,e)}}(),floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.multiplyScalar(-1)},dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(t){var e=this.length();return 0!==e&&t!==e&&this.multiplyScalar(t/e),this},lerp:function(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this},cross:function(t,e){if(void 0!==e)return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e);var n=this.x,i=this.y,r=this.z;return this.x=i*t.z-r*t.y,this.y=r*t.x-n*t.z,this.z=n*t.y-i*t.x,this},crossVectors:function(t,e){var n=t.x,i=t.y,r=t.z,o=e.x,s=e.y,a=e.z;return this.x=i*a-r*s,this.y=r*o-n*a,this.z=n*s-i*o,this},projectOnVector:function(){var t=void 0,e=void 0;return function(n){return void 0===t&&(t=new s),t.copy(n).normalize(),e=this.dot(t),this.copy(t).multiplyScalar(e)}}(),projectOnPlane:function(){var t=void 0;return function(e){return void 0===t&&(t=new s),t.copy(this).projectOnVector(e),this.sub(t)}}(),reflect:function(){var t=void 0;return function(e){return void 0===t&&(t=new s),this.sub(t.copy(e).multiplyScalar(2*this.dot(e)))}}(),angleTo:function(t){var e=this.dot(t)/(this.length()*t.length());return Math.acos((0,o.clamp)(e,-1,1))},distanceTo:function(t){return Math.sqrt(this.distanceToSquared(t))},distanceToSquared:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i},setFromMatrixPosition:function(t){return this.x=t.elements[12],this.y=t.elements[13],this.z=t.elements[14],this},setFromMatrixScale:function(t){var e=this.set(t.elements[0],t.elements[1],t.elements[2]).length(),n=this.set(t.elements[4],t.elements[5],t.elements[6]).length(),i=this.set(t.elements[8],t.elements[9],t.elements[10]).length();return this.x=e,this.y=n,this.z=i,this},setFromMatrixColumn:function(t,e){var n=4*t,i=e.elements;return this.x=i[n],this.y=i[n+1],this.z=i[n+2],this},equals:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z},fromArray:function(t){return this.x=t[0],this.y=t[1],this.z=t[2],this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new s(this.x,this.y,this.z)}},e.default=s},function(t,e,n){"use strict";function i(t){return t*t}function r(t,e){return i(t.x-e.x)+i(t.y-e.y)}function o(t,e){var n=r(t.start,t.end);if(0===n)return r(e,t.start);var i=((e.x-t.start.x)*(t.end.x-t.start.x)+(e.y-t.start.y)*(t.end.y-t.start.y))/n;return i<0?r(e,t.start):i>1?r(e,t.end):r(e,{x:t.start.x+i*(t.end.x-t.start.x),y:t.start.y+i*(t.end.y-t.start.y)})}function s(t,e){return Math.sqrt(o(t,e))}function a(t,e){var n={},i=t.start.x,r=t.start.y,o=t.end.x,s=t.end.y,a=e.start.x,u=e.start.y,c=e.end.x,l=e.end.y,f=void 0,y=void 0,d=void 0,p=void 0,x=void 0,m=void 0,v=void 0,g=void 0,b=void 0,z=void 0,M=void 0,w=void 0;if(f=s-r,d=i-o,x=o*r-i*s,b=f*a+d*u+x,z=f*c+d*l+x,(0===b||0===z||(0,h.sign)(b)!==(0,h.sign)(z))&&(y=l-u,p=a-c,m=c*u-a*l,v=y*i+p*r+m,g=y*o+p*s+m,0===v||0===g||(0,h.sign)(v)!==(0,h.sign)(g))){M=f*p-y*d,w=d*m-p*x;var P=parseFloat(w/M);w=y*x-f*m;var R=parseFloat(w/M);return n.x=P,n.y=R,n}}Object.defineProperty(e,"__esModule",{value:!0});var h=n(0),u={distanceToPoint:s,intersectLine:a};e.default=u},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=function(t,e,n,i){this.x=t||0,this.y=e||0,this.z=n||0,this.w=void 0!==i?i:1};i.prototype.setFromAxisAngle=function(t,e){var n=e/2,i=Math.sin(n);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(n),this},i.prototype.multiplyQuaternions=function(t,e){var n=t.x,i=t.y,r=t.z,o=t.w,s=e.x,a=e.y,h=e.z,u=e.w;return this.x=n*u+o*s+i*h-r*a,this.y=i*u+o*a+r*s-n*h,this.z=r*u+o*h+n*a-i*s,this.w=o*u-n*s-i*a-r*h,this},i.prototype.setFromRotationMatrix=function(t){var e=t.elements,n=e[0],i=e[4],r=e[8],o=e[1],s=e[5],a=e[9],h=e[2],u=e[6],c=e[10],l=n+s+c,f=void 0;return l>0?(f=.5/Math.sqrt(l+1),this.w=.25/f,this.x=(u-a)*f,this.y=(r-h)*f,this.z=(o-i)*f):n>s&&n>c?(f=2*Math.sqrt(1+n-s-c),this.w=(u-a)/f,this.x=.25*f,this.y=(i+o)/f,this.z=(r+h)/f):s>c?(f=2*Math.sqrt(1+s-n-c),this.w=(r-h)/f,this.x=(i+o)/f,this.y=.25*f,this.z=(a+u)/f):(f=2*Math.sqrt(1+c-n-s),this.w=(o-i)/f,this.x=(r+h)/f,this.y=(a+u)/f,this.z=.25*f),this},e.default=i},function(t,e,n){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),o=n(1),s=function(t){return t&&t.__esModule?t:{default:t}}(o),a=n(0),h=function(){function t(e,n){i(this,t),this.start=void 0!==e?e:new s.default,this.end=void 0!==n?n:new s.default}return r(t,[{key:"set",value:function(t,e){return this.start.copy(t),this.end.copy(e),this}},{key:"copy",value:function(t){return this.start.copy(t.start),this.end.copy(t.end),this}},{key:"center",value:function(t){return(t||new s.default).addVectors(this.start,this.end).multiplyScalar(.5)}},{key:"delta",value:function(t){return(t||new s.default).subVectors(this.end,this.start)}},{key:"distanceSq",value:function(){return this.start.distanceToSquared(this.end)}},{key:"distance",value:function(){return this.start.distanceTo(this.end)}},{key:"at",value:function(t,e){var n=e||new s.default;return this.delta(n).multiplyScalar(t).add(this.start)}},{key:"closestPointToPointParameter",value:function(){var t=new s.default,e=new s.default;return function(n,i){t.subVectors(n,this.start),e.subVectors(this.end,this.start);var r=e.dot(e),o=e.dot(t),s=o/r;return i&&(s=(0,a.clamp)(s,0,1)),s}}},{key:"closestPointToPoint",value:function(t,e,n){var i=this.closestPointToPointParameter(t,e),r=n||new s.default;return this.delta(r).multiplyScalar(i).add(this.start)}},{key:"applyMatrix4",value:function(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}},{key:"equals",value:function(t){return t.start.equals(this.start)&&t.end.equals(this.end)}},{key:"clone",value:function(){return(new t).copy(this)}},{key:"intersectLine",value:function(t){var e=this.end.clone().sub(this.start),n=t.end.clone().sub(t.start),i=t.start.clone().sub(this.start),r=e.clone().cross(n),o=i.clone().cross(n);if(0!==i.dot(e)){var s=o.dot(r)/r.lengthSq();if(!(s>1||isNaN(s))){var a=this.start.clone().add(e.clone().multiplyScalar(s));return a.clone().sub(t.start).lengthSq()+a.clone().sub(t.end).lengthSq()<=t.distanceSq()?a:void 0}}}}]),t}();e.default=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(1),r=function(t){return t&&t.__esModule?t:{default:t}}(i),o=function(t,e,n,i,r,o,s,a,h,u,c,l,f,y,d,p){this.elements=new Float32Array(16);var x=this.elements;x[0]=void 0!==t?t:1,x[4]=e||0,x[8]=n||0,x[12]=i||0,x[1]=r||0,x[5]=void 0!==o?o:1,x[9]=s||0,x[13]=a||0,x[2]=h||0,x[6]=u||0,x[10]=void 0!==c?c:1,x[14]=l||0,x[3]=f||0,x[7]=y||0,x[11]=d||0,x[15]=void 0!==p?p:1};o.prototype.makeRotationFromQuaternion=function(t){var e=this.elements,n=t.x,i=t.y,r=t.z,o=t.w,s=n+n,a=i+i,h=r+r,u=n*s,c=n*a,l=n*h,f=i*a,y=i*h,d=r*h,p=o*s,x=o*a,m=o*h;return e[0]=1-(f+d),e[4]=c-m,e[8]=l+x,e[1]=c+m,e[5]=1-(u+d),e[9]=y-p,e[2]=l-x,e[6]=y+p,e[10]=1-(u+f),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this},o.prototype.multiplyMatrices=function(t,e){var n=t.elements,i=e.elements,r=this.elements,o=n[0],s=n[4],a=n[8],h=n[12],u=n[1],c=n[5],l=n[9],f=n[13],y=n[2],d=n[6],p=n[10],x=n[14],m=n[3],v=n[7],g=n[11],b=n[15],z=i[0],M=i[4],w=i[8],P=i[12],R=i[1],L=i[5],S=i[9],T=i[13],_=i[2],j=i[6],O=i[10],V=i[14],q=i[3],E=i[7],k=i[11],A=i[15];return r[0]=o*z+s*R+a*_+h*q,r[4]=o*M+s*L+a*j+h*E,r[8]=o*w+s*S+a*O+h*k,r[12]=o*P+s*T+a*V+h*A,r[1]=u*z+c*R+l*_+f*q,r[5]=u*M+c*L+l*j+f*E,r[9]=u*w+c*S+l*O+f*k,r[13]=u*P+c*T+l*V+f*A,r[2]=y*z+d*R+p*_+x*q,r[6]=y*M+d*L+p*j+x*E,r[10]=y*w+d*S+p*O+x*k,r[14]=y*P+d*T+p*V+x*A,r[3]=m*z+v*R+g*_+b*q,r[7]=m*M+v*L+g*j+b*E,r[11]=m*w+v*S+g*O+b*k,r[15]=m*P+v*T+g*V+b*A,this},o.prototype.multiply=function(t,e){return void 0!==e?(console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)},o.prototype.getInverse=function(t,e){var n=this.elements,i=t.elements,r=i[0],o=i[4],s=i[8],a=i[12],h=i[1],u=i[5],c=i[9],l=i[13],f=i[2],y=i[6],d=i[10],p=i[14],x=i[3],m=i[7],v=i[11],g=i[15];n[0]=c*p*m-l*d*m+l*y*v-u*p*v-c*y*g+u*d*g,n[4]=a*d*m-s*p*m-a*y*v+o*p*v+s*y*g-o*d*g,n[8]=s*l*m-a*c*m+a*u*v-o*l*v-s*u*g+o*c*g,n[12]=a*c*y-s*l*y-a*u*d+o*l*d+s*u*p-o*c*p,n[1]=l*d*x-c*p*x-l*f*v+h*p*v+c*f*g-h*d*g,n[5]=s*p*x-a*d*x+a*f*v-r*p*v-s*f*g+r*d*g,n[9]=a*c*x-s*l*x-a*h*v+r*l*v+s*h*g-r*c*g,n[13]=s*l*f-a*c*f+a*h*d-r*l*d-s*h*p+r*c*p,n[2]=u*p*x-l*y*x+l*f*m-h*p*m-u*f*g+h*y*g,n[6]=a*y*x-o*p*x-a*f*m+r*p*m+o*f*g-r*y*g,n[10]=o*l*x-a*u*x+a*h*m-r*l*m-o*h*g+r*u*g,n[14]=a*u*f-o*l*f-a*h*y+r*l*y+o*h*p-r*u*p,n[3]=c*y*x-u*d*x-c*f*m+h*d*m+u*f*v-h*y*v,n[7]=o*d*x-s*y*x+s*f*m-r*d*m-o*f*v+r*y*v,n[11]=s*u*x-o*c*x-s*h*m+r*c*m+o*h*v-r*u*v,n[15]=o*c*f-s*u*f+s*h*y-r*c*y-o*h*d+r*u*d;var b=r*n[0]+h*n[4]+f*n[8]+x*n[12];if(0===b){var z="Matrix4.getInverse(): can't invert matrix, determinant is 0";if(e)throw new Error(z);return console.warn(z),this.identity(),this}return this.multiplyScalar(1/b),this},o.prototype.applyToVector3Array=function(){var t=new r.default;return function(e,n,i){void 0===n&&(n=0),void 0===i&&(i=e.length);for(var r=0,o=n;r<i;r+=3,o+=3)t.x=e[o],t.y=e[o+1],t.z=e[o+2],t.applyMatrix4(this),e[o]=t.x,e[o+1]=t.y,e[o+2]=t.z;return e}},o.prototype.makeTranslation=function(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this},o.prototype.multiplyScalar=function(t){var e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this},o.prototype.set=function(t,e,n,i,r,o,s,a,h,u,c,l,f,y,d,p){var x=this.elements;return x[0]=t,x[4]=e,x[8]=n,x[12]=i,x[1]=r,x[5]=o,x[9]=s,x[13]=a,x[2]=h,x[6]=u,x[10]=c,x[14]=l,x[3]=f,x[7]=y,x[11]=d,x[15]=p,this},o.prototype.makeScale=function(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this},e.default=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(1),r=function(t){return t&&t.__esModule?t:{default:t}}(i),o=function(t,e){this.normal=void 0!==t?t:new r.default(1,0,0),this.constant=void 0!==e?e:0};o.prototype={constructor:o,set:function(t,e){return this.normal.copy(t),this.constant=e,this},setComponents:function(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this},setFromNormalAndCoplanarPoint:function(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this},setFromCoplanarPoints:function(){var t=new r.default,e=new r.default;return function(n,i,r){var o=t.subVectors(r,i).cross(e.subVectors(n,i)).normalize();return this.setFromNormalAndCoplanarPoint(o,n),this}}(),copy:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this},normalize:function(){var t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(t){return this.normal.dot(t)+this.constant},distanceToSphere:function(t){return this.distanceToPoint(t.center)-t.radius},projectPoint:function(t,e){return this.orthoPoint(t,e).sub(t).negate()},orthoPoint:function(t,e){var n=this.distanceToPoint(t);return(e||new r.default).copy(this.normal).multiplyScalar(n)},isIntersectionLine:function(t){var e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0},intersectLine:function(){var t=new r.default;return function(e,n){var i=n||new r.default,o=e.delta(t),s=this.normal.dot(o);if(0!==s){var a=-(e.start.dot(this.normal)+this.constant)/s;if(!(a<0||a>1))return i.copy(o).multiplyScalar(a).add(e.start)}else if(0===this.distanceToPoint(e.start))return i.copy(e.start)}}(),intersectPlane:function(t){var e=this.normal.clone().cross(t.normal),n=new r.default,i={origin:n,direction:e};if(this.normal.clone().cross(t.normal).length<1e-10)return i.direction=new r.default,i;var o=this.constant,s=t.constant,a=this.normal.clone().dot(t.normal),h=-(o-s*a)/(1-a*a),u=-(s-o*a)/(1-a*a);return i.origin=this.normal.clone().multiplyScalar(h).add(t.normal.clone().multiplyScalar(u)),i},coplanarPoint:function(t){return(t||new r.default).copy(this.normal).multiplyScalar(-this.constant)},translate:function(t){return this.constant=this.constant-t.dot(this.normal),this},equals:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant},clone:function(){return(new o).copy(this)}},e.default=o},function(t,e,n){"use strict";function i(t){return{x:t.pageX,y:t.pageY}}function r(t,e){return{x:t.x-e.x,y:t.y-e.y}}function o(t){return{x:t.x,y:t.y}}function s(t,e){return Math.sqrt(a(t,e))}function a(t,e){var n=r(t,e);return n.x*n.x+n.y*n.y}function h(t,e){return!(t.x<e.left||t.x>e.left+e.width||t.y<e.top||t.y>e.top+e.height)}function u(t,e){var n=[],i=void 0;return t.forEach(function(t,r){var o=s(t,e);n.push(o),i=0===r?o:Math.min(o,i)}),t[n.indexOf(i)]}Object.defineProperty(e,"__esModule",{value:!0});var c={subtract:r,copy:o,pageToPoint:i,distance:s,distanceSquared:a,insideRect:h,findClosestPoint:u};e.default=c},function(t,e,n){"use strict";function i(t){return[{start:{x:t.left,y:t.top},end:{x:t.left+t.width,y:t.top}},{start:{x:t.left+t.width,y:t.top},end:{x:t.left+t.width,y:t.top+t.height}},{start:{x:t.left+t.width,y:t.top+t.height},end:{x:t.left,y:t.top+t.height}},{start:{x:t.left,y:t.top+t.height},end:{x:t.left,y:t.top}}]}function r(t,e){var n=655535;return i(t).forEach(function(t){var i=u.default.distanceToPoint(t,e);i<n&&(n=i)}),n}function o(t){return{topLeft:{x:t.left,y:t.top},bottomRight:{x:t.left+t.width,y:t.top+t.height}}}function s(t,e){var n=void 0,i=void 0,r=o(t),s=o(e);return n=t.width>=0?e.width>=0?!(r.bottomRight.x<=s.topLeft.x||s.bottomRight.x<=r.topLeft.x):!(r.bottomRight.x<=s.bottomRight.x||s.topLeft.x<=r.topLeft.x):e.width>=0?!(r.topLeft.x<=s.topLeft.x||s.bottomRight.x<=r.bottomRight.x):!(r.topLeft.x<=s.bottomRight.x||s.topLeft.x<=r.bottomRight.x),i=t.height>=0?e.height>=0?!(r.bottomRight.y<=s.topLeft.y||s.bottomRight.y<=r.topLeft.y):!(r.bottomRight.y<=s.bottomRight.y||s.topLeft.y<=r.topLeft.y):e.height>=0?!(r.topLeft.y<=s.topLeft.y||s.bottomRight.y<=r.bottomRight.y):!(r.topLeft.y<=s.bottomRight.y||s.top<=r.bottomRight.y),n&&i}function a(t,e){var n={topLeft:{},bottomRight:{}};if(s(t,e)){var i=o(t),r=o(e);return t.width>=0?e.width>=0?(n.topLeft.x=Math.max(i.topLeft.x,r.topLeft.x),n.bottomRight.x=Math.min(i.bottomRight.x,r.bottomRight.x)):(n.topLeft.x=Math.max(i.topLeft.x,r.bottomRight.x),n.bottomRight.x=Math.min(i.bottomRight.x,r.topLeft.x)):e.width>=0?(n.topLeft.x=Math.min(i.topLeft.x,r.bottomRight.x),n.bottomRight.x=Math.max(i.bottomRight.x,r.topLeft.x)):(n.topLeft.x=Math.min(i.topLeft.x,r.topLeft.x),n.bottomRight.x=Math.max(i.bottomRight.x,r.bottomRight.x)),t.height>=0?e.height>=0?(n.topLeft.y=Math.max(i.topLeft.y,r.topLeft.y),n.bottomRight.y=Math.min(i.bottomRight.y,r.bottomRight.y)):(n.topLeft.y=Math.max(i.topLeft.y,r.bottomRight.y),n.bottomRight.y=Math.min(i.bottomRight.y,r.topLeft.y)):e.height>=0?(n.topLeft.y=Math.min(i.topLeft.y,r.bottomRight.y),n.bottomRight.y=Math.max(i.bottomRight.y,r.topLeft.y)):(n.topLeft.y=Math.min(i.topLeft.y,r.topLeft.y),n.bottomRight.y=Math.max(i.bottomRight.y,r.bottomRight.y)),n}}Object.defineProperty(e,"__esModule",{value:!0});var h=n(2),u=function(t){return t&&t.__esModule?t:{default:t}}(h),c={distanceToPoint:r,getIntersectionRect:a};e.default=c},function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var r=n(4);Object.defineProperty(e,"Line3",{enumerable:!0,get:function(){return i(r).default}});var o=n(2);Object.defineProperty(e,"lineSegment",{enumerable:!0,get:function(){return i(o).default}});var s=n(0);Object.defineProperty(e,"clamp",{enumerable:!0,get:function(){return s.clamp}}),Object.defineProperty(e,"degToRad",{enumerable:!0,get:function(){return s.degToRad}}),Object.defineProperty(e,"radToDeg",{enumerable:!0,get:function(){return s.radToDeg}}),Object.defineProperty(e,"sign",{enumerable:!0,get:function(){return s.sign}});var a=n(5);Object.defineProperty(e,"Matrix4",{enumerable:!0,get:function(){return i(a).default}});var h=n(6);Object.defineProperty(e,"Plane",{enumerable:!0,get:function(){return i(h).default}});var u=n(7);Object.defineProperty(e,"point",{enumerable:!0,get:function(){return i(u).default}});var c=n(3);Object.defineProperty(e,"quaternion",{enumerable:!0,get:function(){return i(c).default}});var l=n(8);Object.defineProperty(e,"rect",{enumerable:!0,get:function(){return i(l).default}});var f=n(1);Object.defineProperty(e,"Vector3",{enumerable:!0,get:function(){return i(f).default}})}])});
//# sourceMappingURL=cornerstoneMath.min.js.map
},{}],4:[function(require,module,exports){
/*! cornerstone-tools - 2.3.9 - 2018-07-24 | (c) 2017 Chris Hafey | https://github.com/cornerstonejs/cornerstoneTools */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("cornerstoneTools",[],t):"object"==typeof exports?exports.cornerstoneTools=t():e.cornerstoneTools=t()}(window,function(){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var o=t[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=46)}([function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=window.cornerstone,o=window.cornerstoneMath,r=window.Hammer;t.default={set cornerstone(e){a=e},get cornerstone(){return a},set cornerstoneMath(e){o=e},get cornerstoneMath(){return o},set Hammer(e){r=e},get Hammer(){return r}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default={IMAGE_RENDERED:"cornerstoneimagerendered",NEW_IMAGE:"cornerstonenewimage",IMAGE_CACHE_PROMISE_REMOVED:"cornerstoneimagecachepromiseremoved",ELEMENT_DISABLED:"cornerstoneelementdisabled",MOUSE_DOWN:"cornerstonetoolsmousedown",MOUSE_UP:"cornerstonetoolsmouseup",MOUSE_DOWN_ACTIVATE:"cornerstonetoolsmousedownactivate",MOUSE_DRAG:"cornerstonetoolsmousedrag",MOUSE_MOVE:"cornerstonetoolsmousemove",MOUSE_CLICK:"cornerstonetoolsmouseclick",MOUSE_DOUBLE_CLICK:"cornerstonetoolsmousedoubleclick",MOUSE_WHEEL:"cornerstonetoolsmousewheel",TOUCH_START:"cornerstonetoolstouchstart",TOUCH_START_ACTIVE:"cornerstonetoolstouchstartactive",TOUCH_END:"cornerstonetoolstouchend",TOUCH_DRAG:"cornerstonetoolstouchdrag",TOUCH_DRAG_END:"cornerstonetoolstouchdragend",TOUCH_PINCH:"cornerstonetoolstouchpinch",TOUCH_ROTATE:"cornerstonetoolstouchrotate",TOUCH_PRESS:"cornerstonetoolstouchpress",TAP:"cornerstonetoolstap",DOUBLE_TAP:"cornerstonetoolsdoubletap",MULTI_TOUCH_START:"cornerstonetoolsmultitouchstart",MULTI_TOUCH_START_ACTIVE:"cornerstonetoolsmultitouchstartactive",MULTI_TOUCH_DRAG:"cornerstonetoolsmultitouchdrag",KEY_DOWN:"cornerstonetoolskeydown",KEY_UP:"cornerstonetoolskeyup",KEY_PRESS:"cornerstonetoolskeypress",MEASUREMENT_ADDED:"cornerstonetoolsmeasurementadded",MEASUREMENT_MODIFIED:"cornerstonetoolsmeasurementmodified",MEASUREMENT_REMOVED:"cornerstonemeasurementremoved",TOOL_DEACTIVATED:"cornerstonetoolstooldeactivated",CLIP_STOPPED:"cornerstonetoolsclipstopped",STACK_SCROLL:"cornerstonestackscroll",LINE_SAMPLE_UPDATED:"cornerstonelinesampleupdated"}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getElementToolStateManager=t.setElementToolStateManager=t.clearToolState=t.removeToolState=t.getToolState=t.addToolState=void 0;var a=l(n(1)),o=l(n(0)),r=n(26),i=l(n(6));function l(e){return e&&e.__esModule?e:{default:e}}function d(e){var t=o.default.cornerstone.getEnabledElement(e);return void 0===t.toolStateManager&&(t.toolStateManager=r.globalImageIdSpecificToolStateManager),t.toolStateManager}t.addToolState=function(e,t,n){d(e).add(e,t,n);var o=a.default.MEASUREMENT_ADDED,r={toolType:t,element:e,measurementData:n};(0,i.default)(e,o,r)},t.getToolState=function(e,t){return d(e).get(e,t)},t.removeToolState=function(e,t,n){for(var o=d(e).get(e,t),r=-1,l=0;l<o.data.length;l++)o.data[l]===n&&(r=l);if(-1!==r){o.data.splice(r,1);var u=a.default.MEASUREMENT_REMOVED,s={toolType:t,element:e,measurementData:n};(0,i.default)(e,u,s)}},t.clearToolState=function(e,t){var n=d(e).get(e,t);void 0!==n&&(n.data=[])},t.setElementToolStateManager=function(e,t){o.default.cornerstone.getEnabledElement(e).toolStateManager=t},t.getElementToolStateManager=d},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getNewContext=function(e){var t=e.getContext("2d");return t.setTransform(1,0,0,1,0,0),t},t.draw=function(e,t){e.save(),t(e),e.restore()},t.path=l,t.setShadow=function(e,t){t.shadow&&(e.shadowColor=t.shadowColor||"#000000",e.shadowOffsetX=t.shadowOffsetX||1,e.shadowOffsetY=t.shadowOffsetY||1)},t.drawLine=function(e,t,n,a,o){var i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel";l(e,o,function(e){if("pixel"===i){var o=r.default.cornerstone;n=o.pixelToCanvas(t,n),a=o.pixelToCanvas(t,a)}e.moveTo(n.x,n.y),e.lineTo(a.x,a.y)})},t.drawLines=function(e,t,n,a){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"pixel";l(e,a,function(e){n.forEach(function(n){var a=n.start,i=n.end;if("pixel"===o){var l=r.default.cornerstone;a=l.pixelToCanvas(t,a),i=l.pixelToCanvas(t,i)}e.moveTo(a.x,a.y),e.lineTo(i.x,i.y)})})},t.drawJoinedLines=function(e,t,n,a,o){var i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel";l(e,o,function(e){if("pixel"===i){var o=r.default.cornerstone;n=o.pixelToCanvas(t,n),a=a.map(function(e){return o.pixelToCanvas(t,e)})}e.moveTo(n.x,n.y),a.forEach(function(t){var n=t.x,a=t.y;e.lineTo(n,a)})})},t.drawCircle=function(e,t,n,a,o){"pixel"===(arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel")&&(n=r.default.cornerstone.pixelToCanvas(t,n));l(e,o,function(e){e.arc(n.x,n.y,a,0,2*Math.PI)})},t.drawEllipse=function(e,t,n,a,o){"pixel"===(arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel")&&(n=r.default.cornerstone.pixelToCanvas(t,n),a=r.default.cornerstone.pixelToCanvas(t,a));var i=Math.min(n.x,a.x),d=Math.min(n.y,a.y),u=Math.abs(n.x-a.x),s=Math.abs(n.y-a.y),c=u/2*.5522848,f=s/2*.5522848,v=i+u,g=d+s,m=i+u/2,h=d+s/2;l(e,o,function(e){e.moveTo(i,h),e.bezierCurveTo(i,h-f,m-c,d,m,d),e.bezierCurveTo(m+c,d,v,h-f,v,h),e.bezierCurveTo(v,h+f,m+c,g,m,g),e.bezierCurveTo(m-c,g,i,h+f,i,h),e.closePath()})},t.drawRect=function(e,t,n,a,o){if("pixel"===(arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel")){var i=r.default.cornerstone;n=i.pixelToCanvas(t,n),a=i.pixelToCanvas(t,a)}var d=Math.min(n.x,a.x),u=Math.min(n.y,a.y),s=Math.abs(n.x-a.x),c=Math.abs(n.y-a.y);l(e,o,function(e){e.rect(d,u,s,c)})},t.fillOutsideRect=function(e,t,n,a,o){if("pixel"===(arguments.length>5&&void 0!==arguments[5]?arguments[5]:"pixel")){var i=r.default.cornerstone;n=i.pixelToCanvas(t,n),a=i.pixelToCanvas(t,a)}var d=Math.min(n.x,a.x),u=Math.min(n.y,a.y),s=Math.abs(n.x-a.x),c=Math.abs(n.y-a.y);l(e,o,function(e){e.rect(0,0,e.canvas.clientWidth,e.canvas.clientHeight),e.rect(d+s,u,-s,c)})},t.fillBox=function(e,t,n){e.fillStyle=n,e.fillRect(t.left,t.top,t.width,t.height)},t.fillTextLines=function(e,t,n,a,o){var r=i.textStyle.getFontSize();e.font=i.textStyle.getFont(),e.textBaseline="top",e.fillStyle=a,n.forEach(function(n,a){e.fillText(n,t.left+o,t.top+o+a*(r+o))})};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(46);function l(e,t,n){var a=t.color,o=t.lineWidth,r=t.fillStyle,l=t.lineDash;e.beginPath(),e.strokeStyle=a||e.strokeStyle,e.lineWidth=o||void 0===o&&i.toolStyle.getToolWidth()||e.lineWidth,l&&e.setLineDash(l),n(e),r&&(e.fillStyle=r,e.fill()),e.stroke(),l&&e.setLineDash([])}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a={};t.getToolOptions=function(e,t){if(!a[e])return{};var n=a[e].find(function(e){return e.element===t});return n?n.options:{}},t.setToolOptions=function(e,t,n){if(a[e]){var o=a[e].findIndex(function(e){return e.element===t});if(-1===o)a[e].push({element:t,options:n});else{var r=a[e][o].options||{};a[e][o].options=Object.assign(r,n)}}else a[e]=[{element:t,options:n}]},t.clearToolOptions=function(e,t){var n=a[e];n&&(a[e]=n.filter(function(e){return e.element!==t}))},t.clearToolOptionsByToolType=function(e){delete a[e]},t.clearToolOptionsByElement=function(e){for(var t in a)a[t]=a[t].filter(function(t){return t.element!==e})}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return 0!=(t&1<<e-1)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=void 0;"function"==typeof window.CustomEvent?a=new CustomEvent(t,{detail:n,cancelable:!0}):(a=document.createEvent("CustomEvent")).initCustomEvent(t,!0,!0,n);return e.dispatchEvent(a)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a="white",o="greenyellow",r="transparent";var i={setFillColor:function(e){r=e},getFillColor:function(){return r},setToolColor:function(e){a=e},getToolColor:function(){return a},setActiveColor:function(e){o=e},getActiveColor:function(){return o},getColorIfActive:function(e){return e.color?e.color:e.active?o:a}};t.default=i},function(e,t,n){"use strict";function a(e,t,n){return Math.min(Math.max(t,e),n)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=a,t.clipToBox=function(e,t){e.x=a(e.x,0,t.width),e.y=a(e.y,0,t.height)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a,o){Object.keys(n).forEach(function(d){var u=n[d];if(!0!==u.drawnIndependently&&(!o||!0!==o.drawHandlesIfActive||u.active)){var s=function(e){var t=void 0;t=e&&e.handleRadius?e.handleRadius:l;return t}(o),c={color:a,lineWidth:u.active?r.default.getActiveWidth():r.default.getToolWidth(),fillStyle:o&&o.fill};(0,i.drawCircle)(e,t.element,u,s,c)}})};var a,o=n(15),r=(a=o)&&a.__esModule?a:{default:a},i=n(3);var l=6},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t={},n=e.toolType;function h(t){var r=t.detail,i=r.element,l=(0,m.getToolOptions)(n,i);(0,f.default)(r.which,l.mouseButtonMask)&&(e.addNewMeasurement?e.addNewMeasurement(r):function(t){var r=o.default.cornerstone,i=t.element,l=e.createNewMeasurement(t);if(!l)return;(0,v.addToolState)(t.element,n,l),i.removeEventListener(a.default.MOUSE_MOVE,T),i.removeEventListener(a.default.MOUSE_DOWN,y),i.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),_&&i.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,_);r.updateImage(i);var s=void 0;s=1===Object.keys(l.handles).length?d.default:u.default;var f=void 0;f=!(!e.options||void 0===e.options.preventHandleOutsideImage)&&e.options.preventHandleOutsideImage;s(t,n,l,l.handles.end,function(){l.active=!1,l.invalidated=!0,(0,c.default)(t,l.handles)&&(0,v.removeToolState)(i,n,l),i.addEventListener(a.default.MOUSE_MOVE,T),i.addEventListener(a.default.MOUSE_DOWN,y),i.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),_&&i.addEventListener(a.default.MOUSE_DOUBLE_CLICK,_),r.updateImage(i)},f)}(r),t.preventDefault(),t.stopPropagation())}function p(t){var a=t.detail;r.default.setCoords(a);var i=(0,v.getToolState)(a.element,n);if(i){for(var d=!1,u=0;u<i.data.length;u++){var s=a.currentPoints.canvas,c=i.data[u];!0===(0,l.default)(a.element,c.handles,s)&&(d=!0),(e.pointNearTool(a.element,c,s)&&!c.active||!e.pointNearTool(a.element,c,s)&&c.active)&&(c.active=!c.active,d=!0)}!0===d&&o.default.cornerstone.updateImage(a.element)}}function E(t){var r=t.detail,l=void 0,u=r.element,g=(0,m.getToolOptions)(n,u);if((0,f.default)(r.which,g.mouseButtonMask)){var h=r.startPoints.canvas,p=(0,v.getToolState)(t.currentTarget,n);if(p){var E=void 0,y=void 0;for(y=!(!e.options||void 0===e.options.preventHandleOutsideImage)&&e.options.preventHandleOutsideImage,E=0;E<p.data.length;E++){l=p.data[E];var M=(0,i.default)(u,l.handles,h,6);if(M)return u.removeEventListener(a.default.MOUSE_MOVE,T),l.active=!0,(0,d.default)(r,n,l,M,x,y),t.stopImmediatePropagation(),t.stopPropagation(),void t.preventDefault()}if(e.pointNearTool){var _=e.options||{deleteIfHandleOutsideImage:!0,preventHandleOutsideImage:!1};for(E=0;E<p.data.length;E++)if((l=p.data[E]).active=!1,e.pointNearTool(u,l,h))return l.active=!0,u.removeEventListener(a.default.MOUSE_MOVE,T),(0,s.default)(t,l,p,n,_,x),t.stopImmediatePropagation(),t.stopPropagation(),void t.preventDefault()}}}function x(){l.invalidated=!0,(0,c.default)(r,l.handles)&&(0,v.removeToolState)(u,n,l),o.default.cornerstone.updateImage(u),u.addEventListener(a.default.MOUSE_MOVE,T)}}var T=e.mouseMoveCallback||p,y=e.mouseDownCallback||E,M=e.mouseDownActivateCallback||h,_=e.mouseDoubleClickCallback;var x={enable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,T),t.removeEventListener(a.default.MOUSE_DOWN,y),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),_&&t.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,_),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),o.default.cornerstone.updateImage(t)},disable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,T),t.removeEventListener(a.default.MOUSE_DOWN,y),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),_&&t.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,_),o.default.cornerstone.updateImage(t)},activate:function(t,r){(0,m.setToolOptions)(n,t,{mouseButtonMask:r}),t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,T),t.removeEventListener(a.default.MOUSE_DOWN,y),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.addEventListener(a.default.MOUSE_MOVE,T),t.addEventListener(a.default.MOUSE_DOWN,y),t.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),_&&(t.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,_),t.addEventListener(a.default.MOUSE_DOUBLE_CLICK,_)),o.default.cornerstone.updateImage(t)},deactivate:function(t,r){(0,m.setToolOptions)(n,t,{mouseButtonMask:r});var i=a.default.TOOL_DEACTIVATED,l={mouseButtonMask:r,toolType:n,type:i};(0,g.default)(t,i,l),t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,T),t.removeEventListener(a.default.MOUSE_DOWN,y),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,M),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.addEventListener(a.default.MOUSE_MOVE,T),t.addEventListener(a.default.MOUSE_DOWN,y),_&&(t.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,_),t.addEventListener(a.default.MOUSE_DOUBLE_CLICK,_)),e.deactivate&&e.deactivate(t,r),o.default.cornerstone.updateImage(t)},getConfiguration:function(){return t},setConfiguration:function(e){t=e},mouseDownCallback:E,mouseMoveCallback:p,mouseDownActivateCallback:h};return e.pointNearTool&&(x.pointNearTool=e.pointNearTool),_&&(x.mouseDoubleClickCallback=_),e.addNewMeasurement&&(x.addNewMeasurement=e.addNewMeasurement),x};var a=h(n(1)),o=h(n(0)),r=h(n(38)),i=h(n(25)),l=h(n(32)),d=h(n(31)),u=h(n(30)),s=h(n(37)),c=h(n(16)),f=h(n(5)),v=n(2),g=h(n(6)),m=n(4);function h(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.textBoxWidth=l,t.default=function(e,t,n,a,o,d){"[object Array]"!==Object.prototype.toString.call(t)&&(t=[t]);var u=r.default.getFontSize(),s=r.default.getBackgroundColor(),c=0;t.forEach(function(t){var n=l(e,t,5);c=Math.max(c,n)});var f={width:c,height:5+t.length*(u+5)};return(0,i.draw)(e,function(e){e.strokeStyle=o,d&&d.centering&&!0===d.centering.x&&(n-=f.width/2),d&&d.centering&&!0===d.centering.y&&(a-=f.height/2),f.left=n,f.top=a;var r=d&&!0===d.debug?"#FF0000":s;(0,i.fillBox)(e,f,r),(0,i.fillTextLines)(e,f,t,o,5)}),f};var a,o=n(21),r=(a=o)&&a.__esModule?a:{default:a},i=n(3);function l(e,t,n){var a=r.default.getFont(),o=e.font;a&&a!==o&&(e.font=a);var i=e.measureText(t).width;return a&&a!==o&&(e.font=o),i+2*n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=f(n(1)),o=f(n(0)),r=f(n(16)),i=f(n(25)),l=f(n(59)),d=f(n(28)),u=f(n(60)),s=n(2),c=f(n(6));function f(e){return e&&e.__esModule?e:{default:e}}function v(e){Object.keys(e).forEach(function(t){e[t].active=!1})}function g(e){if(e)for(var t=0;t<e.data.length;t++){var n=e.data[t];n.active=!1,n.handles&&v(n.handles)}}t.default=function(e){function t(i){var l=i.detail;e.addNewMeasurement?e.addNewMeasurement(l):function(i){var l=o.default.cornerstone,u=i.element,c=e.createNewMeasurement(i);if(c){if((0,s.addToolState)(u,e.toolType,c),1===Object.keys(c.handles).length&&i.type===a.default.TAP)return c.active=!1,c.handles.end.active=!1,c.handles.end.highlight=!1,c.invalidated=!0,(0,r.default)(i,c.handles)&&(0,s.removeToolState)(u,e.toolType,c),void l.updateImage(u);u.removeEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),u.removeEventListener(a.default.TAP,e.tapCallback||n),u.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),l.updateImage(u),(0,d.default)(i,e.toolType,c,c.handles.end,function(){c.active=!1,c.invalidated=!0,(0,r.default)(i,c.handles)&&(0,s.removeToolState)(u,e.toolType,c),u.addEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),u.addEventListener(a.default.TAP,e.tapCallback||n),u.addEventListener(a.default.TOUCH_START,e.touchStartCallback||f),l.updateImage(u)})}}(l),i.stopImmediatePropagation(),i.preventDefault()}function n(d){var c=d.detail,v=o.default.cornerstone,m=c.element,h=c.currentPoints.canvas,p=(0,s.getToolState)(d.currentTarget,e.toolType),E=void 0,T=void 0;function y(){g(p),(0,r.default)(c,E.handles)&&(0,s.removeToolState)(m,e.toolType,E),v.updateImage(m),m.addEventListener(a.default.TOUCH_START,e.touchStartCallback||f),m.addEventListener(a.default.TAP,e.tapCallback||n)}if(g(p),p)for(T=0;T<p.data.length;T++){E=p.data[T];var M=(0,i.default)(m,E.handles,h,25);if(M)return m.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),m.removeEventListener(a.default.TAP,e.tapCallback||n),E.active=!0,M.active=!0,v.updateImage(m),(0,l.default)(d,e.toolType,E,M,y),d.stopImmediatePropagation(),void d.preventDefault()}if(p&&e.pointNearTool)for(T=0;T<p.data.length;T++)if(E=p.data[T],e.pointNearTool(m,E,h))return m.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),m.removeEventListener(a.default.TAP,e.tapCallback||n),E.active=!0,v.updateImage(m),(0,u.default)(d,E,p,e.toolType,!0,y),d.stopImmediatePropagation(),void d.preventDefault();return e.touchDownActivateCallback?e.touchDownActivateCallback(d):t(d),!1}function f(t){var d=t.detail,v=o.default.cornerstone,g=d.element,m=d.startPoints.canvas,h=void 0,p=(0,s.getToolState)(t.currentTarget,e.toolType),E=void 0;function T(t,o){h.active=!1,h.invalidated=!0,(0,r.default)(d,h.handles)&&(0,s.removeToolState)(d.element,e.toolType,h),v.updateImage(d.element),g.addEventListener(a.default.TOUCH_START,e.touchStartCallback||f),g.addEventListener(a.default.TAP,e.tapCallback||n),e.pressCallback&&g.addEventListener(a.default.TOUCH_PRESS,e.pressCallback),t&&t.type===a.default.TOUCH_PRESS&&(0,c.default)(g,t.type,o)}if(p){for(E=0;E<p.data.length;E++){h=p.data[E];var y=(0,i.default)(d.element,h.handles,m,28);if(y)return g.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),g.removeEventListener(a.default.TAP,e.tapCallback||n),e.pressCallback&&g.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),h.active=!0,(0,l.default)(t,e.toolType,h,y,T),t.stopImmediatePropagation(),t.preventDefault(),void t.stopPropagation()}if(e.pointNearTool)for(E=0;E<p.data.length;E++)if(h=p.data[E],e.pointNearTool(d.element,h,m))return g.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),g.removeEventListener(a.default.TAP,e.tapCallback||n),e.pressCallback&&g.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),(0,u.default)(t,h,p,e.toolType,!0,T),t.stopImmediatePropagation(),t.preventDefault(),void t.stopPropagation()}}var v={enable:function(r){r.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),r.removeEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),r.removeEventListener(a.default.TAP,e.tapCallback||n),r.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),e.doubleTapCallback&&r.removeEventListener(a.default.DOUBLE_TAP,e.doubleTapCallback),e.pressCallback&&r.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),o.default.cornerstone.updateImage(r)},disable:function(r){r.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),r.removeEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),r.removeEventListener(a.default.TAP,e.tapCallback||n),e.doubleTapCallback&&r.removeEventListener(a.default.DOUBLE_TAP,e.doubleTapCallback),e.pressCallback&&r.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),o.default.cornerstone.updateImage(r)},activate:function(r){r.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),r.removeEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),r.removeEventListener(a.default.TAP,e.tapCallback||n),r.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.addEventListener(a.default.TOUCH_START,e.touchStartCallback||f),r.addEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),r.addEventListener(a.default.TAP,e.tapCallback||n),e.doubleTapCallback&&(r.removeEventListener(a.default.DOUBLE_TAP,e.doubleTapCallback),r.addEventListener(a.default.DOUBLE_TAP,e.doubleTapCallback)),e.pressCallback&&(r.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),r.addEventListener(a.default.TOUCH_PRESS,e.pressCallback)),o.default.cornerstone.updateImage(r)},deactivate:function(r){var i=a.default.TOOL_DEACTIVATED,l={toolType:e.toolType,type:i};(0,c.default)(r,i,l),r.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.removeEventListener(a.default.TOUCH_START,e.touchStartCallback||f),r.removeEventListener(a.default.TOUCH_START_ACTIVE,e.touchDownActivateCallback||t),r.removeEventListener(a.default.TAP,e.tapCallback||n),r.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),r.addEventListener(a.default.TOUCH_START,e.touchStartCallback||f),e.doubleTapCallback&&r.removeEventListener(a.default.DOUBLE_TAP,e.doubleTapCallback),e.pressCallback&&r.removeEventListener(a.default.TOUCH_PRESS,e.pressCallback),o.default.cornerstone.updateImage(r)},touchStartCallback:e.touchStartCallback||f,touchDownActivateCallback:e.touchDownActivateCallback||t,tapCallback:e.tapCallback||n};return e.pointNearTool&&(v.pointNearTool=e.pointNearTool),e.doubleTapCallback&&(v.doubleTapCallback=e.doubleTapCallback),e.pressCallback&&(v.pressCallback=e.pressCallback),e.addNewMeasurement&&(v.addNewMeasurement=e.addNewMeasurement),v}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=void 0,o=void 0,r=void 0;var i={setStartLoadHandler:function(e){a=e},getStartLoadHandler:function(){return a},setEndLoadHandler:function(e){o=e},getEndLoadHandler:function(){return o},setErrorLoadingHandler:function(e){r=e},getErrorLoadingHandler:function(){return r}};t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(!t)throw new Error("simpleMouseButtonTool: toolType is required");var n={};return{activate:function(n,a){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};o.mouseButtonMask=a,(0,i.setToolOptions)(t,n,o),n.removeEventListener(r.default.MOUSE_DOWN_ACTIVATE,e),n.addEventListener(r.default.MOUSE_DOWN_ACTIVATE,e)},disable:function(t){t.removeEventListener(r.default.MOUSE_DOWN_ACTIVATE,e)},enable:function(t){t.removeEventListener(r.default.MOUSE_DOWN_ACTIVATE,e)},deactivate:function(t){t.removeEventListener(r.default.MOUSE_DOWN_ACTIVATE,e)},getConfiguration:function(){return n},setConfiguration:function(e){n=e}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a},i=n(4)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=1,o=2;var r={setToolWidth:function(e){a=e},getToolWidth:function(){return a},setActiveWidth:function(e){o=e},getActiveWidth:function(){return o}};t.default=r},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=e.image,a={left:0,top:0,width:n.width,height:n.height},o=!1;return Object.keys(t).forEach(function(e){var n=t[e];!0!==n.allowedOutsideImage&&!1===r.default.cornerstoneMath.point.insideRect(n,a)&&(o=!0)}),o};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,i,l,d,u,s,c,f){var v=a.default.cornerstone,g=v.pixelToCanvas(t,n);c&&(g.x+=c);var m={centering:{x:!1,y:f}};if(n.boundingBox=(0,o.default)(e,i,g.x,g.y,u,m),n.hasMoved){var h=d(l).map(function(e){return v.pixelToCanvas(t,e)});(0,r.default)(h,g,n.boundingBox,e,u,s)}};var a=i(n(0)),o=i(n(11)),r=i(n(104));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){var a=[r.default.TOUCH_DRAG];return n&&!0===n.fireOnTouchStart&&a.push(r.default.TOUCH_START),{activate:function(o){n&&n.eventData&&(0,i.setToolOptions)(t,o,n.eventData),a.forEach(function(t){o.removeEventListener(t,e),o.addEventListener(t,e)}),n&&n.activateCallback&&n.activateCallback(o),n&&n.touchStartCallback&&o.addEventListener(r.default.TOUCH_START,n.touchStartCallback),n&&n.touchEndCallback&&o.addEventListener(r.default.TOUCH_END,n.touchEndCallback)},disable:function(t){a.forEach(function(n){t.removeEventListener(n,e)}),n&&n.disableCallback&&n.disableCallback(t),n&&n.touchStartCallback&&t.removeEventListener(r.default.TOUCH_START,n.touchStartCallback),n&&n.touchEndCallback&&t.removeEventListener(r.default.TOUCH_END,n.touchEndCallback)},enable:function(t){a.forEach(function(n){t.removeEventListener(n,e)}),n&&n.enableCallback&&n.enableCallback(t),n&&n.touchStartCallback&&t.removeEventListener(r.default.TOUCH_START,n.touchStartCallback),n&&n.touchEndCallback&&t.removeEventListener(r.default.TOUCH_END,n.touchEndCallback)},deactivate:function(t){a.forEach(function(n){t.removeEventListener(n,e)}),n&&n.deactivateCallback&&n.deactivateCallback(t),n&&n.touchStartCallback&&t.removeEventListener(r.default.TOUCH_START,n.touchStartCallback),n&&n.touchEndCallback&&t.removeEventListener(r.default.TOUCH_END,n.touchEndCallback)}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a},i=n(4)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=r.default.cornerstoneMath;if(e instanceof t.Vector3)return e;return new t.Vector3(e[0],e[1],e[2])};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=r.default.cornerstone,a=n.metaData.get("patientStudyModule",e.imageId),o=n.metaData.get("generalSeriesModule",e.imageId);if(a&&o&&"PT"===o.modality){var l=t*e.slope+e.intercept,d=a.patientWeight;if(d){var u=n.metaData.get("petIsotopeModule",e.imageId);if(u){var s=u.radiopharmaceuticalInfo,c=s.radiopharmaceuticalStartTime,f=s.radionuclideTotalDose,v=s.radionuclideHalfLife,g=o.seriesTime;if(c&&f&&v&&g){var m=i(g.fractionalSeconds||0)+g.seconds+60*g.minutes+60*g.hours*60-(i(c.fractionalSeconds)+c.seconds+60*c.minutes+60*c.hours*60);return l*d/(f*Math.exp(-m*Math.log(2)/v))*1e3}}}}};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a};function i(e){return parseFloat("."+e)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=15,o=a+"px Arial",r="transparent";var i={setFont:function(e){o=e},getFont:function(){return o},setFontSize:function(e){a=e},getFontSize:function(){return a},setBackgroundColor:function(e){r=e},getBackgroundColor:function(){return r}};t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e.boundingBox)return r.default.cornerstoneMath.point.insideRect(t,e.boundingBox)};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.freehand=void 0;var a=O(n(1)),o=O(n(0)),r=O(n(15)),i=O(n(7)),l=O(n(9)),d=O(n(32)),u=O(n(22)),s=O(n(20)),c=O(n(6)),f=O(n(5)),v=O(n(17)),g=n(2),m=n(4),h=n(8),p=n(55),E=O(n(98)),T=O(n(97)),y=O(n(96)),M=O(n(94)),_=O(n(93)),x=O(n(54)),b=n(34),S=n(3);function O(e){return e&&e.__esModule?e:{default:e}}function C(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var P="freehand",I={mouseLocation:{handles:{start:{highlight:!0,active:!0}}},keyDown:{shift:!1,ctrl:!1,alt:!1},activePencilMode:!1,spacing:5,activeHandleRadius:3,completeHandleRadius:6,alwaysShowHandles:!1,invalidColor:"crimson",modifying:!1,movingTextBox:!1,currentHandle:0,currentTool:-1};function L(e,t,n){return null!==w(e,t,n)}function w(e,t,n){var a=G.getConfiguration();if(void 0===t.handles)return null;if(!1===t.visible)return null;for(var r=0;r<t.handles.length;r++){var i=o.default.cornerstone.pixelToCanvas(e,t.handles[r]);if(o.default.cornerstoneMath.point.distance(i,n)<a.spacing)return r}return t.textBox&&(0,u.default)(t.textBox,n)?t.textBox:null}function D(e){var t=e.detail,n=G.getConfiguration();t.event.shiftKey&&(n.activePencilMode=!0),function(e){e.element.addEventListener(a.default.MOUSE_MOVE,R);var t={visible:!0,active:!0,invalidated:!0,color:void 0,handles:[],textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}},n=G.getConfiguration();n.mouseLocation.handles.start.x=e.currentPoints.image.x,n.mouseLocation.handles.start.y=e.currentPoints.image.y,(0,g.addToolState)(e.element,P,t);var o=(0,g.getToolState)(e.element,P);n.currentTool=o.data.length-1}(t),U(t),e.preventDefault(),e.stopPropagation()}function U(e){var t=(0,g.getToolState)(e.element,P);if(void 0!==t){var n=G.getConfiguration(),a=t.data[n.currentTool];if(!a.handles.invalidHandlePlacement){var r=new b.FreehandHandleData(e.currentPoints.image);a.handles.length&&a.handles[n.currentHandle-1].lines.push(e.currentPoints.image),a.handles.push(r),n.currentHandle+=1,o.default.cornerstone.updateImage(e.element)}}}function A(e,t){var n=(0,g.getToolState)(e.element,P);if(n){var a=G.getConfiguration(),r=n.data[a.currentTool];r.active=!1,r.highlight=!1,r.handles.invalidHandlePlacement=!1,void 0!==t&&r.handles[a.currentHandle-1].lines.push(r.handles[0]),a.modifying&&(a.modifying=!1,r.invalidated=!0),a.currentHandle=0,a.currentTool=-1,a.activePencilMode=!1,r.canComplete=!1,o.default.cornerstone.updateImage(e.element)}}function k(e){var t=e.detail,n=t.element,o=(0,m.getToolOptions)(P,n);if(!(0,f.default)(t.which,o.mouseButtonMask))return e.stopPropagation(),void e.preventDefault();var r=G.getConfiguration().currentTool;if(r<0)!function(e){var t=e.detail,n=function(e){var t=e.element,n=e.currentPoints.canvas,a=(0,g.getToolState)(t,P);if(a)for(var o=void 0,r=0;r<a.data.length;r++)if(null!==(o=w(t,a.data[r],n)))return{handleNearby:o,toolIndex:r}}(t);t.event.ctrlKey?(0,y.default)(e,n):void 0!==n&&function(e,t){var n=e.detail,o=n.element,r=(0,g.getToolState)(n.element,P),i=t.handleNearby;i.hasBoundingBox?function(e,t){var n=G.getConfiguration(),o=t.handleNearby,r=t.toolIndex;e.addEventListener(a.default.MOUSE_UP,N),e.addEventListener(a.default.MOUSE_DRAG,H),n.movingTextBox=!0,n.currentHandle=o,n.currentTool=r}(o,t):void 0!==i&&function(e,t,n){var o=G.getConfiguration(),r=t.handleNearby,i=t.toolIndex;e.removeEventListener(a.default.MOUSE_MOVE,R),o.dragOrigin={x:n.data[i].handles[r].x,y:n.data[i].handles[r].y},e.addEventListener(a.default.MOUSE_UP,N),e.addEventListener(a.default.MOUSE_CLICK,N),e.addEventListener(a.default.MOUSE_DRAG,H),o.modifying=!0,o.currentHandle=r,o.currentTool=i}(o,t,r);e.preventDefault(),e.stopPropagation()}(e,n)}(e);else{var i=(0,g.getToolState)(t.element,P);r>=0&&i.data[r].active&&function(e,t,n){var a=e.detail,o=G.getConfiguration(),r=a.element,i=t.data[n],l=w(r,i,a.currentPoints.canvas);!x.default.end(i.handles)&&i.canComplete?A(a,o.currentHandle):null===l&&U(a),e.preventDefault(),e.stopPropagation()}(e,i,r)}}function R(e){var t=e.detail,n=(0,g.getToolState)(t.element,P);if(n){if(G.getConfiguration().currentTool<0){if(!function(e,t){for(var n=!1,a=0;a<t.data.length;a++){var o=e.element,r=t.data[a],i=e.currentPoints.canvas;!0===(0,d.default)(o,r.handles,i)&&(n=!0),(L(o,r,i)&&!r.active||!L(o,r,i)&&r.active)&&(r.active=!r.active,n=!0),!0===r.textBox&&(0,u.default)(r.textBox,i)&&(r.active=!r.active,r.highlight=!r.highlight,n=!0)}return n}(t,n))return}else!function(e,t){var n=G.getConfiguration(),a=n.currentTool,r=e.element,i=t.data[a],l=e.currentPoints.canvas;if(j(e),function(e){var t=G.getConfiguration();if(e.handles.length<2)return!0;var n=void 0;n=t.activePencilMode?function(e){var t=G.getConfiguration().mouseLocation.handles.start,n=e.handles,a=x.default.newHandle(t,n);return!1===a&&(a=function(e,t){var n=G.getConfiguration(),a=e.handles;if(o.default.cornerstoneMath.point.distance(a[0],t)<n.spacing)return e.canComplete=!0,!1;e.canComplete=!1;for(var r=1;r<a.length-1;r++)if(o.default.cornerstoneMath.point.distance(a[r],t)<n.spacing)return!0;return!1}(e,t)),a}(e):function(e){var t=G.getConfiguration(),n=t.mouseLocation.handles.start,a=e.handles,r=!1;return e.canComplete=!1,o.default.cornerstoneMath.point.distance(a[0],n)<t.spacing&&!x.default.end(a)?(e.canComplete=!0,r=!1):r=x.default.newHandle(n,a),r}(e),e.handles.invalidHandlePlacement=n}(i),n.activePencilMode)!function(e,t){for(var n=G.getConfiguration(),a=n.mouseLocation.handles.start,r=0;r<t.length;r++)if(o.default.cornerstoneMath.point.distance(t[r],a)<n.spacing)return;U(e)}(e,i.handles);else{var d=w(r,i,l);null!==d&&!d.hasBoundingBox&&d<i.handles.length-1&&(n.mouseLocation.handles.start.x=i.handles[d].x,n.mouseLocation.handles.start.y=i.handles[d].y)}}(t,n);o.default.cornerstone.updateImage(t.element)}}function H(e){var t=e.detail,n=(0,g.getToolState)(t.element,P);if(n){var a=G.getConfiguration(),r=n.data[a.currentTool],i=a.currentHandle;j(t),a.currentTool>=0&&(0,E.default)(i,r),o.default.cornerstone.updateImage(t.element)}}function N(e){var t=e.detail,n=t.element,r=(0,g.getToolState)(t.element,P);(n.removeEventListener(a.default.MOUSE_UP,N),n.removeEventListener(a.default.MOUSE_DRAG,H),n.removeEventListener(a.default.MOUSE_CLICK,N),n.addEventListener(a.default.MOUSE_MOVE,R),void 0!==r)&&("handle"===(0,T.default)(e,r)&&A(t),e.preventDefault(),e.stopPropagation(),o.default.cornerstone.updateImage(t.element))}function j(e){var t=G.getConfiguration();t.mouseLocation.handles.start.x=e.currentPoints.image.x,t.mouseLocation.handles.start.y=e.currentPoints.image.y,(0,h.clipToBox)(t.mouseLocation.handles.start,e.image)}function B(e){var t=e.toString().split(".");return t[0]=t[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),t.join(".")}function V(e){var t=e.detail,n=(0,g.getToolState)(e.currentTarget,P);if(void 0!==n){var a=o.default.cornerstone,d=t.image,u=t.element,c=G.getConfiguration(),f=a.metaData.get("generalSeriesModule",d.imageId),m=void 0;f&&(m=f.modality);for(var h=(0,S.getNewContext)(t.canvasContext.canvas),p=r.default.getToolWidth(),E=function(e){var o=n.data[e];if(!1===o.visible)return"continue";(0,S.draw)(h,function(e){var n=i.default.getColorIfActive(o),r=void 0;if(o.active?o.handles.invalidHandlePlacement?(n=c.invalidColor,r=c.invalidColor):(n=i.default.getColorIfActive(o),r=i.default.getFillColor()):r=i.default.getToolColor(),o.handles.length)for(var f=0;f<o.handles.length;f++){var g=[].concat(C(o.handles[f].lines));f!==o.handles.length-1||o.polyBoundingBox||g.push(c.mouseLocation.handles.start),(0,S.drawJoinedLines)(e,t.element,o.handles[f],g,{color:n})}var h={fill:r};(c.alwaysShowHandles||c.keyDown.ctrl||o.active&&o.polyBoundingBox)&&(h.handleRadius=c.activeHandleRadius,(0,l.default)(e,t,o.handles,n,h)),o.canComplete&&(h.handleRadius=c.completeHandleRadius,(0,l.default)(e,t,[o.handles[0]],n,h)),o.active&&!o.polyBoundingBox&&(h.handleRadius=c.activeHandleRadius,(0,l.default)(e,t,c.mouseLocation.handles,n,h),(0,l.default)(e,t,[o.handles[0]],n,h));var E=void 0,T=void 0,x=void 0;if(!1===o.invalidated)T=o.meanStdDev,x=o.meanStdDevSUV,E=o.area;else if(!o.active){for(var b={left:o.handles[0].x,right:o.handles[0].x,bottom:o.handles[0].y,top:o.handles[0].x},O=0;O<o.handles.length;O++)b.left=Math.min(b.left,o.handles[O].x),b.right=Math.max(b.right,o.handles[O].x),b.bottom=Math.min(b.bottom,o.handles[O].y),b.top=Math.max(b.top,o.handles[O].y);var P={left:b.left,top:b.bottom,width:Math.abs(b.right-b.left),height:Math.abs(b.top-b.bottom)};if(o.polyBoundingBox=P,!d.color){var I=a.getPixels(u,P.left,P.top,P.width,P.height);T=(0,_.default)(I,P,o.handles),"PT"===m&&(x={mean:(0,s.default)(d,(T.mean-d.intercept)/d.slope),stdDev:(0,s.default)(d,(T.stdDev-d.intercept)/d.slope)}),T&&!isNaN(T.mean)&&(o.meanStdDev=T,o.meanStdDevSUV=x)}var L=(d.columnPixelSpacing||1)*(d.rowPixelSpacing||1);E=(0,M.default)(o.handles,L),isNaN(E)||(o.area=E),o.invalidated=!1}if(o.polyBoundingBox&&!o.textBox.freehand){o.textBox.hasMoved||(o.textBox.x=o.polyBoundingBox.left+o.polyBoundingBox.width,o.textBox.y=o.polyBoundingBox.top+o.polyBoundingBox.height/2);var w=function(e){var t=e.meanStdDev,n=e.meanStdDevSUV,a=e.area,o=[];if(t&&void 0!==t.mean){var r="";"CT"===m&&(r=" HU");var i="Mean: "+B(t.mean.toFixed(2))+r,l="StdDev: "+B(t.stdDev.toFixed(2))+r;if(n&&void 0!==n.mean){i+=" SUV: "+B(n.mean.toFixed(2)),l+=" SUV: "+B(n.stdDev.toFixed(2))}o.push(i),o.push(l)}if(a){var u=" mm"+String.fromCharCode(178);d.rowPixelSpacing&&d.columnPixelSpacing||(u=" pixels"+String.fromCharCode(178));var s="Area: "+B(a.toFixed(2))+u;o.push(s)}return o}(o);(0,v.default)(e,u,o.textBox,w,o.handles,y,n,p,0,!0)}})},T=0;T<n.data.length;T++)E(T)}function y(e){return e}}function W(e){e.removeEventListener(a.default.MOUSE_DOWN,k),e.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,D),e.removeEventListener(a.default.MOUSE_DRAG,H),e.removeEventListener(a.default.MOUSE_UP,N),e.removeEventListener(a.default.MOUSE_MOVE,R),e.removeEventListener(a.default.IMAGE_RENDERED,V),e.removeEventListener(a.default.KEY_DOWN,p.keyDownCallback),e.removeEventListener(a.default.KEY_UP,p.keyUpCallback)}var G={enable:function(e){W(e),e.addEventListener(a.default.IMAGE_RENDERED,V),o.default.cornerstone.updateImage(e)},disable:function(e){W(e),o.default.cornerstone.updateImage(e)},activate:function(e,t){(0,m.setToolOptions)(P,e,{mouseButtonMask:t}),W(e),e.addEventListener(a.default.IMAGE_RENDERED,V),e.addEventListener(a.default.MOUSE_MOVE,R),e.addEventListener(a.default.MOUSE_DOWN,k),e.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,D),e.addEventListener(a.default.KEY_DOWN,p.keyDownCallback),e.addEventListener(a.default.KEY_UP,p.keyUpCallback),o.default.cornerstone.updateImage(e)},deactivate:function(e,t){(0,m.setToolOptions)(P,e,{mouseButtonMask:t});var n=a.default.TOOL_DEACTIVATED,r={mouseButtonMask:t,toolType:P,type:n};(0,c.default)(e,n,r),W(e),e.addEventListener(a.default.IMAGE_RENDERED,V),e.addEventListener(a.default.MOUSE_MOVE,R),e.addEventListener(a.default.MOUSE_DOWN,k),e.addEventListener(a.default.KEY_DOWN,p.keyDownCallback),e.addEventListener(a.default.KEY_UP,p.keyUpCallback),o.default.cornerstone.updateImage(e)},getConfiguration:function(){return I},setConfiguration:function(e){I=e},pointNearTool:L};t.freehand=G},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t={};return{disable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e)},enable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e),t.addEventListener(a.default.IMAGE_RENDERED,e),o.default.cornerstone.updateImage(t)},getConfiguration:function(){return t},setConfiguration:function(e){t=e}}};var a=r(n(1)),o=r(n(0));function r(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,r){var i=void 0;if(t)return Object.keys(t).forEach(function(l){var d=t[l];if(d.hasOwnProperty("pointNearHandle")){if(d.pointNearHandle(e,d,n))return void(i=d)}else if(!0===d.hasBoundingBox){if((0,o.default)(d,n))return void(i=d)}else{var u=a.default.cornerstone.pixelToCanvas(e,d);if(a.default.cornerstoneMath.point.distance(u,n)<=r)return void(i=d)}}),i};var a=r(n(0)),o=r(n(22));function r(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalImageIdSpecificToolStateManager=t.newImageIdSpecificToolStateManager=void 0;var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a};function i(){var e={};return{get:function(t,n){var a=r.default.cornerstone.getEnabledElement(t);if(a.image&&!1!==e.hasOwnProperty(a.image.imageId)){var o=e[a.image.imageId];if(!1!==o.hasOwnProperty(n))return o[n]}},add:function(t,n,a){var o=r.default.cornerstone.getEnabledElement(t);o.image&&!1!==e.hasOwnProperty(o.image.imageId)||(e[o.image.imageId]={});var i=e[o.image.imageId];!1===i.hasOwnProperty(n)&&(i[n]={data:[]}),i[n].data.push(a)},clear:function(t){var n=r.default.cornerstone.getEnabledElement(t);n.image&&!1!==e.hasOwnProperty(n.image.imageId)&&delete e[n.image.imageId]},saveImageIdToolState:function(t){return e[t]},restoreImageIdToolState:function(t,n){e[t]=n},saveToolState:function(){return e},restoreToolState:function(t){e=t},toolState:e}}var l=i();t.newImageIdSpecificToolStateManager=i,t.globalImageIdSpecificToolStateManager=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a){var o=r.default.cornerstone,i={start:o.pixelToCanvas(e,t),end:o.pixelToCanvas(e,n)};return r.default.cornerstoneMath.lineSegment.distanceToPoint(i,a)};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,l,d,u){var s=o.default.cornerstone,c=e.element,f=s.pageToPixel(c,e.currentPoints.page.x,e.currentPoints.page.y+50),v={x:l.x-f.x,y:l.y-f.y};function g(e){var o=e.detail;l.x=o.currentPoints.image.x+v.x,l.y=o.currentPoints.image.y+v.y,u&&(0,i.clipToBox)(l,o.image),s.updateImage(c);var d=a.default.MEASUREMENT_MODIFIED,f={toolType:t,element:c,measurementData:n};(0,r.default)(c,d,f)}function m(e){var t=e.detail;if(c.removeEventListener(a.default.TOUCH_DRAG,g),c.removeEventListener(a.default.TOUCH_PINCH,m),c.removeEventListener(a.default.TOUCH_END,m),c.removeEventListener(a.default.TAP,m),c.removeEventListener(a.default.TOUCH_START,h),c.removeEventListener(a.default.TOOL_DEACTIVATED,p),e.type===a.default.TOUCH_PINCH||e.type===a.default.TOUCH_PRESS)return l.active=!1,s.updateImage(c),void d();l.active=!1,n.active=!1,l.x=t.currentPoints.image.x+v.x,l.y=t.currentPoints.image.y+v.y,u&&(0,i.clipToBox)(l,t.image),s.updateImage(c),"function"==typeof d&&d()}function h(e){return e.stopImmediatePropagation(),!1}function p(){c.removeEventListener(a.default.TOUCH_DRAG,g),c.removeEventListener(a.default.TOUCH_PINCH,m),c.removeEventListener(a.default.TOUCH_END,m),c.removeEventListener(a.default.TAP,m),c.removeEventListener(a.default.TOUCH_START,h),c.removeEventListener(a.default.TOOL_DEACTIVATED,p),l.active=!1,n.active=!1,l.x=e.currentPoints.image.x+v.x,l.y=e.currentPoints.image.y+v.y,u&&(0,i.clipToBox)(l,e.image),s.updateImage(c)}l.active=!0,n.active=!0,c.addEventListener(a.default.TOUCH_DRAG,g),c.addEventListener(a.default.TOUCH_PINCH,m),c.addEventListener(a.default.TOUCH_END,m),c.addEventListener(a.default.TAP,m),c.addEventListener(a.default.TOUCH_START,h),c.addEventListener(a.default.TOOL_DEACTIVATED,p)};var a=l(n(1)),o=l(n(0)),r=l(n(6)),i=n(8);function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return{activate:function(t){t.removeEventListener(r.default.MOUSE_WHEEL,e),t.addEventListener(r.default.MOUSE_WHEEL,e)},disable:function(t){t.removeEventListener(r.default.MOUSE_WHEEL,e)},enable:function(t){t.removeEventListener(r.default.MOUSE_WHEEL,e)},deactivate:function(t){t.removeEventListener(r.default.MOUSE_WHEEL,e)}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,l,d,u){var s=o.default.cornerstone,c=e.element;function f(e){var o=e.detail;l.active=!0,l.x=o.currentPoints.image.x,l.y=o.currentPoints.image.y,u&&(0,i.clipToBox)(l,o.image),s.updateImage(c);var d=a.default.MEASUREMENT_MODIFIED,f={toolType:t,element:c,measurementData:n};(0,r.default)(c,d,f)}function v(e){c.removeEventListener(a.default.MOUSE_MOVE,v),c.removeEventListener(a.default.MOUSE_DRAG,v),c.addEventListener(a.default.MOUSE_MOVE,f),c.addEventListener(a.default.MOUSE_DRAG,f),c.addEventListener(a.default.MOUSE_CLICK,h),e.type===a.default.MOUSE_DRAG&&c.addEventListener(a.default.MOUSE_UP,h)}function g(e){e.detail.measurementData===n&&h()}function m(e){e.detail.toolType===t&&(c.removeEventListener(a.default.MOUSE_MOVE,f),c.removeEventListener(a.default.MOUSE_DRAG,f),c.removeEventListener(a.default.MOUSE_CLICK,h),c.removeEventListener(a.default.MOUSE_UP,h),c.removeEventListener(a.default.MEASUREMENT_REMOVED,g),c.removeEventListener(a.default.TOOL_DEACTIVATED,m),l.active=!1,s.updateImage(c))}function h(){c.removeEventListener(a.default.MOUSE_MOVE,f),c.removeEventListener(a.default.MOUSE_DRAG,f),c.removeEventListener(a.default.MOUSE_CLICK,h),c.removeEventListener(a.default.MOUSE_UP,h),c.removeEventListener(a.default.MEASUREMENT_REMOVED,g),c.removeEventListener(a.default.TOOL_DEACTIVATED,m),l.active=!1,s.updateImage(c),"function"==typeof d&&d()}c.addEventListener(a.default.MOUSE_DRAG,v),c.addEventListener(a.default.MOUSE_MOVE,v),c.addEventListener(a.default.MEASUREMENT_REMOVED,g),c.addEventListener(a.default.TOOL_DEACTIVATED,m)};var a=l(n(1)),o=l(n(0)),r=l(n(6)),i=n(8);function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,l,d,u){var s=o.default.cornerstone,c=e.element,f={x:l.x-e.currentPoints.image.x,y:l.y-e.currentPoints.image.y};function v(e){var o=e.detail;!1===l.hasMoved&&(l.hasMoved=!0),l.active=!0,l.x=o.currentPoints.image.x+f.x,l.y=o.currentPoints.image.y+f.y,u&&(0,i.clipToBox)(l,o.image),s.updateImage(c);var d=a.default.MEASUREMENT_MODIFIED,v={toolType:t,element:c,measurementData:n};(0,r.default)(c,d,v)}function g(){l.active=!1,c.removeEventListener(a.default.MOUSE_DRAG,v),c.removeEventListener(a.default.MOUSE_UP,g),c.removeEventListener(a.default.MOUSE_CLICK,g),s.updateImage(c),"function"==typeof d&&d()}c.addEventListener(a.default.MOUSE_DRAG,v),c.addEventListener(a.default.MOUSE_UP,g),c.addEventListener(a.default.MOUSE_CLICK,g)};var a=l(n(1)),o=l(n(0)),r=l(n(6)),i=n(8);function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a){a||(a=6);var o=function(e){var t=void 0;return Object.keys(e).forEach(function(n){var a=e[n];!0!==a.active||(t=a)}),t}(t),i=(0,r.default)(e,t,n,a);return o!==i&&(void 0!==i&&(i.active=!0),void 0!==o&&(o.active=!1),!0)};var a,o=n(25),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=void 0,o={default:6,IE:{9:6,10:8,default:8},Firefox:{default:6},Opera:{10:8,11:6,12:6,default:6},Chrome:{default:6},Safari:{default:6}};function r(){var e=navigator.userAgent,t=e.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i)||[],n=void 0;return/trident/i.test(t[1])?"IE "+((n=/\brv[ :]+(\d+)/g.exec(e)||[])[1]||""):"Chrome"===t[1]&&null!==(n=e.match(/\b(OPR|Edge)\/(\d+)/))?n.slice(1).join(" ").replace("OPR","Opera"):(t=t[2]?[t[1],t[2]]:[navigator.appName,navigator.appVersion,"-?"],null!==(n=e.match(/version\/(\d+)/i))&&t.splice(1,1,n[1]),t.join(" "))}function i(){var e=r().split(" "),t=e[0],n=e[1],a=o[t];return a?a[n]?a[n]:a.default:o.default}t.getDefaultSimultaneousRequests=i,t.getMaxSimultaneousRequests=function(){return a||i()},t.setMaxSimultaneousRequests=function(e){a=e},t.getBrowserInfo=r,t.isMobileDevice=function(){return new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini").test(navigator.userAgent)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.FreehandHandleData=function e(t){var n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.x=t.x,this.y=t.y,this.highlight=n,this.active=a,this.lines=[]}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n={},a=[r.default.MULTI_TOUCH_DRAG];return t&&!0===t.fireOnTouchStart&&a.push(r.default.MULTI_TOUCH_START),{activate:function(n){a.forEach(function(t){n.removeEventListener(t,e),n.addEventListener(t,e)}),t&&t.activateCallback&&t.activateCallback(n)},disable:function(n){a.forEach(function(t){n.removeEventListener(t,e)}),t&&t.disableCallback&&t.disableCallback(n)},enable:function(n){a.forEach(function(t){n.removeEventListener(t,e)}),t&&t.enableCallback&&t.enableCallback(n)},deactivate:function(n){a.forEach(function(t){n.removeEventListener(t,e)}),t&&t.deactivateCallback&&t.deactivateCallback(n)},getConfiguration:function(){return n},setConfiguration:function(e){n=e}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){var l=(0,o.getToolState)(e,"timeSeries");if(l&&l.data&&l.data.length){var d=a.default.cornerstone,u=l.data[0],s=u.stacks[u.currentStackIndex].currentImageIdIndex,c=u.currentStackIndex+t;if(n?(c>=u.stacks.length&&(c=0),c<0&&(c=u.stacks.length-1)):c=(0,i.default)(c,0,u.stacks.length-1),c!==u.currentStackIndex){var f=d.getViewport(e),v=u.stacks[c],g=r.default.getStartLoadHandler(),m=r.default.getEndLoadHandler(),h=r.default.getErrorLoadingHandler();g&&g(e);(!0===v.preventCache?d.loadImage(v.imageIds[s]):d.loadAndCacheImage(v.imageIds[s])).then(function(t){u.currentImageIdIndex!==s&&(v.currentImageIdIndex=s,u.currentStackIndex=c,d.displayImage(e,t,f),m&&m(e,t))},function(t){var n=v.imageIds[s];h&&h(e,n,t)})}}};var a=l(n(0)),o=n(2),r=l(n(13)),i=l(n(8));function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,u,s,c){var f=o.default.cornerstone,v=e.detail.element;function g(e){var n=e.detail;t.active=!0,Object.keys(t.handles).forEach(function(e){var a=t.handles[e];!0!==a.movesIndependently&&(a.x+=n.deltaPoints.image.x,a.y+=n.deltaPoints.image.y,s.preventHandleOutsideImage&&(0,d.clipToBox)(a,n.image))}),f.updateImage(v);var o=a.default.MEASUREMENT_MODIFIED,r={toolType:u,element:v,measurementData:t};(0,l.default)(v,o,r),e.preventDefault(),e.stopPropagation()}function m(e){var n=e.detail;t.invalidated=!0,v.removeEventListener(a.default.MOUSE_DRAG,g),v.removeEventListener(a.default.MOUSE_UP,m),v.removeEventListener(a.default.MOUSE_CLICK,m),!0===s.deleteIfHandleOutsideImage&&(0,r.default)(n,t.handles)&&(0,i.removeToolState)(v,u,t),f.updateImage(v),"function"==typeof c&&c()}return v.addEventListener(a.default.MOUSE_DRAG,g),v.addEventListener(a.default.MOUSE_UP,m),v.addEventListener(a.default.MOUSE_CLICK,m),!0};var a=u(n(1)),o=u(n(0)),r=u(n(16)),i=n(2),l=u(n(6)),d=n(8);function u(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=void 0;var o={setCoords:function(e){a=e.currentPoints.canvas},getCoords:function(){return a}};t.default=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return{page:r.default.cornerstoneMath.point.copy(e.page),image:r.default.cornerstoneMath.point.copy(e.image),client:r.default.cornerstoneMath.point.copy(e.client),canvas:r.default.cornerstoneMath.point.copy(e.canvas)}};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a,o){if(!e)throw new Error("getRGBPixels: parameter element must not be undefined");t=Math.round(t),n=Math.round(n);var i=r.default.cornerstone.getEnabledElement(e),l=[],d=0,u=i.image.getPixelData(),s=void 0,c=void 0,f=void 0;if(i.image.color)for(c=0;c<o;c++)for(f=0;f<a;f++){var v=u[s=4*((c+n)*i.image.columns+(f+t))],g=u[s+1],m=u[s+2],h=u[s+3];l[d++]=v,l[d++]=g,l[d++]=m,l[d++]=h}return l};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=e.width/2,a=e.height/2;if(n<=0||a<=0)return!1;var o=e.left+n,r=e.top+a,i=t.x-o,l=t.y-r;return i*i/(n*n)+l*l/(a*a)<=1}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=Math.pow(10,t);return Math.round(e*n)/n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],d=(0,r.getToolState)(e,"stack");if(d&&d.data&&d.data.length){var u=d.data[0];u.pending||(u.pending=[]);var s=u.currentImageIdIndex+t;if(n)s%=u.imageIds.length;else s=(0,i.default)(s,0,u.imageIds.length-1);if(l)(0,o.default)(e,s);else{var c={index:s};u.pending.push(c),function e(t,n,r){if(t.pending[0]===n){if(t.currentImageIdIndex===n.index)return t.pending.splice(t.pending.indexOf(n),1),void(t.pending.length>0&&e(t,t.pending[0],r));r.addEventListener(a.default.NEW_IMAGE,function e(i){t.imageIds.indexOf(i.detail.image.imageId)===n.index&&(t.pending.splice(t.pending.indexOf(n),1),r.removeEventListener(a.default.NEW_IMAGE,e),t.pending.length>0&&function e(t,n,r){if(t.pending[0]===n){if(t.currentImageIdIndex===n.index)return t.pending.splice(t.pending.indexOf(n),1),void(t.pending.length>0&&e(t,t.pending[0],r));r.addEventListener(a.default.NEW_IMAGE,function o(i){t.imageIds.indexOf(i.detail.image.imageId)===n.index&&(t.pending.splice(t.pending.indexOf(n),1),r.removeEventListener(a.default.NEW_IMAGE,o),t.pending.length>0&&e(t,t.pending[0],r))}),(0,o.default)(r,n.index)}}(t,t.pending[0],r))}),(0,o.default)(r,n.index)}}(u,c,e)}}};var a=l(n(1)),o=l(n(65)),r=n(2),i=l(n(8));function l(e){return e&&e.__esModule?e:{default:e}}function d(e,t,n){if(e.pending[0]===t){if(e.currentImageIdIndex===t.index){e.pending.splice(e.pending.indexOf(t),1);if(e.pending.length>0){d(e,e.pending[0],n)}return}var r=function o(r){var i;if(e.imageIds.indexOf(r.detail.image.imageId)===t.index){e.pending.splice(e.pending.indexOf(t),1);n.removeEventListener(a.default.NEW_IMAGE,o);if(e.pending.length>0){d(e,e.pending[0],n)}}};n.addEventListener(a.default.NEW_IMAGE,r);(0,o.default)(n,t.index)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(33);var l={interaction:[],thumbnail:[],prefetch:[]},d={interaction:0,thumbnail:0,prefetch:0},u={interaction:6,thumbnail:6,prefetch:5},s=!1,c=20;function f(){s&&setTimeout(function(){g()},c)}function v(e){var t=r.default.cornerstone,n=e.type;d[n]++,s=!0;var a=e.imageId,o=e.doneCallback,i=e.failCallback,l=t.imageCache.getImageLoadObject(a);if(l)l.promise.then(function(e){d[n]--,o(e),f()},function(e){d[n]--,i(e),f()});else{var u=function(e){return"prefetch"===e.type?-5:"interactive"===e.type?0:"thumbnail"===e.type?5:void 0}(e);(!0===e.preventCache?t.loadImage(a,{priority:u,type:e.type}):t.loadAndCacheImage(a,{priority:u,type:e.type})).then(function(e){d[n]--,o(e),f()},function(e){d[n]--,i(e),f()})}}function g(){var e=(0,i.getMaxSimultaneousRequests)();u={interaction:Math.max(e,1),thumbnail:Math.max(e-2,1),prefetch:Math.max(e-1,1)};for(var t=e-(d.interaction+d.thumbnail+d.prefetch),n=0;n<t;n++){var a=m();a&&v(a)}}function m(){return l.interaction.length&&d.interaction<u.interaction?l.interaction.shift():l.thumbnail.length&&d.thumbnail<u.thumbnail?l.thumbnail.shift():l.prefetch.length&&d.prefetch<u.prefetch?l.prefetch.shift():(l.interaction.length||l.thumbnail.length||l.prefetch.length||(s=!1),!1)}t.default={addRequest:function(e,t,n,a,o,i,d){if(!l.hasOwnProperty(n))throw new Error("Request type must be one of interaction, thumbnail, or prefetch");if(e&&t){var u={type:n,imageId:t,preventCache:a,doneCallback:o,failCallback:i},c=r.default.cornerstone.imageCache.getImageLoadObject(t);c?c.promise.then(function(e){o(e)},function(e){i(e)}):(d?l[n].unshift(u):l[n].push(u),s=!0)}},clearRequestStack:function(e){if(!l.hasOwnProperty(e))throw new Error("Request type must be one of interaction, thumbnail, or prefetch");l[e]=[]},startGrabbing:g,getRequestPool:function(){return l}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.projectPatientPointToImagePlane=function(e,t){var n=(0,o.default)(t.rowCosines),a=(0,o.default)(t.columnCosines),r=(0,o.default)(t.imagePositionPatient),i=e.clone().sub(r),l=n.dot(i)/t.columnPixelSpacing,d=a.dot(i)/t.rowPixelSpacing;return{x:l,y:d}},t.imagePointToPatientPoint=i,t.planePlaneIntersection=function(e,t){var n=(0,o.default)(e.rowCosines),r=(0,o.default)(e.columnCosines),l=(0,o.default)(e.imagePositionPatient),d=(0,o.default)(t.rowCosines),u=(0,o.default)(t.columnCosines),s=(0,o.default)(t.imagePositionPatient),c=n.clone().cross(r),f=new a.default.cornerstoneMath.Plane;f.setFromNormalAndCoplanarPoint(c,l);var v=d.clone().cross(u),g=new a.default.cornerstoneMath.Plane;g.setFromNormalAndCoplanarPoint(v,s);var m=g.clone().intersectPlane(f),h=m.origin,p=m.direction,E=i({x:t.columns,y:t.rows},t),T=s.distanceTo(E),y=new a.default.cornerstoneMath.Line3;y.start=h,y.end=h.clone().add(p.multiplyScalar(T));var M=function(e){var t=i({x:0,y:0},e),n=i({x:e.columns,y:0},e),o=i({x:0,y:e.rows},e),r=i({x:e.columns,y:e.rows},e);return{top:new a.default.cornerstoneMath.Line3(t,n),left:new a.default.cornerstoneMath.Line3(t,o),right:new a.default.cornerstoneMath.Line3(n,r),bottom:new a.default.cornerstoneMath.Line3(o,r)}}(t),_=function(e,t){var n=[];return Object.keys(t).forEach(function(a){var o=t[a],r=e.intersectLine(o);r&&n.push(r)}),n}(y,M);if(2!==_.length)return;return{start:_[0],end:_[1]}};var a=r(n(0)),o=r(n(19));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=(0,o.default)(t.rowCosines),a=(0,o.default)(t.columnCosines),r=(0,o.default)(t.imagePositionPatient),i=n.clone().multiplyScalar(e.x);i.multiplyScalar(t.columnPixelSpacing);var l=a.clone().multiplyScalar(e.y);l.multiplyScalar(t.rowPixelSpacing);var d=i.add(l);return d.add(r),d}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getToolOptions=t.setToolOptions=t.version=t.adaptiveBrush=t.brush=t.zoomTouchDrag=t.zoomTouchPinch=t.zoomWheel=t.zoom=t.wwwcRegionTouch=t.wwwcRegion=t.wwwcTouchDrag=t.wwwc=t.touchTool=t.touchPinchTool=t.touchDragTool=t.textMarkerTouch=t.textMarker=t.simpleMouseButtonTool=t.simpleAngleTouch=t.simpleAngle=t.seedAnnotateTouch=t.seedAnnotate=t.scaleOverlayTool=t.saveAs=t.rotateTouch=t.rotateTouchDrag=t.rotate=t.rectangleRoiTouch=t.rectangleRoi=t.probeTouch=t.probe=t.panMultiTouch=t.panTouchDrag=t.pan=t.orientationMarkers=t.multiTouchDragTool=t.mouseWheelTool=t.mouseButtonTool=t.mouseButtonRectangleTool=t.magnifyTouchDrag=t.magnify=t.lengthTouch=t.length=t.keyboardTool=t.imageStats=t.highlightTouch=t.highlight=t.freehandSculpter=t.freehand=t.eraserTouch=t.eraser=t.ellipticalRoiTouch=t.ellipticalRoi=t.dragProbeTouch=void 0,t.dragProbe=t.doubleTapZoom=t.doubleTapTool=t.displayTool=t.crosshairsTouch=t.crosshairs=t.arrowAnnotateTouch=t.arrowAnnotate=t.angleTouch=t.angle=t.touchInput=t.preventGhostClick=t.mouseWheelInput=t.mouseInput=t.keyboardInput=t.touchMoveHandle=t.touchMoveAllHandles=t.moveNewHandleTouch=t.moveNewHandle=t.moveHandle=t.moveAllHandles=t.handleActivator=t.getHandleNearImagePoint=t.drawHandles=t.anyHandlesOutsideImage=t.stopClip=t.playClip=t.stackRenderers=t.scrollIndicator=t.stackPrefetch=t.stackScrollMultiTouch=t.stackScrollTouchDrag=t.stackScrollWheel=t.stackScroll=t.stackScrollKeyboard=t.appState=t.globalFrameOfReferenceSpecificToolStateManager=t.newFrameOfReferenceSpecificToolStateManager=t.globalImageIdSpecificToolStateManager=t.newImageIdSpecificToolStateManager=t.loadHandlerManager=t.addStackStateManager=t.newStackSpecificToolStateManager=t.stackSpecificStateManager=t.textStyle=t.newTimeSeriesSpecificToolStateManager=t.addTimeSeriesStateManager=t.toolColors=t.toolCoordinates=t.getElementToolStateManager=t.setElementToolStateManager=t.clearToolState=t.removeToolState=t.getToolState=t.addToolState=t.toolStyle=t.panZoomSynchronizer=t.stackImageIndexSynchronizer=t.stackImagePositionOffsetSynchronizer=t.stackImagePositionSynchronizer=t.stackScrollSynchronizer=t.Synchronizer=t.updateImageSynchronizer=t.wwwcSynchronizer=t.timeSeriesScrollTouchDrag=t.timeSeriesScrollWheel=t.timeSeriesScroll=t.timeSeriesPlayer=t.incrementTimePoint=t.probeTool4D=t.calculateEllipseStatistics=t.calculateSUV=t.copyPoints=t.drawArrow=t.drawCircle=t.drawEllipse=t.drawTextBox=t.getLuminance=t.isMobileDevice=t.getBrowserInfo=t.getMaxSimultaneousRequests=t.getDefaultSimultaneousRequests=t.getRGBPixels=t.isMouseButtonEnabled=t.makeUnselectable=t.pointInEllipse=t.pointInsideBoundingBox=t.planePlaneIntersection=t.imagePointToPatientPoint=t.projectPatientPointToImagePlane=t.roundToDecimal=t.scroll=t.scrollToIndex=t.setContextToDisplayFontSize=t.requestPoolManager=t.orientation=t.referenceLines=t.EVENTS=t.external=t.drawing=void 0;var a=n(0);Object.defineProperty(t,"external",{enumerable:!0,get:function(){return lt(a).default}});var o=n(1);Object.defineProperty(t,"EVENTS",{enumerable:!0,get:function(){return lt(o).default}});var r=n(142);Object.defineProperty(t,"referenceLines",{enumerable:!0,get:function(){return lt(r).default}});var i=n(66);Object.defineProperty(t,"orientation",{enumerable:!0,get:function(){return lt(i).default}});var l=n(44);Object.defineProperty(t,"requestPoolManager",{enumerable:!0,get:function(){return lt(l).default}});var d=n(138);Object.defineProperty(t,"setContextToDisplayFontSize",{enumerable:!0,get:function(){return lt(d).default}});var u=n(65);Object.defineProperty(t,"scrollToIndex",{enumerable:!0,get:function(){return lt(u).default}});var s=n(43);Object.defineProperty(t,"scroll",{enumerable:!0,get:function(){return lt(s).default}});var c=n(42);Object.defineProperty(t,"roundToDecimal",{enumerable:!0,get:function(){return lt(c).default}});var f=n(45);Object.defineProperty(t,"projectPatientPointToImagePlane",{enumerable:!0,get:function(){return f.projectPatientPointToImagePlane}}),Object.defineProperty(t,"imagePointToPatientPoint",{enumerable:!0,get:function(){return f.imagePointToPatientPoint}}),Object.defineProperty(t,"planePlaneIntersection",{enumerable:!0,get:function(){return f.planePlaneIntersection}});var v=n(22);Object.defineProperty(t,"pointInsideBoundingBox",{enumerable:!0,get:function(){return lt(v).default}});var g=n(41);Object.defineProperty(t,"pointInEllipse",{enumerable:!0,get:function(){return lt(g).default}});var m=n(137);Object.defineProperty(t,"makeUnselectable",{enumerable:!0,get:function(){return lt(m).default}});var h=n(5);Object.defineProperty(t,"isMouseButtonEnabled",{enumerable:!0,get:function(){return lt(h).default}});var p=n(40);Object.defineProperty(t,"getRGBPixels",{enumerable:!0,get:function(){return lt(p).default}});var E=n(33);Object.defineProperty(t,"getDefaultSimultaneousRequests",{enumerable:!0,get:function(){return E.getDefaultSimultaneousRequests}}),Object.defineProperty(t,"getMaxSimultaneousRequests",{enumerable:!0,get:function(){return E.getMaxSimultaneousRequests}}),Object.defineProperty(t,"getBrowserInfo",{enumerable:!0,get:function(){return E.getBrowserInfo}}),Object.defineProperty(t,"isMobileDevice",{enumerable:!0,get:function(){return E.isMobileDevice}});var T=n(64);Object.defineProperty(t,"getLuminance",{enumerable:!0,get:function(){return lt(T).default}});var y=n(11);Object.defineProperty(t,"drawTextBox",{enumerable:!0,get:function(){return lt(y).default}});var M=n(136);Object.defineProperty(t,"drawEllipse",{enumerable:!0,get:function(){return lt(M).default}});var _=n(135);Object.defineProperty(t,"drawCircle",{enumerable:!0,get:function(){return lt(_).default}});var x=n(63);Object.defineProperty(t,"drawArrow",{enumerable:!0,get:function(){return lt(x).default}});var b=n(39);Object.defineProperty(t,"copyPoints",{enumerable:!0,get:function(){return lt(b).default}});var S=n(20);Object.defineProperty(t,"calculateSUV",{enumerable:!0,get:function(){return lt(S).default}});var O=n(62);Object.defineProperty(t,"calculateEllipseStatistics",{enumerable:!0,get:function(){return lt(O).default}});var C=n(134);Object.defineProperty(t,"probeTool4D",{enumerable:!0,get:function(){return lt(C).default}});var P=n(36);Object.defineProperty(t,"incrementTimePoint",{enumerable:!0,get:function(){return lt(P).default}});var I=n(131);Object.defineProperty(t,"timeSeriesPlayer",{enumerable:!0,get:function(){return lt(I).default}});var L=n(130);Object.defineProperty(t,"timeSeriesScroll",{enumerable:!0,get:function(){return L.timeSeriesScroll}}),Object.defineProperty(t,"timeSeriesScrollWheel",{enumerable:!0,get:function(){return L.timeSeriesScrollWheel}}),Object.defineProperty(t,"timeSeriesScrollTouchDrag",{enumerable:!0,get:function(){return L.timeSeriesScrollTouchDrag}});var w=n(129);Object.defineProperty(t,"wwwcSynchronizer",{enumerable:!0,get:function(){return lt(w).default}});var D=n(128);Object.defineProperty(t,"updateImageSynchronizer",{enumerable:!0,get:function(){return lt(D).default}});var U=n(127);Object.defineProperty(t,"Synchronizer",{enumerable:!0,get:function(){return lt(U).default}});var A=n(126);Object.defineProperty(t,"stackScrollSynchronizer",{enumerable:!0,get:function(){return lt(A).default}});var k=n(125);Object.defineProperty(t,"stackImagePositionSynchronizer",{enumerable:!0,get:function(){return lt(k).default}});var R=n(124);Object.defineProperty(t,"stackImagePositionOffsetSynchronizer",{enumerable:!0,get:function(){return lt(R).default}});var H=n(123);Object.defineProperty(t,"stackImageIndexSynchronizer",{enumerable:!0,get:function(){return lt(H).default}});var N=n(122);Object.defineProperty(t,"panZoomSynchronizer",{enumerable:!0,get:function(){return lt(N).default}});var j=n(15);Object.defineProperty(t,"toolStyle",{enumerable:!0,get:function(){return lt(j).default}});var B=n(2);Object.defineProperty(t,"addToolState",{enumerable:!0,get:function(){return B.addToolState}}),Object.defineProperty(t,"getToolState",{enumerable:!0,get:function(){return B.getToolState}}),Object.defineProperty(t,"removeToolState",{enumerable:!0,get:function(){return B.removeToolState}}),Object.defineProperty(t,"clearToolState",{enumerable:!0,get:function(){return B.clearToolState}}),Object.defineProperty(t,"setElementToolStateManager",{enumerable:!0,get:function(){return B.setElementToolStateManager}}),Object.defineProperty(t,"getElementToolStateManager",{enumerable:!0,get:function(){return B.getElementToolStateManager}});var V=n(38);Object.defineProperty(t,"toolCoordinates",{enumerable:!0,get:function(){return lt(V).default}});var W=n(7);Object.defineProperty(t,"toolColors",{enumerable:!0,get:function(){return lt(W).default}});var G=n(121);Object.defineProperty(t,"addTimeSeriesStateManager",{enumerable:!0,get:function(){return G.addTimeSeriesStateManager}}),Object.defineProperty(t,"newTimeSeriesSpecificToolStateManager",{enumerable:!0,get:function(){return G.newTimeSeriesSpecificToolStateManager}});var F=n(21);Object.defineProperty(t,"textStyle",{enumerable:!0,get:function(){return lt(F).default}});var z=n(120);Object.defineProperty(t,"stackSpecificStateManager",{enumerable:!0,get:function(){return z.stackSpecificStateManager}}),Object.defineProperty(t,"newStackSpecificToolStateManager",{enumerable:!0,get:function(){return z.newStackSpecificToolStateManager}}),Object.defineProperty(t,"addStackStateManager",{enumerable:!0,get:function(){return z.addStackStateManager}});var K=n(13);Object.defineProperty(t,"loadHandlerManager",{enumerable:!0,get:function(){return lt(K).default}});var Y=n(26);Object.defineProperty(t,"newImageIdSpecificToolStateManager",{enumerable:!0,get:function(){return Y.newImageIdSpecificToolStateManager}}),Object.defineProperty(t,"globalImageIdSpecificToolStateManager",{enumerable:!0,get:function(){return Y.globalImageIdSpecificToolStateManager}});var q=n(119);Object.defineProperty(t,"newFrameOfReferenceSpecificToolStateManager",{enumerable:!0,get:function(){return q.newFrameOfReferenceSpecificToolStateManager}}),Object.defineProperty(t,"globalFrameOfReferenceSpecificToolStateManager",{enumerable:!0,get:function(){return q.globalFrameOfReferenceSpecificToolStateManager}});var X=n(118);Object.defineProperty(t,"appState",{enumerable:!0,get:function(){return lt(X).default}});var J=n(117);Object.defineProperty(t,"stackScrollKeyboard",{enumerable:!0,get:function(){return lt(J).default}});var Z=n(116);Object.defineProperty(t,"stackScroll",{enumerable:!0,get:function(){return Z.stackScroll}}),Object.defineProperty(t,"stackScrollWheel",{enumerable:!0,get:function(){return Z.stackScrollWheel}}),Object.defineProperty(t,"stackScrollTouchDrag",{enumerable:!0,get:function(){return Z.stackScrollTouchDrag}}),Object.defineProperty(t,"stackScrollMultiTouch",{enumerable:!0,get:function(){return Z.stackScrollMultiTouch}});var Q=n(115);Object.defineProperty(t,"stackPrefetch",{enumerable:!0,get:function(){return lt(Q).default}});var $=n(114);Object.defineProperty(t,"scrollIndicator",{enumerable:!0,get:function(){return lt($).default}});var ee=n(113);Object.defineProperty(t,"stackRenderers",{enumerable:!0,get:function(){return lt(ee).default}});var te=n(111);Object.defineProperty(t,"playClip",{enumerable:!0,get:function(){return te.playClip}}),Object.defineProperty(t,"stopClip",{enumerable:!0,get:function(){return te.stopClip}});var ne=n(16);Object.defineProperty(t,"anyHandlesOutsideImage",{enumerable:!0,get:function(){return lt(ne).default}});var ae=n(9);Object.defineProperty(t,"drawHandles",{enumerable:!0,get:function(){return lt(ae).default}});var oe=n(25);Object.defineProperty(t,"getHandleNearImagePoint",{enumerable:!0,get:function(){return lt(oe).default}});var re=n(32);Object.defineProperty(t,"handleActivator",{enumerable:!0,get:function(){return lt(re).default}});var ie=n(37);Object.defineProperty(t,"moveAllHandles",{enumerable:!0,get:function(){return lt(ie).default}});var le=n(31);Object.defineProperty(t,"moveHandle",{enumerable:!0,get:function(){return lt(le).default}});var de=n(30);Object.defineProperty(t,"moveNewHandle",{enumerable:!0,get:function(){return lt(de).default}});var ue=n(28);Object.defineProperty(t,"moveNewHandleTouch",{enumerable:!0,get:function(){return lt(ue).default}});var se=n(60);Object.defineProperty(t,"touchMoveAllHandles",{enumerable:!0,get:function(){return lt(se).default}});var ce=n(59);Object.defineProperty(t,"touchMoveHandle",{enumerable:!0,get:function(){return lt(ce).default}});var fe=n(110);Object.defineProperty(t,"keyboardInput",{enumerable:!0,get:function(){return lt(fe).default}});var ve=n(109);Object.defineProperty(t,"mouseInput",{enumerable:!0,get:function(){return lt(ve).default}});var ge=n(108);Object.defineProperty(t,"mouseWheelInput",{enumerable:!0,get:function(){return lt(ge).default}});var me=n(58);Object.defineProperty(t,"preventGhostClick",{enumerable:!0,get:function(){return lt(me).default}});var he=n(107);Object.defineProperty(t,"touchInput",{enumerable:!0,get:function(){return lt(he).default}});var pe=n(106);Object.defineProperty(t,"angle",{enumerable:!0,get:function(){return pe.angle}}),Object.defineProperty(t,"angleTouch",{enumerable:!0,get:function(){return pe.angleTouch}});var Ee=n(105);Object.defineProperty(t,"arrowAnnotate",{enumerable:!0,get:function(){return Ee.arrowAnnotate}}),Object.defineProperty(t,"arrowAnnotateTouch",{enumerable:!0,get:function(){return Ee.arrowAnnotateTouch}});var Te=n(103);Object.defineProperty(t,"crosshairs",{enumerable:!0,get:function(){return Te.crosshairs}}),Object.defineProperty(t,"crosshairsTouch",{enumerable:!0,get:function(){return Te.crosshairsTouch}});var ye=n(24);Object.defineProperty(t,"displayTool",{enumerable:!0,get:function(){return lt(ye).default}});var Me=n(57);Object.defineProperty(t,"doubleTapTool",{enumerable:!0,get:function(){return lt(Me).default}});var _e=n(102);Object.defineProperty(t,"doubleTapZoom",{enumerable:!0,get:function(){return lt(_e).default}});var xe=n(101);Object.defineProperty(t,"dragProbe",{enumerable:!0,get:function(){return xe.dragProbe}}),Object.defineProperty(t,"dragProbeTouch",{enumerable:!0,get:function(){return xe.dragProbeTouch}});var be=n(100);Object.defineProperty(t,"ellipticalRoi",{enumerable:!0,get:function(){return be.ellipticalRoi}}),Object.defineProperty(t,"ellipticalRoiTouch",{enumerable:!0,get:function(){return be.ellipticalRoiTouch}});var Se=n(99);Object.defineProperty(t,"eraser",{enumerable:!0,get:function(){return Se.eraser}}),Object.defineProperty(t,"eraserTouch",{enumerable:!0,get:function(){return Se.eraserTouch}});var Oe=n(23);Object.defineProperty(t,"freehand",{enumerable:!0,get:function(){return Oe.freehand}});var Ce=n(52);Object.defineProperty(t,"freehandSculpter",{enumerable:!0,get:function(){return Ce.freehandSculpter}});var Pe=n(90);Object.defineProperty(t,"highlight",{enumerable:!0,get:function(){return Pe.highlight}}),Object.defineProperty(t,"highlightTouch",{enumerable:!0,get:function(){return Pe.highlightTouch}});var Ie=n(89);Object.defineProperty(t,"imageStats",{enumerable:!0,get:function(){return lt(Ie).default}});var Le=n(61);Object.defineProperty(t,"keyboardTool",{enumerable:!0,get:function(){return lt(Le).default}});var we=n(88);Object.defineProperty(t,"length",{enumerable:!0,get:function(){return we.length}}),Object.defineProperty(t,"lengthTouch",{enumerable:!0,get:function(){return we.lengthTouch}});var De=n(87);Object.defineProperty(t,"magnify",{enumerable:!0,get:function(){return De.magnify}}),Object.defineProperty(t,"magnifyTouchDrag",{enumerable:!0,get:function(){return De.magnifyTouchDrag}});var Ue=n(51);Object.defineProperty(t,"mouseButtonRectangleTool",{enumerable:!0,get:function(){return lt(Ue).default}});var Ae=n(10);Object.defineProperty(t,"mouseButtonTool",{enumerable:!0,get:function(){return lt(Ae).default}});var ke=n(29);Object.defineProperty(t,"mouseWheelTool",{enumerable:!0,get:function(){return lt(ke).default}});var Re=n(35);Object.defineProperty(t,"multiTouchDragTool",{enumerable:!0,get:function(){return lt(Re).default}});var He=n(86);Object.defineProperty(t,"orientationMarkers",{enumerable:!0,get:function(){return lt(He).default}});var Ne=n(85);Object.defineProperty(t,"pan",{enumerable:!0,get:function(){return Ne.pan}}),Object.defineProperty(t,"panTouchDrag",{enumerable:!0,get:function(){return Ne.panTouchDrag}});var je=n(84);Object.defineProperty(t,"panMultiTouch",{enumerable:!0,get:function(){return lt(je).default}});var Be=n(83);Object.defineProperty(t,"probe",{enumerable:!0,get:function(){return Be.probe}}),Object.defineProperty(t,"probeTouch",{enumerable:!0,get:function(){return Be.probeTouch}});var Ve=n(82);Object.defineProperty(t,"rectangleRoi",{enumerable:!0,get:function(){return Ve.rectangleRoi}}),Object.defineProperty(t,"rectangleRoiTouch",{enumerable:!0,get:function(){return Ve.rectangleRoiTouch}});var We=n(81);Object.defineProperty(t,"rotate",{enumerable:!0,get:function(){return We.rotate}}),Object.defineProperty(t,"rotateTouchDrag",{enumerable:!0,get:function(){return We.rotateTouchDrag}});var Ge=n(80);Object.defineProperty(t,"rotateTouch",{enumerable:!0,get:function(){return lt(Ge).default}});var Fe=n(79);Object.defineProperty(t,"saveAs",{enumerable:!0,get:function(){return lt(Fe).default}});var ze=n(78);Object.defineProperty(t,"scaleOverlayTool",{enumerable:!0,get:function(){return lt(ze).default}});var Ke=n(77);Object.defineProperty(t,"seedAnnotate",{enumerable:!0,get:function(){return Ke.seedAnnotate}}),Object.defineProperty(t,"seedAnnotateTouch",{enumerable:!0,get:function(){return Ke.seedAnnotateTouch}});var Ye=n(76);Object.defineProperty(t,"simpleAngle",{enumerable:!0,get:function(){return Ye.simpleAngle}}),Object.defineProperty(t,"simpleAngleTouch",{enumerable:!0,get:function(){return Ye.simpleAngleTouch}});var qe=n(14);Object.defineProperty(t,"simpleMouseButtonTool",{enumerable:!0,get:function(){return lt(qe).default}});var Xe=n(75);Object.defineProperty(t,"textMarker",{enumerable:!0,get:function(){return Xe.textMarker}}),Object.defineProperty(t,"textMarkerTouch",{enumerable:!0,get:function(){return Xe.textMarkerTouch}});var Je=n(18);Object.defineProperty(t,"touchDragTool",{enumerable:!0,get:function(){return lt(Je).default}});var Ze=n(50);Object.defineProperty(t,"touchPinchTool",{enumerable:!0,get:function(){return lt(Ze).default}});var Qe=n(12);Object.defineProperty(t,"touchTool",{enumerable:!0,get:function(){return lt(Qe).default}});var $e=n(74);Object.defineProperty(t,"wwwc",{enumerable:!0,get:function(){return $e.wwwc}}),Object.defineProperty(t,"wwwcTouchDrag",{enumerable:!0,get:function(){return $e.wwwcTouchDrag}});var et=n(73);Object.defineProperty(t,"wwwcRegion",{enumerable:!0,get:function(){return et.wwwcRegion}}),Object.defineProperty(t,"wwwcRegionTouch",{enumerable:!0,get:function(){return et.wwwcRegionTouch}});var tt=n(72);Object.defineProperty(t,"zoom",{enumerable:!0,get:function(){return tt.zoom}}),Object.defineProperty(t,"zoomWheel",{enumerable:!0,get:function(){return tt.zoomWheel}}),Object.defineProperty(t,"zoomTouchPinch",{enumerable:!0,get:function(){return tt.zoomTouchPinch}}),Object.defineProperty(t,"zoomTouchDrag",{enumerable:!0,get:function(){return tt.zoomTouchDrag}});var nt=n(71);Object.defineProperty(t,"brush",{enumerable:!0,get:function(){return nt.brush}});var at=n(70);Object.defineProperty(t,"adaptiveBrush",{enumerable:!0,get:function(){return at.adaptiveBrush}});var ot=n(69);Object.defineProperty(t,"version",{enumerable:!0,get:function(){return lt(ot).default}});var rt=n(4);Object.defineProperty(t,"setToolOptions",{enumerable:!0,get:function(){return rt.setToolOptions}}),Object.defineProperty(t,"getToolOptions",{enumerable:!0,get:function(){return rt.getToolOptions}});var it=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(3));function lt(e){return e&&e.__esModule?e:{default:e}}t.drawing=it},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.drawBrushOnCanvas=t.drawBrushPixels=void 0;var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(3);t.drawBrushPixels=function(e,t,n,a){e.forEach(function(e){var o,r=(o=e[0],e[1]*a+o);t[r]=n})},t.drawBrushOnCanvas=function(e,t,n,a){var o=r.default.cornerstone.pixelToCanvas(a,{x:0,y:0}),l=r.default.cornerstone.pixelToCanvas(a,{x:1,y:1}),d=l.x-o.x,u=l.y-o.y;(0,i.draw)(t,function(t){e.forEach(function(e){var o=r.default.cornerstone.pixelToCanvas(a,{x:e[0],y:e[1]}),l={left:o.x,top:o.y,width:d,height:u};(0,i.fillBox)(t,l,n)})})}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=Math.round(a),i=Math.round(o);if(1===e)return[[r,i]];for(var l=[],d=0,u=-e;u<=e;u++){var s=i+u;if(!(s>t||s<0))for(var c=-e;c<=e;c++){var f=r+c;f>n||f<0||c*c+u*u<e*e&&(l[d++]=[r+c,i+u])}}return l}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.toolType;function n(e){var t=e.detail,n=!1;n=function(e){var t=e.keyCode,n=!1;109===t||173===t?(m(),n=!0):61!==t&&107!==t||(g(),n=!0);return n}(t)||n,(n=function(e){var t=e.keyCode,n=!1;219===t?(p(),n=!0):221===t&&(h(),n=!0);return n}(t)||n)&&o.default.cornerstone.updateImage(t.element)}function s(e){var t=b.getConfiguration(),n=o.default.cornerstone.colors.getColormap(t.colormapId);t.draw=e;var a=n.getColor(t.draw);t.hoverColor="rgba("+a[[0]]+", "+a[[1]]+", "+a[[2]]+", 1.0 )",t.dragColor="rgba("+a[[0]]+", "+a[[1]]+", "+a[[2]]+", 0.8 )"}function g(){var e=b.getConfiguration();e.radius=(0,u.default)(e.radius+1,e.minRadius,e.maxRadius)}function m(){var e=b.getConfiguration();e.radius=(0,u.default)(e.radius-1,e.minRadius,e.maxRadius)}function h(){var e=b.getConfiguration(),t=E(),n=e.draw+1;n===t&&(n=0),s(n)}function p(){var e=b.getConfiguration(),t=E(),n=e.draw-1;n<0&&(n=t-1),s(n)}function E(){var e=b.getConfiguration(),t=o.default.cornerstone.colors.getColormap(e.colormapId);return t.getNumberOfColors()}function T(t){e.onMouseMove(t)}function y(t){var n=t.detail,o=n.element;e.onMouseUp(t),o.removeEventListener(a.default.MOUSE_DRAG,T),o.removeEventListener(a.default.MOUSE_DRAG,M),o.removeEventListener(a.default.MOUSE_UP,y),o.removeEventListener(a.default.MOUSE_CLICK,y)}function M(t){return e.onDrag(t),!1}function _(n){var o=n.detail,r=o.element,i=(0,d.getToolOptions)(t,r);if((0,l.default)(o.which,i.mouseButtonMask))return r.addEventListener(a.default.MOUSE_DRAG,M),r.addEventListener(a.default.MOUSE_UP,y),r.addEventListener(a.default.MOUSE_CLICK,y),e.onMouseDown(n),!1;r.addEventListener(a.default.MOUSE_DRAG,T),r.addEventListener(a.default.MOUSE_UP,y)}function x(t){var n=t.detail,a=n.element,i=(0,r.getToolState)(a,c),l=void 0;i?l=i.data[0].pixelData:(l=new Uint8ClampedArray(n.image.width*n.image.height),(0,r.addToolState)(a,c,{pixelData:l}));var d=o.default.cornerstone.getLayer(n.element,f);d.image.setPixelData(l),d.invalid=!0,o.default.cornerstone.updateImage(a),e.onImageRendered(t)}var b=(0,i.default)({mouseMoveCallback:T,mouseDownActivateCallback:_,onImageRendered:x,deactivate:function(e){e.removeEventListener(a.default.IMAGE_RENDERED,x),e.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,_),e.removeEventListener(a.default.MOUSE_MOVE,T),e.removeEventListener(a.default.KEY_DOWN,n),e.addEventListener(a.default.IMAGE_RENDERED,x),b.getConfiguration().active=!1}});return b.keyDownCallback=n,b.activate=function(e,i){(0,d.setToolOptions)(t,e,{mouseButtonMask:i}),e.removeEventListener(a.default.IMAGE_RENDERED,x),e.addEventListener(a.default.IMAGE_RENDERED,x),e.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,_),e.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,_),e.removeEventListener(a.default.MOUSE_MOVE,T),e.addEventListener(a.default.MOUSE_MOVE,T),e.removeEventListener(a.default.KEY_DOWN,n),e.addEventListener(a.default.KEY_DOWN,n);var l=o.default.cornerstone.getEnabledElement(e),u=l.image,s=u.width,g=u.height,m=new Uint8ClampedArray(s*g),h=b.getConfiguration();h.active=!0;var p=h.colormapId;if(!p){var E=b.getConfiguration();(function(e){var t=o.default.cornerstone.colors.getColormap(e);t.setNumberOfColors(20),t.setColor(0,[255,255,255,0]),t.setColor(1,[230,25,75,102]),t.setColor(2,[60,180,175,102]),t.setColor(3,[255,225,25,102]),t.setColor(4,[0,130,200,102]),t.setColor(5,[245,130,48,102]),t.setColor(6,[145,30,180,102]),t.setColor(7,[70,240,240,102]),t.setColor(8,[240,50,230,102]),t.setColor(9,[210,245,60,102]),t.setColor(10,[250,190,190,102]),t.setColor(11,[0,128,128,102]),t.setColor(12,[230,190,255,102]),t.setColor(13,[170,110,40,102]),t.setColor(14,[255,250,200,102]),t.setColor(15,[128,0,0,102]),t.setColor(16,[170,255,195,102]),t.setColor(17,[128,128,0,102]),t.setColor(18,[255,215,180,102]),t.setColor(19,[0,0,128,102])})(p="BrushColorMap"),E.colormapId=p}var y={minPixelValue:0,maxPixelValue:1,slope:1,intercept:0,getPixelData:function(){return m},rows:l.image.height,columns:l.image.width,height:g,width:s,pixelData:m,setPixelData:function(e){m=e},colormap:p,color:!1,rgba:!1,labelmap:!0,invert:!1,columnPixelSpacing:1,rowPixelSpacing:1,sizeInBytes:l.image.width*l.image.height},M=void 0;v||(v=o.default.cornerstone.addLayer(e,o.default.cornerstone.getEnabledElement(e).image)),f&&(M=o.default.cornerstone.getLayer(e,f)),M||(f=o.default.cornerstone.addLayer(e,y,{viewport:{pixelReplication:!0}})),(0,r.addToolState)(e,c,{pixelData:m}),h.brushLayerId=f,b.setConfiguration(h),o.default.cornerstone.updateImage(e)},b.changeDrawColor=s,b.increaseRadius=g,b.decreaseRadius=m,b.nextSegmentation=h,b.previousSegmentation=p,b};var a=s(n(1)),o=s(n(0)),r=n(2),i=s(n(10)),l=s(n(5)),d=n(4),u=s(n(8));function s(e){return e&&e.__esModule?e:{default:e}}var c="brush",f=void 0,v=void 0},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return{activate:function(t){t.removeEventListener(r.default.TOUCH_PINCH,e),t.addEventListener(r.default.TOUCH_PINCH,e)},disable:function(t){t.removeEventListener(r.default.TOUCH_PINCH,e)},enable:function(t){t.removeEventListener(r.default.TOUCH_PINCH,e)},deactivate:function(t){t.removeEventListener(r.default.TOUCH_PINCH,e)}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=e.toolType;function g(o){var r=o.detail,i=r.element,l=(0,v.getToolOptions)(n,i);if((0,c.default)(r.which,l.mouseButtonMask))return function(o){var r=o.element,i=e.createNewMeasurement(o);i&&((0,f.addToolState)(o.element,n,i),r.removeEventListener(a.default.MOUSE_MOVE,m),(0,d.default)(o,n,i,i.handles.end,function(){i.active=!1,(0,s.default)(o,i.handles)&&(0,f.removeToolState)(o.element,n,i),r.addEventListener(a.default.MOUSE_MOVE,m)},t))}(r),!1}function m(t){var a=t.detail;r.default.setCoords(a);var i=(0,f.getToolState)(a.element,n);if(void 0!==i){for(var d=!1,u=a.currentPoints.canvas,s=0;s<i.data.length;s++){var c=i.data[s];!0===(0,l.default)(a.element,c.handles,u)&&(d=!0),(e.pointInsideRect(a.element,c,u)&&!c.active||!e.pointInsideRect(a.element,c,u)&&c.active)&&(c.active=!c.active,d=!0)}!0===d&&o.default.cornerstone.updateImage(a.element)}}function h(r){var l=r.detail,g=l.element,h=o.default.cornerstone,p=void 0,E=(0,v.getToolOptions)(n,g);if((0,c.default)(l.which,E.mouseButtonMask)){var T=l.startPoints.canvas,y=(0,f.getToolState)(r.currentTarget,n),M=void 0;if(void 0!==y)for(M=0;M<y.data.length;M++){p=y.data[M];var _=(0,i.default)(l.element,p.handles,T,25);if(void 0!==_)return g.removeEventListener(a.default.MOUSE_MOVE,m),p.active=!0,(0,d.default)(l,n,p,_,b,t),r.stopImmediatePropagation(),!1}var x={deleteIfHandleOutsideImage:!0,preventHandleOutsideImage:t};if(void 0!==y&&void 0!==e.pointInsideRect)for(M=0;M<y.data.length;M++)if(p=y.data[M],e.pointInsideRect(l.element,p,T))return g.removeEventListener(a.default.MOUSE_MOVE,m),(0,u.default)(r,p,y,n,x,b),g.addEventListener(a.default.MOUSE_MOVE,m),r.stopImmediatePropagation(),!1}function b(){p.active=!1,(0,s.default)(l,p.handles)&&(0,f.removeToolState)(l.element,n,p),h.updateImage(l.element),g.addEventListener(a.default.MOUSE_MOVE,m)}}return{enable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,m),t.removeEventListener(a.default.MOUSE_DOWN,h),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,g),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),o.default.cornerstone.updateImage(t)},disable:function(t){t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,m),t.removeEventListener(a.default.MOUSE_DOWN,h),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,g),o.default.cornerstone.updateImage(t)},activate:function(t,r){(0,v.setToolOptions)(n,t,{mouseButtonMask:r}),t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,m),t.removeEventListener(a.default.MOUSE_DOWN,h),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,g),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.addEventListener(a.default.MOUSE_MOVE,m),t.addEventListener(a.default.MOUSE_DOWN,h),t.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,g),o.default.cornerstone.updateImage(t)},deactivate:function(t,r){(0,v.setToolOptions)(n,t,{mouseButtonMask:r}),t.removeEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.removeEventListener(a.default.MOUSE_MOVE,m),t.removeEventListener(a.default.MOUSE_DOWN,h),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,g),t.addEventListener(a.default.IMAGE_RENDERED,e.onImageRendered),t.addEventListener(a.default.MOUSE_MOVE,m),t.addEventListener(a.default.MOUSE_DOWN,h),o.default.cornerstone.updateImage(t)}}};var a=g(n(1)),o=g(n(0)),r=g(n(38)),i=g(n(25)),l=g(n(32)),d=g(n(31)),u=g(n(37)),s=g(n(16)),c=g(n(5)),f=n(2),v=n(4);function g(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.freehandSculpter=void 0;var a=g(n(1)),o=g(n(0)),r=n(23),i=g(n(7)),l=g(n(9)),d=g(n(5)),u=n(2),s=n(4),c=n(8),f=n(55),v=n(53);function g(e){return e&&e.__esModule?e:{default:e}}var m=new(n(91).Sculpter),h="freehandSculpter",p="freehand",E={mouseLocation:{handles:{start:{highlight:!0,active:!0}}},keyDown:{shift:!1,ctrl:!1,alt:!1},active:!1,minSpacing:5,maxSpacing:20,toolSizeImage:null,toolSizeCanvas:null,currentTool:null,color:i.default.getActiveColor()};function T(e){var t=e.detail,n=t.element,r=(0,s.getToolOptions)(h,n),i=P.getConfiguration(),l=!1;if(!(0,d.default)(t.which,r.mouseButtonMask))return e.stopPropagation(),void e.preventDefault();t.event.ctrlKey?(!function(e){var t=P.getConfiguration(),n=e.element,a=new v.FreehandLineFinder(e).findTool();t.currentTool=a,function(e,t){for(var n=(0,u.getToolState)(e,p),a=0;a<n.data.length;a++)n.data[a].active=a===t}(n,a)}(t),l=!0):null!==i.currentTool&&(!function(e){var t=P.getConfiguration(),n=e.element;(function(e){for(var t=P.getConfiguration(),n=t.currentTool,a=(0,u.getToolState)(e.element,p).data[n].handles,r=e.currentPoints.image,i=e.currentPoints.canvas,l=1/0,d=1/0,s=0;s<a.length;s++){var c=a[s],f=o.default.cornerstoneMath.point.distance(c,r);if(f<l){l=f;var v=o.default.cornerstone.pixelToCanvas(e.element,a[s]);d=o.default.cornerstoneMath.point.distance(v,i)}}t.toolSizeImage=l,t.toolSizeCanvas=d})(e),t.active=!0,b(e),n.addEventListener(a.default.MOUSE_UP,M),n.addEventListener(a.default.MOUSE_CLICK,M),n.addEventListener(a.default.MOUSE_DRAG,y)}(t),l=!0),l&&o.default.cornerstone.updateImage(t.element)}function y(e){var t=e.detail,n=(0,u.getToolState)(t.element,p);if(n){var a=P.getConfiguration(),r=n.data[a.currentTool].handles;b(t),m.sculpt(t,r),o.default.cornerstone.updateImage(t.element)}}function M(e){var t=e.detail,n=t.element,r=P.getConfiguration();n.removeEventListener(a.default.MOUSE_UP,M),n.removeEventListener(a.default.MOUSE_DRAG,y),n.removeEventListener(a.default.MOUSE_CLICK,M),r.active=!1,e.preventDefault(),e.stopPropagation(),function(e){var t=P.getConfiguration(),n=e.element;(0,u.getToolState)(n,p).data[t.currentTool].invalidated=!0,o.default.cornerstone.updateImage(n)}(t)}function _(e){x(e.detail.element)}function x(e){var t=P.getConfiguration(),n=(0,u.getToolState)(e,p);if(t.currentTool=null,n)for(var a=0;a<n.data.length;a++)n.data[a].active=!1;o.default.cornerstone.updateImage(e)}function b(e){var t=P.getConfiguration();t.mouseLocation.handles.start.x=e.currentPoints.image.x,t.mouseLocation.handles.start.y=e.currentPoints.image.y,(0,c.clipToBox)(t.mouseLocation.handles.start,e.image)}function S(e){var t=e.detail,n=t.canvasContext.canvas.getContext("2d"),a=P.getConfiguration();if(a.active){var o={fill:null,handleRadius:a.toolSizeCanvas};(0,l.default)(n,t,a.mouseLocation.handles,a.color,o)}}function O(e){x(e),C(e)}function C(e){e.removeEventListener(a.default.IMAGE_RENDERED,S),e.removeEventListener(a.default.MOUSE_DOWN,T),e.removeEventListener(a.default.MOUSE_DRAG,y),e.removeEventListener(a.default.MOUSE_UP,M),e.removeEventListener(a.default.KEY_DOWN,f.keyDownCallback),e.removeEventListener(a.default.KEY_UP,f.keyUpCallback),e.removeEventListener(a.default.NEW_IMAGE,_)}var P={enable:function(e){O(e)},disable:O,activate:function(e,t){(0,s.setToolOptions)(h,e,{mouseButtonMask:t}),r.freehand.enable(e),C(e),e.addEventListener(a.default.IMAGE_RENDERED,S),e.addEventListener(a.default.MOUSE_DOWN,T),e.addEventListener(a.default.KEY_DOWN,f.keyDownCallback),e.addEventListener(a.default.KEY_UP,f.keyUpCallback),e.addEventListener(a.default.NEW_IMAGE,_),e.focus(),o.default.cornerstone.updateImage(e)},deactivate:function(e){O(e)},getConfiguration:function(){return E},setConfiguration:function(e){E=e}};t.freehandSculpter=P},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FreehandLineFinder=void 0;var a,o=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),r=n(2),i=n(0),l=(a=i)&&a.__esModule?a:{default:a},d=n(95);t.FreehandLineFinder=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._eventData=t}return o(e,[{key:"findLine",value:function(){var e=this.findTool();if(null===e)return null;var t=this._getCloseLinesInTool(e);return t?this._findCorrectLine(e,t):null}},{key:"findTool",value:function(){return this._toolData=(0,r.getToolState)(this._eventData.element,"freehand"),this._mousePoint=this._eventData.currentPoints.canvas,this._toolData?this._nearestHandleToPointAllTools().toolIndex:null}},{key:"_nearestHandleToPointAllTools",value:function(){for(var e=this._toolData,t={toolIndex:null,handleIndex:null,distance:1/0},n=0;n<e.data.length;n++){var a=this._nearestHandleToPoint(n);null!==a&&(a.distance<t.distance&&(t=a))}return t}},{key:"_nearestHandleToPoint",value:function(e){var t=this._eventData,n=this._toolData.data[e];if(void 0===n.handles)return null;if(!1===n.visible)return null;for(var a={toolIndex:e,handleIndex:null,distance:1/0},o=0;o<n.handles.length;o++){var r=l.default.cornerstone.pixelToCanvas(t.element,n.handles[o]),i=l.default.cornerstoneMath.point.distance(r,this._mousePoint);i<a.distance&&(a.handleIndex=o,a.distance=i)}return a}},{key:"_getCloseLinesInTool",value:function(t){for(var n=this._toolData.data[t].handles,a=[],o=0;o<n.length;o++){var r=e.getNextHandleIndex(o,n.length);this._distanceOfPointfromLine(n[o],n[r])<10&&a.push([o,r])}return a}},{key:"_findCorrectLine",value:function(e,t){for(var n=0;n<t.length;n++)if(this._pointProjectsToLineSegment(e,t[n]))return new d.ClickedLineData(e,t[n]);return null}},{key:"_pointProjectsToLineSegment",value:function(t,n){var a=this._eventData,o=this._toolData.data[t];if(void 0!==o.handles){if(!1===o.visible)return!1;var r=o.handles[n[0]],i=o.handles[n[1]],l=e.getCanvasPointsFromHandles(r,i,a.element),d=e.getLineAsVector(l),u=this._getLineOriginToMouseAsVector(l),s=(u[0]*d[0]+u[1]*d[1])/d.magnitude;return s>0&&s<d.magnitude}}},{key:"_getLineOriginToMouseAsVector",value:function(e){return[this._mousePoint.x-e[0].x,this._mousePoint.y-e[0].y]}},{key:"_distanceOfPointfromLine",value:function(e,t){var n=this._eventData,a=l.default.cornerstone.pixelToCanvas(n.element,e),o=l.default.cornerstone.pixelToCanvas(n.element,t),r=this._mousePoint;return Math.abs((o.y-a.y)*r.x-(o.x-a.x)*r.y+o.x*a.y-o.y*a.x)/l.default.cornerstoneMath.point.distance(a,o)}}],[{key:"getCanvasPointsFromHandles",value:function(e,t,n){var a=[];return e.x<t.x?(a.push(l.default.cornerstone.pixelToCanvas(n,e)),a.push(l.default.cornerstone.pixelToCanvas(n,t))):(a.push(l.default.cornerstone.pixelToCanvas(n,t)),a.push(l.default.cornerstone.pixelToCanvas(n,e))),a}},{key:"getLineAsVector",value:function(e){var t=[e[1].x-e[0].x,e[1].y-e[0].y];return t.magnitude=l.default.cornerstoneMath.point.distance(e[0],e[1]),t}},{key:"getNextHandleIndex",value:function(e,t){return e<t-1?e+1:0}}]),e}()},function(e,t,n){"use strict";function a(e,t,n,a){for(var i=e.length-1,l=0;l<e.length;l++)if(-1===a.indexOf(l)&&-1===a.indexOf(i)){if(o(t,n,r(e[i]),r(e[l])))return!0;i=l}else i=l;return!1}function o(e,t,n,a){var o=!1,r=[i(e,t,n),i(e,t,a),i(n,a,e),i(n,a,t)];return r[0]!==r[1]&&r[2]!==r[3]||(0===r[0]&&l(e,n,t)?o=!0:0===r[1]&&l(e,a,t)?o=!0:0===r[2]&&l(n,e,a)?o=!0:0===r[3]&&l(n,t,a)&&(o=!0),o)}function r(e){return{x:e.x,y:e.y}}function i(e,t,n){var a=(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y);return 0===a?0:a>0?1:2}function l(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}Object.defineProperty(t,"__esModule",{value:!0});var d={newHandle:function(e,t){var n=t.length-1;return a(t,r(t[n]),r(e),[n])},end:function(e){var t=e.length-1;return a(e,r(e[t]),r(e[0]),[t,0])},modify:function(e,t){var n=r(e[t]),o=t-1;0===t&&(o=e.length-1);var i=r(e[o]);return!!a(e,n,i,[t,o])||a(e,n,i=r(e[o=t===e.length-1?0:t+1]),[t,o])}};t.default=d},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.keyDownCallback=function(e){var t=e.detail,n=i.freehand.getConfiguration(),a=t.keyCode,o=!1;a===l.CTRL&&(n.keyDown.ctrl=!0,o=!0);a===l.SHIFT&&(n.keyDown.shift=!0);a===l.ALT&&(n.keyDown.alt=!0);o&&r.default.cornerstone.updateImage(t.element)},t.keyUpCallback=function(e){var t=e.detail,n=i.freehand.getConfiguration(),a=t.keyCode,o=!1;a===l.CTRL&&(n.keyDown.ctrl=!1,o=!0);a===l.SHIFT&&(n.keyDown.shift=!1);a===l.ALT&&(n.keyDown.alt=!1);o&&r.default.cornerstone.updateImage(t.element)};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(23);var l={SHIFT:16,CTRL:17,ALT:18}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(!t)throw new Error("simpleTouchTool: toolType is required");var n={};return{activate:function(n){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,i.setToolOptions)(t,n,a),n.removeEventListener(r.default.TOUCH_START,e),n.addEventListener(r.default.TOUCH_START,e)},disable:function(t){t.removeEventListener(r.default.TOUCH_START,e)},enable:function(t){t.removeEventListener(r.default.TOUCH_START,e)},deactivate:function(t){t.removeEventListener(r.default.TOUCH_START,e)},getConfiguration:function(){return n},setConfiguration:function(e){n=e}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a},i=n(4)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return{activate:function(t){t.removeEventListener(r.default.DOUBLE_TAP,e),t.addEventListener(r.default.DOUBLE_TAP,e)},disable:function(t){t.removeEventListener(r.default.DOUBLE_TAP,e)},enable:function(t){t.removeEventListener(r.default.DOUBLE_TAP,e)},deactivate:function(t){t.removeEventListener(r.default.DOUBLE_TAP,e)}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=2e3,o={mouse:0,touch:1},r=void 0,i=void 0;function l(e,t){var n=Date.now();if(e!==r){if(n-i<=a)return t.preventDefault(),t.stopPropagation(),t.stopImmediatePropagation(),!1;r=e}i=n}var d=l.bind(null,o.mouse),u=l.bind(null,o.touch);function s(e,t,n){var a=n?d:u;t.forEach(function(t){e.addEventListener(t,a)})}function c(e,t,n){var a=n?d:u;t.forEach(function(t){e.removeEventListener(t,a)})}var f=["mousedown","mouseup"],v=["touchstart","touchend"];function g(e){c(e,f,o.mouse),c(e,v,o.touch)}var m={enable:function(e){g(e),s(e,f,o.mouse),s(e,v,o.touch)},disable:g};t.default=m},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,i,u){l.value=!0;var s=e.detail,c=o.default.cornerstone,f=s.element,v=c.getEnabledElement(f),g=((new Date).getTime(),-57),m={x:s.currentPoints.page.x,y:s.currentPoints.page.y+g},h=c.pageToPixel(f,m.x,m.y);function p(e){var o=e.detail;l.value=!1,!1===i.hasMoved&&(i.hasMoved=!0),i.active=!0;var d=o.currentPoints,u={x:d.page.x,y:d.page.y+g};h=c.pageToPixel(f,u.x,u.y),i.x=h.x,i.y=h.y,c.updateImage(f);var s=a.default.MEASUREMENT_MODIFIED,v={toolType:t,element:f,measurementData:n};(0,r.default)(f,s,v)}function E(e){var t=e.detail;l.value=!1,i.active=!1,f.removeEventListener(a.default.TOUCH_DRAG,p),d.forEach(function(e){f.removeEventListener(e,E)}),c.updateImage(f),e.type===a.default.TOUCH_PRESS&&(t.handlePressed=n,i.x=s.currentPoints.image.x,i.y=s.currentPoints.image.y),"function"==typeof u&&u(e)}f.addEventListener(a.default.TOUCH_DRAG,p),d.forEach(function(e){f.addEventListener(e,E)}),function e(t,n,a,r,i){if(!a.value)return;var l=o.default.cornerstone;var d=(new Date).getTime();var u=Math.abs(n.y-i.y);var s=u/10;if(u<1)return n.y=i.y,void(a.value=!1);n.y>i.y?n.y-=s:n.y<i.y&&(n.y+=s);l.updateImage(r.element);l.requestAnimationFrame(function(){e(d,n,a,r,i)})}(0,i,l,v,h)};var a=i(n(1)),o=i(n(0)),r=i(n(6));function i(e){return e&&e.__esModule?e:{default:e}}var l={value:!1},d=[a.default.TOUCH_END,a.default.TOUCH_DRAG_END,a.default.TOUCH_PINCH,a.default.TOUCH_PRESS,a.default.TAP]},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,d,u,s){var c=e.detail.element,f=o.default.cornerstone;function v(e){var n=e.detail;t.active=!0,Object.keys(t.handles).forEach(function(e){var a=t.handles[e];!0!==a.movesIndependently&&(a.x+=n.deltaPoints.image.x,a.y+=n.deltaPoints.image.y)}),f.updateImage(c);var o=a.default.MEASUREMENT_MODIFIED,r={toolType:d,element:c,measurementData:t};(0,l.default)(c,o,r),e.preventDefault(),e.stopPropagation()}function g(e){var n=e.detail;t.active=!1,t.invalidated=!1,c.removeEventListener(a.default.TOUCH_DRAG,v),c.removeEventListener(a.default.TOUCH_PINCH,g),c.removeEventListener(a.default.TOUCH_PRESS,g),c.removeEventListener(a.default.TOUCH_END,g),c.removeEventListener(a.default.TOUCH_DRAG_END,g),c.removeEventListener(a.default.TAP,g);var o=(0,r.default)(n,t.handles);!0===u&&!0===o&&(0,i.removeToolState)(c,d,t),f.updateImage(c),"function"==typeof s&&s(e)}return c.addEventListener(a.default.TOUCH_DRAG,v),c.addEventListener(a.default.TOUCH_PINCH,g),c.addEventListener(a.default.TOUCH_PRESS,g),c.addEventListener(a.default.TOUCH_END,g),c.addEventListener(a.default.TOUCH_DRAG_END,g),c.addEventListener(a.default.TAP,g),!0};var a=d(n(1)),o=d(n(0)),r=d(n(16)),i=n(2),l=d(n(6));function d(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t={};return{activate:function(t){t.removeEventListener(r.default.KEY_DOWN,e),t.addEventListener(r.default.KEY_DOWN,e)},disable:function(t){t.removeEventListener(r.default.KEY_DOWN,e)},enable:function(t){t.removeEventListener(r.default.KEY_DOWN,e)},deactivate:function(t){t.removeEventListener(r.default.KEY_DOWN,e)},getConfiguration:function(){return t},setConfiguration:function(e){t=e}}};var a,o=n(1),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){for(var n=0,a=0,o=0,i=0,l=t.top;l<t.top+t.height;l++)for(var d=t.left;d<t.left+t.width;d++){var u={x:d,y:l};(0,r.default)(t,u)&&(n+=e[i],a+=e[i]*e[i],o++),i++}if(0===o)return{count:o,mean:0,variance:0,stdDev:0};var s=n/o,c=a/o-s*s;return{count:o,mean:s,variance:c,stdDev:Math.sqrt(c)}};var a,o=n(41),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,o,r){var i=Math.atan2(n.y-t.y,n.x-t.x),l={color:o,lineWidth:r};(0,a.drawLine)(e,void 0,t,n,l,"canvas"),l={color:o,lineWidth:r,fillStyle:o};var d=[{x:n.x-10*Math.cos(i-Math.PI/7),y:n.y-10*Math.sin(i-Math.PI/7)},{x:n.x-10*Math.cos(i+Math.PI/7),y:n.y-10*Math.sin(i+Math.PI/7)},n];(0,a.drawJoinedLines)(e,void 0,n,d,l,"canvas")};var a=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a,o){if(!e)throw new Error("getLuminance: parameter element must not be undefined");t=Math.round(t),n=Math.round(n);var i=r.default.cornerstone.getEnabledElement(e).image,l=[],d=0,u=i.getPixelData(),s=void 0,c=void 0,f=void 0;if(i.color)for(c=0;c<o;c++)for(f=0;f<a;f++){var v=u[s=4*((c+n)*i.columns+(f+t))],g=u[s+1],m=u[s+2];l[d++]=.2126*v+.7152*g+.0722*m}else for(c=0;c<o;c++)for(f=0;f<a;f++)s=(c+n)*i.columns+(f+t),l[d++]=u[s]*i.slope+i.intercept;return l};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=(0,r.getToolState)(e,"stack");if(n&&n.data&&n.data.length){var u=o.default.cornerstone,s=void 0;if(n.data.length>1){var c=(0,r.getToolState)(e,"stackRenderer");c&&c.data&&c.data.length&&(s=c.data[0])}var f=n.data[0];t<0&&(t+=f.imageIds.length);var v=l.default.getStartLoadHandler(),g=l.default.getEndLoadHandler(),m=l.default.getErrorLoadingHandler();if(t!==f.currentImageIdIndex){v&&v(e);var h={newImageIdIndex:t,direction:t-f.currentImageIdIndex};f.currentImageIdIndex=t;var p=f.imageIds[t];(Boolean(f.preventCache)?u.loadImage(p):u.loadAndCacheImage(p)).then(function(a){if(f.currentImageIdIndex===t){try{u.getEnabledElement(e)}catch(e){return}s?(s.currentImageIdIndex=t,s.render(e,n.data)):u.displayImage(e,a),g&&g(e,a)}},function(n){var a=f.imageIds[t];m&&m(e,a,n)}),i.default.startGrabbing(),(0,d.default)(e,a.default.STACK_SCROLL,h)}}};var a=u(n(1)),o=u(n(0)),r=n(2),i=u(n(44)),l=u(n(13)),d=u(n(6));function u(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(n(140)),o=r(n(139));function r(e){return e&&e.__esModule?e:{default:e}}var i={getOrientationString:a.default,invertOrientationString:o.default};t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,d){var u=a.default.cornerstone,s=u.getEnabledElement(n).image,c=u.getEnabledElement(d).image;if(s&&c){var f=u.metaData.get("imagePlaneModule",s.imageId),v=u.metaData.get("imagePlaneModule",c.imageId);if(f&&v&&f.rowCosines&&f.columnCosines&&f.imagePositionPatient&&v.rowCosines&&v.columnCosines&&v.imagePositionPatient&&f.frameOfReferenceUID===v.frameOfReferenceUID){f.rowCosines=(0,i.default)(f.rowCosines),f.columnCosines=(0,i.default)(f.columnCosines),f.imagePositionPatient=(0,i.default)(f.imagePositionPatient),v.rowCosines=(0,i.default)(v.rowCosines),v.columnCosines=(0,i.default)(v.columnCosines),v.imagePositionPatient=(0,i.default)(v.imagePositionPatient);var g=f.rowCosines.clone().cross(f.columnCosines),m=v.rowCosines.clone().cross(v.columnCosines),h=g.angleTo(m);if(!((h=Math.abs(h))<.5)){var p=(0,o.default)(f,v);if(p){var E=r.default.getActiveColor();e.setTransform(1,0,0,1,0,0),(0,l.draw)(e,function(e){(0,l.drawLine)(e,t.element,p.start,p.end,{color:E})})}}}}};var a=d(n(0)),o=d(n(68)),r=d(n(7)),i=d(n(19)),l=n(3);function d(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=(0,a.planePlaneIntersection)(e,t);if(n)return{start:(0,a.projectPatientPointToImagePlane)(n.start,e),end:(0,a.projectPatientPointToImagePlane)(n.end,e)}};var a=n(45)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default="2.3.9"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.adaptiveBrush=void 0;var a=d(n(0)),o=n(2),r=d(n(49)),i=d(n(48)),l=n(47);function d(e){return e&&e.__esModule?e:{default:e}}var u="brush",s={draw:1,radius:5,tolerance:5,minRadius:1,maxRadius:20,hoverColor:"rgba(230, 25, 75, 1.0)",dragColor:"rgba(230, 25, 75, 0.8)",active:!1},c=void 0,f=void 0,v=void 0,g=void 0,m=void 0;function h(e){var t=E.getConfiguration(),n=e.element,r=a.default.cornerstone.getLayer(n,t.brushLayerId),d=a.default.cornerstone.getLayers(n)[0],s=r.image,m=s.rows,h=s.columns,p=(0,o.getToolState)(n,u).data[0];g=function(e,t,n,a){for(var o=E.getConfiguration(),r=o.draw,d=Math.round(c.x),u=Math.round(c.y),s=null,g=[],m=o.radius;0!==s&&m>o.minRadius;){s=0,g=(0,i.default)(m,n,a,d,u);for(var h=0;h<g.length;h++){var p=g[h][0],T=e[g[h][1]*a+p];if(T>f||T<v){s++;break}}m--}return 0===s&&(0,l.drawBrushPixels)(g,t,r,a),m}(d.image.getPixelData(),p.pixelData,m,h),r.invalid=!0,a.default.cornerstone.updateImage(n)}function p(e){var t=E.getConfiguration(),n=e.element,r=a.default.cornerstone.getLayer(n,t.brushLayerId),d=r.image,s=d.rows,c=d.columns,f=e.currentPoints.image,v=f.x,g=f.y,m=(0,o.getToolState)(n,u).data[0].pixelData,h=t.draw,p=t.radius;if(!(v<0||v>c||g<0||g>s)){var T=(0,i.default)(p,s,c,v,g);(0,l.drawBrushPixels)(T,m,h,c),r.invalid=!0,a.default.cornerstone.updateImage(n)}}var E=(0,r.default)({onMouseMove:function(e){var t=e.detail;c=t.currentPoints.image,a.default.cornerstone.updateImage(t.element)},onMouseDown:function(e){var t=e.detail,n=t.element,o=E.getConfiguration(),r=a.default.cornerstone.getLayer(n,o.brushLayerId),l=a.default.cornerstone.getLayers(n)[0],d=t.currentPoints.image,u=d.x,s=d.y,g=r.image,T=g.rows,y=g.columns,M=(0,i.default)(o.radius,T,y,u,s);0===o.draw?p(t):(function(e,t,n){var a=E.getConfiguration().tolerance,o=Number.MAX_VALUE,r=-Number.MAX_VALUE;e.forEach(function(e){var a=e[1]*n+e[0],i=t[a];o=Math.min(i,o),r=Math.max(i,r)}),v=o-a,f=r+a}(M,l.image.getPixelData(),y),h(t)),m=!0,c=t.currentPoints.image},onMouseUp:function(e){var t=e.detail;c=t.currentPoints.image;var n=E.getConfiguration();m=!1,g=n.radius,a.default.cornerstone.updateImage(t.element)},onDrag:function(e){var t=e.detail;0===s.draw?p(t):h(t),m=!0,c=t.currentPoints.image},toolType:"adaptiveBrush",onImageRendered:function(e){var t=e.detail;if(c){var n=t.image,a=n.rows,o=n.columns,r=c,d=r.x,u=r.y;if(!(d<0||d>o||u<0||u>a)){var s=E.getConfiguration(),f=t.canvasContext,v=m?s.dragColor:s.hoverColor,h=t.element;if(g=m&&g||s.radius,f.setTransform(1,0,0,1,0,0),s.active){var p=(0,i.default)(g,a,o,d,u);(0,l.drawBrushOnCanvas)(p,f,v,h)}}}}});E.setConfiguration(s),t.adaptiveBrush=E},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.brush=void 0;var a=d(n(0)),o=n(2),r=d(n(49)),i=d(n(48)),l=n(47);function d(e){return e&&e.__esModule?e:{default:e}}var u="brush",s=void 0,c=!1;function f(e){var t=v.getConfiguration(),n=e.element,r=a.default.cornerstone.getLayer(n,t.brushLayerId),d=r.image,s=d.rows,c=d.columns,f=e.currentPoints.image,g=f.x,m=f.y,h=(0,o.getToolState)(n,u).data[0].pixelData,p=t.draw,E=t.radius;if(!(g<0||g>c||m<0||m>s)){var T=(0,i.default)(E,s,c,g,m);(0,l.drawBrushPixels)(T,h,p,c),r.invalid=!0,a.default.cornerstone.updateImage(n)}}var v=(0,r.default)({onMouseMove:function(e){var t=e.detail;s=t.currentPoints.image,a.default.cornerstone.updateImage(t.element)},onMouseDown:function(e){var t=e.detail;f(t),c=!0,s=t.currentPoints.image},onMouseUp:function(e){var t=e.detail;s=t.currentPoints.image,c=!1},onDrag:function(e){var t=e.detail;f(t),c=!0,s=t.currentPoints.image},toolType:"brush",onImageRendered:function(e){var t=e.detail;if(s){var n=t.image,a=n.rows,o=n.columns,r=s,d=r.x,u=r.y;if(!(d<0||d>o||u<0||u>a)){var f=v.getConfiguration(),g=f.radius,m=t.canvasContext,h=c?f.dragColor:f.hoverColor,p=t.element;if(m.setTransform(1,0,0,1,0,0),f.active){var E=(0,i.default)(g,a,o,d,u);(0,l.drawBrushOnCanvas)(E,m,h,p)}}}}});v.setConfiguration({draw:1,radius:5,minRadius:1,maxRadius:20,hoverColor:"rgba(230, 25, 75, 1.0)",dragColor:"rgba(230, 25, 75, 0.8)",active:!1}),t.brush=v},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.zoomTouchDrag=t.zoomTouchPinch=t.zoomWheel=t.zoom=void 0;var a=f(n(1)),o=f(n(0)),r=f(n(14)),i=f(n(5)),l=f(n(29)),d=f(n(50)),u=f(n(18)),s=n(4),c=n(8);function f(e){return e&&e.__esModule?e:{default:e}}var v="zoom",g=void 0;function m(e,t){var n=y.getConfiguration(),a=Math.log(e.scale)/Math.log(1.7)+t,o=Math.pow(1.7,a);return n.maxScale&&o>n.maxScale?e.scale=n.maxScale:n.minScale&&o<n.minScale?e.scale=n.minScale:e.scale=o,e}function h(e,t){if(t.hflip&&(e.x*=-1),t.vflip&&(e.y*=-1),0!==t.rotation){var n=t.rotation*Math.PI/180,a=Math.cos(n),o=Math.sin(n),r=e.x*a-e.y*o,i=e.x*o+e.y*a;e.x=r,e.y=i}return e}function p(e,t){var n=o.default.cornerstone,a=e.element,r=m(e.viewport,t);n.setViewport(a,r);var i=n.pageToPixel(a,e.startPoints.page.x,e.startPoints.page.y),l={x:e.startPoints.image.x-i.x,y:e.startPoints.image.y-i.y};l=h(l,r),r.translation.x-=l.x,r.translation.y-=l.y,n.setViewport(a,r)}function E(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,T),t.removeEventListener(a.default.MOUSE_UP,E),t.removeEventListener(a.default.MOUSE_CLICK,E)}function T(e){var t=e.detail;if(!t.deltaPoints.page.y)return!1;var n=t.deltaPoints.page.y/100,a=y.getConfiguration();a&&a.invert&&(n*=-1),y.strategy(t,n),e.preventDefault(),e.stopPropagation()}var y=(0,r.default)(function(e){var t=e.detail,n=t.element,o=(0,s.getToolOptions)(v,n);(0,i.default)(t.which,o.mouseButtonMask)&&(g=t.startPoints,n.addEventListener(a.default.MOUSE_DRAG,T),n.addEventListener(a.default.MOUSE_UP,E),n.addEventListener(a.default.MOUSE_CLICK,E),e.preventDefault(),e.stopPropagation())},v);y.strategies={default:p,translate:function(e,t){var n=e.element,a=e.image,r=y.getConfiguration(),i=m(e.viewport,t),l={x:0,y:0};if(t<0)i.scale<3&&(Math.abs(i.translation.x)<.01?i.translation.x=0:l.x=i.translation.x/8,Math.abs(i.translation.y)<.01?i.translation.y=0:l.y=i.translation.y/8);else{r&&r.preventZoomOutsideImage&&(0,c.clipToBox)(g.image,a);var d={x:a.width/2-g.image.x,y:a.height/2-g.image.y};d=h(d,i);var u={x:i.translation.x-d.x,y:i.translation.y-d.y};Math.abs(u.x)<.01?i.translation.x=d.x:l.x=u.x/8,Math.abs(u.y)<.01?i.translation.y=d.y:l.y=u.y/8}i.translation.x-=l.x,i.translation.y-=l.y,o.default.cornerstone.setViewport(n,i)},zoomToCenter:function(e,t){var n=e.element,a=m(e.viewport,t);o.default.cornerstone.setViewport(n,a)}},y.strategy=p;var M=(0,l.default)(function(e){var t=e.detail,n=-t.direction/4,a=y.getConfiguration();a&&a.invert&&(n*=-1);var r=m(t.viewport,n);o.default.cornerstone.setViewport(t.element,r)}),_=(0,d.default)(function(e){var t=e.detail,n=o.default.cornerstone,a=y.getConfiguration(),r=t.viewport,i=t.element;r.scale+=t.scaleChange*r.scale,a.maxScale&&r.scale>a.maxScale?r.scale=a.maxScale:a.minScale&&r.scale<a.minScale&&(r.scale=a.minScale),n.setViewport(i,r);var l=n.pageToPixel(i,t.startPoints.page.x,t.startPoints.page.y),d={x:t.startPoints.image.x-l.x,y:t.startPoints.image.y-l.y};d=h(d,r),r.translation.x-=d.x,r.translation.y-=d.y,n.setViewport(i,r)}),x=(0,u.default)(T,v);t.zoom=y,t.zoomWheel=M,t.zoomTouchPinch=_,t.zoomTouchDrag=x},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.wwwcRegionTouch=t.wwwcRegion=void 0;var a=f(n(1)),o=f(n(0)),r=f(n(7)),i=n(2),l=f(n(64)),d=f(n(5)),u=n(4),s=f(n(8)),c=n(3);function f(e){return e&&e.__esModule?e:{default:e}}var v="wwwcRegion",g={minWindowWidth:10};function m(e){var t=e.detail.element,n=(0,i.getToolState)(t,v);n&&n.data&&(n.data=[]),t.removeEventListener(a.default.MOUSE_MOVE,M),t.removeEventListener(a.default.MOUSE_DRAG,M),t.removeEventListener(a.default.MOUSE_UP,h),t.removeEventListener(a.default.MOUSE_CLICK,h),t.addEventListener(a.default.MOUSE_DOWN,T)}function h(e){var t=e.detail,n=t.element;n.removeEventListener(a.default.MOUSE_MOVE,M),n.removeEventListener(a.default.MOUSE_DRAG,M),n.removeEventListener(a.default.MOUSE_UP,h),n.removeEventListener(a.default.MOUSE_CLICK,h),n.addEventListener(a.default.MOUSE_DOWN,T);var o=(0,i.getToolState)(t.element,v);o&&o.data&&o.data.length&&(o.data[0].endPoint={x:t.currentPoints.image.x,y:t.currentPoints.image.y},p(t))}function p(e){var t=o.default.cornerstone,n=(0,i.getToolState)(e.element,v);if(n&&n.data&&n.data.length){var a=n.data[0].startPoint,r=n.data[0].endPoint,d=Math.abs(a.x-r.x),u=Math.abs(a.y-r.y),c=Math.min(a.x,r.x),f=Math.min(a.y,r.y);c=(0,s.default)(c,0,e.image.width),f=(0,s.default)(f,0,e.image.height),d=Math.floor(Math.min(d,Math.abs(e.image.width-c))),u=Math.floor(Math.min(u,Math.abs(e.image.height-f)));var g=function(e,t,n){var a=e.length;if(a<2)return{min:t,max:n,mean:(t+n)/2};for(var o=n,r=t,i=0,l=0;l<a;l++){var d=e[l];o=Math.min(o,d),r=Math.max(r,d),i+=d}return{min:o,max:r,mean:i/a}}((0,l.default)(e.element,c,f,d,u),e.image.minPixelValue,e.image.maxPixelValue),m=S.getConfiguration(),h=t.getViewport(e.element);void 0===m.minWindowWidth&&(m.minWindowWidth=10),h.voi.windowWidth=Math.max(Math.abs(g.max-g.min),m.minWindowWidth),h.voi.windowCenter=g.mean,t.setViewport(e.element,h),n.data=[],t.updateImage(e.element)}}function E(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_MOVE,E),t.removeEventListener(a.default.MOUSE_DRAG,E),t.addEventListener(a.default.MOUSE_MOVE,M),t.addEventListener(a.default.MOUSE_DRAG,M),t.addEventListener(a.default.MOUSE_CLICK,h),e.type===a.default.MOUSE_DRAG&&t.addEventListener(a.default.MOUSE_UP,h)}function T(e){var t=e.detail,n=t.element,o=(0,u.getToolOptions)(v,n);if((0,d.default)(t.which,o.mouseButtonMask))return n.addEventListener(a.default.MOUSE_DRAG,E),n.addEventListener(a.default.MOUSE_MOVE,E),n.removeEventListener(a.default.MOUSE_DOWN,T),y(t),!1}function y(e){var t=(0,i.getToolState)(e.element,v);t&&t.data&&(t.data=[]);var n={startPoint:{x:e.currentPoints.image.x,y:e.currentPoints.image.y}};(0,i.addToolState)(e.element,v,n)}function M(e){var t=e.detail,n=t.element,a=(0,i.getToolState)(n,v);a&&a.data&&a.data.length&&(a.data[0].endPoint={x:t.currentPoints.image.x,y:t.currentPoints.image.y},o.default.cornerstone.updateImage(n))}function _(e){var t=e.detail,n=t.element,a=t.canvasContext,o=(0,i.getToolState)(t.element,v);if(o&&o.data&&o.data.length){var l=o.data[0].startPoint,d=o.data[0].endPoint;if(l&&d){a.setTransform(1,0,0,1,0,0);var u=r.default.getActiveColor(),s=S.getConfiguration();(0,c.draw)(a,function(e){(0,c.setShadow)(e,s),(0,c.drawRect)(e,n,l,d,{color:u})})}}}function x(e){e.removeEventListener(a.default.MOUSE_DOWN,T),e.removeEventListener(a.default.MOUSE_UP,h),e.removeEventListener(a.default.MOUSE_CLICK,h),e.removeEventListener(a.default.MOUSE_DRAG,M),e.removeEventListener(a.default.MOUSE_MOVE,M),e.removeEventListener(a.default.IMAGE_RENDERED,_),e.removeEventListener(a.default.NEW_IMAGE,m),o.default.cornerstone.updateImage(e)}function b(e){e.removeEventListener(a.default.TOUCH_DRAG,M),e.removeEventListener(a.default.TOUCH_START,y),e.removeEventListener(a.default.TOUCH_DRAG_END,p),e.removeEventListener(a.default.IMAGE_RENDERED,_)}var S={activate:function(e,t){(0,u.setToolOptions)(v,e,{mouseButtonMask:t}),(0,i.getToolState)(e,v)||(0,i.addToolState)(e,v,[]);e.removeEventListener(a.default.MOUSE_DOWN,T),e.removeEventListener(a.default.MOUSE_UP,h),e.removeEventListener(a.default.MOUSE_CLICK,h),e.removeEventListener(a.default.MOUSE_DRAG,M),e.removeEventListener(a.default.MOUSE_MOVE,M),e.removeEventListener(a.default.IMAGE_RENDERED,_),e.removeEventListener(a.default.NEW_IMAGE,m),e.addEventListener(a.default.MOUSE_DOWN,T),e.addEventListener(a.default.IMAGE_RENDERED,_),e.addEventListener(a.default.NEW_IMAGE,m),o.default.cornerstone.updateImage(e)},deactivate:x,disable:x,setConfiguration:function(e){g=e},getConfiguration:function(){return g}},O={activate:function(e){(0,i.getToolState)(e,v)||(0,i.addToolState)(e,v,[]);e.removeEventListener(a.default.TOUCH_DRAG,M),e.removeEventListener(a.default.TOUCH_START,y),e.removeEventListener(a.default.TOUCH_DRAG_END,p),e.removeEventListener(a.default.IMAGE_RENDERED,_),e.addEventListener(a.default.TOUCH_DRAG,M),e.addEventListener(a.default.TOUCH_START,y),e.addEventListener(a.default.TOUCH_DRAG_END,p),e.addEventListener(a.default.IMAGE_RENDERED,_)},deactivate:b,disable:b};t.wwwcRegion=S,t.wwwcRegionTouch=O},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.wwwcTouchDrag=t.wwwc=void 0;var a=u(n(1)),o=u(n(0)),r=u(n(14)),i=u(n(18)),l=u(n(5)),d=n(4);function u(e){return e&&e.__esModule?e:{default:e}}var s="wwwc";function c(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,v),t.removeEventListener(a.default.MOUSE_UP,c),t.removeEventListener(a.default.MOUSE_CLICK,c)}function f(e){var t=(e.image.maxPixelValue*e.image.slope+e.image.intercept-(e.image.minPixelValue*e.image.slope+e.image.intercept))/1024,n=e.deltaPoints.page.x*t,a=e.deltaPoints.page.y*t;e.viewport.voi.windowWidth+=n,e.viewport.voi.windowCenter+=a}function v(e){var t=e.detail;g.strategy(t),o.default.cornerstone.setViewport(t.element,t.viewport)}var g=(0,r.default)(function(e){var t=e.detail,n=t.element,o=(0,d.getToolOptions)(s,n);(0,l.default)(t.which,o.mouseButtonMask)&&(n.addEventListener(a.default.MOUSE_DRAG,v),n.addEventListener(a.default.MOUSE_UP,c),n.addEventListener(a.default.MOUSE_CLICK,c),e.preventDefault(),e.stopPropagation())},s);g.strategies={default:f},g.strategy=f;var m=(0,i.default)(function(e){var t=e.detail;e.stopImmediatePropagation();var n=t,a=(n.image.maxPixelValue*n.image.slope+n.image.intercept-(n.image.minPixelValue*n.image.slope+n.image.intercept))/1024,r=n.deltaPoints.page.x*a,i=n.deltaPoints.page.y*a,l=g.getConfiguration();l.orientation?0===l.orientation?(n.viewport.voi.windowWidth+=r,n.viewport.voi.windowCenter+=i):(n.viewport.voi.windowWidth+=i,n.viewport.voi.windowCenter+=r):(n.viewport.voi.windowWidth+=r,n.viewport.voi.windowCenter+=i),o.default.cornerstone.setViewport(n.element,n.viewport)});t.wwwc=g,t.wwwcTouchDrag=m},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.textMarkerTouch=t.textMarker=void 0;var a=m(n(1)),o=m(n(0)),r=m(n(10)),i=m(n(12)),l=m(n(22)),d=m(n(7)),u=m(n(5)),s=n(11),c=m(s),f=n(2),v=n(4),g=n(3);function m(e){return e&&e.__esModule?e:{default:e}}var h="textMarker";function p(e){var t=y.getConfiguration();if(t.current){var n={visible:!0,active:!0,text:t.current,color:void 0,handles:{end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0,hasBoundingBox:!0}}},a={left:0,top:0,width:e.image.width,height:e.image.height};if(o.default.cornerstoneMath.point.insideRect(n.handles.end,a)){var r=t.markers.indexOf(t.current);return t.ascending?(r+=1)>=t.markers.length&&(t.loop?r-=t.markers.length:r=-1):(r-=1)<0&&(t.loop?r+=t.markers.length:r=-1),t.current=t.markers[r],n}}}function E(e,t,n){if(!1===t.visible)return!1;if(t.handles.end.boundingBox){var a=o.default.cornerstoneMath.rect.distanceToPoint(t.handles.end.boundingBox,n),r=(0,l.default)(t.handles.end,n);return a<10||r}}function T(e){var t=e.detail,n=(0,f.getToolState)(t.element,h);if(n)for(var a=(0,g.getNewContext)(t.canvasContext.canvas),r=y.getConfiguration(),i=function(e){var i=n.data[e];if(!1===i.visible)return"continue";var l=d.default.getColorIfActive(i);(0,g.draw)(a,function(e){(0,g.setShadow)(e,r);i.textWidth=(0,s.textBoxWidth)(e,i.text,5);var n=o.default.cornerstone.pixelToCanvas(t.element,i.handles.end);i.handles.end.boundingBox=(0,c.default)(e,i.text,n.x,n.y-10,l,{centering:{x:!0,y:!0}})})},l=0;l<n.data.length;l++)i(l)}var y=(0,r.default)({createNewMeasurement:p,onImageRendered:T,pointNearTool:E,toolType:h,mouseDoubleClickCallback:function(e){var t=e.detail,n=o.default.cornerstone,r=t.element,i=void 0,l=(0,v.getToolOptions)(h,r);if((0,u.default)(t.which,l.mouseButtonMask)){var d=y.getConfiguration(),s=t.currentPoints.canvas,c=(0,f.getToolState)(r,h);if(c){for(var g=0;g<c.data.length;g++)if(E(0,i=c.data[g],s))return i.active=!0,n.updateImage(r),r.removeEventListener(a.default.MOUSE_MOVE,y.mouseMoveCallback),r.removeEventListener(a.default.MOUSE_DOWN,y.mouseDownCallback),r.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,y.mouseDownActivateCallback),r.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,y.mouseDoubleClickCallback),d.changeTextCallback(i,t,m),e.stopImmediatePropagation(),e.preventDefault(),void e.stopPropagation();e.preventDefault(),e.stopPropagation()}}function m(e,t,o){!0===o?(0,f.removeToolState)(r,h,e):e.text=t,e.active=!1,n.updateImage(r),r.addEventListener(a.default.MOUSE_MOVE,y.mouseMoveCallback),r.addEventListener(a.default.MOUSE_DOWN,y.mouseDownCallback),r.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,y.mouseDownActivateCallback),r.addEventListener(a.default.MOUSE_DOUBLE_CLICK,y.mouseDoubleClickCallback)}}}),M=(0,i.default)({createNewMeasurement:p,onImageRendered:T,pointNearTool:E,toolType:h,pressCallback:function(e){var t=e.detail,n=o.default.cornerstone,r=t.element,i=void 0;function l(e,t,o){!0===o?(0,f.removeToolState)(r,h,e):e.text=t,e.active=!1,n.updateImage(r),r.addEventListener(a.default.TOUCH_DRAG,M.touchMoveCallback),r.addEventListener(a.default.TOUCH_START_ACTIVE,M.touchDownActivateCallback),r.addEventListener(a.default.TOUCH_START,M.touchStartCallback),r.addEventListener(a.default.TAP,M.tapCallback),r.addEventListener(a.default.TOUCH_PRESS,M.pressCallback)}var d=y.getConfiguration(),u=t.currentPoints.canvas,s=(0,f.getToolState)(r,h);if(!s)return!1;if(t.handlePressed)return t.handlePressed.active=!0,n.updateImage(r),r.removeEventListener(a.default.TOUCH_DRAG,M.touchMoveCallback),r.removeEventListener(a.default.TOUCH_START_ACTIVE,M.touchDownActivateCallback),r.removeEventListener(a.default.TOUCH_START,M.touchStartCallback),r.removeEventListener(a.default.TAP,M.tapCallback),r.removeEventListener(a.default.TOUCH_PRESS,M.pressCallback),d.changeTextCallback(t.handlePressed,t,l),e.stopImmediatePropagation(),e.preventDefault(),void e.stopPropagation();for(var c=0;c<s.data.length;c++)if(E(0,i=s.data[c],u))return i.active=!0,n.updateImage(r),r.removeEventListener(a.default.TOUCH_DRAG,M.touchMoveCallback),r.removeEventListener(a.default.TOUCH_START_ACTIVE,M.touchDownActivateCallback),r.removeEventListener(a.default.TOUCH_START,M.touchStartCallback),r.removeEventListener(a.default.TAP,M.tapCallback),r.removeEventListener(a.default.TOUCH_PRESS,M.pressCallback),d.changeTextCallback(i,t,l),e.stopImmediatePropagation(),e.preventDefault(),void e.stopPropagation();e.preventDefault(),e.stopPropagation()}});t.textMarker=y,t.textMarkerTouch=M},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.simpleAngleTouch=t.simpleAngle=void 0;var a=T(n(1)),o=T(n(0)),r=T(n(10)),i=T(n(42)),l=T(n(17)),d=T(n(15)),u=T(n(7)),s=T(n(16)),c=T(n(30)),f=T(n(28)),v=T(n(9)),g=T(n(12)),m=T(n(27)),h=n(2),p=n(3),E=n(11);function T(e){return e&&e.__esModule?e:{default:e}}var y="simpleAngle";function M(e){return{visible:!0,active:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},middle:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function _(e,t,n){return!1!==t.visible&&((0,m.default)(e,t.handles.start,t.handles.middle,n)<25||(0,m.default)(e,t.handles.middle,t.handles.end,n)<25)}function x(e){return Math.sqrt(Math.pow(e.x,2)+Math.pow(e.y,2))}function b(e){var t=e.detail,n=(0,h.getToolState)(e.currentTarget,y);if(n)for(var a=o.default.cornerstone,r=t.enabledElement,s=(0,p.getNewContext)(t.canvasContext.canvas),c=d.default.getToolWidth(),f=S.getConfiguration(),g=function(e){var o=n.data[e];if(!1===o.visible)return"continue";(0,p.draw)(s,function(e){(0,p.setShadow)(e,f);var n=u.default.getColorIfActive(o),d=a.pixelToCanvas(t.element,o.handles.start),s=a.pixelToCanvas(t.element,o.handles.middle);(0,p.drawJoinedLines)(e,t.element,o.handles.start,[o.handles.middle,o.handles.end],{color:n});var g={drawHandlesIfActive:f&&f.drawHandlesOnHover};(0,v.default)(e,t,o.handles,n,g);var m=t.image.columnPixelSpacing||1,h=t.image.rowPixelSpacing||1,y={x:(Math.ceil(o.handles.middle.x)-Math.ceil(o.handles.start.x))*m,y:(Math.ceil(o.handles.middle.y)-Math.ceil(o.handles.start.y))*h},M={x:(Math.ceil(o.handles.end.x)-Math.ceil(o.handles.middle.x))*m,y:(Math.ceil(o.handles.end.y)-Math.ceil(o.handles.middle.y))*h},_={x:(Math.ceil(o.handles.end.x)-Math.ceil(o.handles.start.x))*m,y:(Math.ceil(o.handles.end.y)-Math.ceil(o.handles.start.y))*h},b=x(y),S=x(M),O=x(_),C=Math.acos((Math.pow(b,2)+Math.pow(S,2)-Math.pow(O,2))/(2*b*S));if(C*=180/Math.PI,o.rAngle=(0,i.default)(C,2),o.rAngle){var P=function(e,t,n){var a=t&&n?"":" (isotropic)";return e.rAngle.toString()+String.fromCharCode(parseInt("00B0",16))+a}(o,t.image.rowPixelSpacing,t.image.columnPixelSpacing),I=void 0;if(!o.handles.textBox.hasMoved){I={x:s.x,y:s.y};var L=(0,E.textBoxWidth)(e,P,5);s.x<d.x?I.x-=15+L:I.x+=15;var w=a.internal.getTransform(r);w.invert();var D=w.transformPoint(I.x,I.y);o.handles.textBox.x=D.x,o.handles.textBox.y=D.y}(0,l.default)(e,t.element,o.handles.textBox,P,o.handles,T,n,c,0,!0)}})},m=0;m<n.data.length;m++)g(m);function T(e){return[e.start,e.middle,e.end]}}var S=(0,r.default)({createNewMeasurement:M,addNewMeasurement:function(e){var t=o.default.cornerstone,n=M(e),r=e.element;(0,h.addToolState)(r,y,n),r.removeEventListener(a.default.MOUSE_MOVE,S.mouseMoveCallback),r.removeEventListener(a.default.MOUSE_DRAG,S.mouseMoveCallback),r.removeEventListener(a.default.MOUSE_DOWN,S.mouseDownCallback),r.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,S.mouseDownActivateCallback),t.updateImage(r),(0,c.default)(e,y,n,n.handles.middle,function(){if(n.active=!1,(0,s.default)(e,n.handles))return(0,h.removeToolState)(r,y,n),r.addEventListener(a.default.MOUSE_MOVE,S.mouseMoveCallback),r.addEventListener(a.default.MOUSE_DRAG,S.mouseMoveCallback),r.addEventListener(a.default.MOUSE_DOWN,S.mouseDownCallback),r.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,S.mouseDownActivateCallback),void t.updateImage(r);n.handles.end.active=!0,t.updateImage(r),(0,c.default)(e,y,n,n.handles.end,function(){n.active=!1,(0,s.default)(e,n.handles)&&(0,h.removeToolState)(r,y,n),r.addEventListener(a.default.MOUSE_MOVE,S.mouseMoveCallback),r.addEventListener(a.default.MOUSE_DRAG,S.mouseMoveCallback),r.addEventListener(a.default.MOUSE_DOWN,S.mouseDownCallback),r.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,S.mouseDownActivateCallback),t.updateImage(r)})})},onImageRendered:b,pointNearTool:_,toolType:y}),O=(0,g.default)({createNewMeasurement:M,addNewMeasurement:function(e){var t=o.default.cornerstone,n=M(e),r=e.element;(0,h.addToolState)(r,y,n),r.removeEventListener(a.default.TOUCH_DRAG,O.touchMoveCallback),r.removeEventListener(a.default.TOUCH_START_ACTIVE,O.touchDownActivateCallback),r.removeEventListener(a.default.TOUCH_START,O.touchStartCallback),r.removeEventListener(a.default.TAP,O.tapCallback),t.updateImage(r),(0,f.default)(e,y,n,n.handles.middle,function(){if((0,s.default)(e,n.handles))return(0,h.removeToolState)(r,y,n),r.addEventListener(a.default.TOUCH_DRAG,O.touchMoveCallback),r.addEventListener(a.default.TOUCH_START,O.touchStartCallback),r.addEventListener(a.default.TOUCH_START_ACTIVE,O.touchDownActivateCallback),r.addEventListener(a.default.TAP,O.tapCallback),void t.updateImage(r);(0,f.default)(e,y,n,n.handles.end,function(){(0,s.default)(e,n.handles)&&((0,h.removeToolState)(r,y,n),t.updateImage(r)),r.addEventListener(a.default.TOUCH_DRAG,O.touchMoveCallback),r.addEventListener(a.default.TOUCH_START,O.touchStartCallback),r.addEventListener(a.default.TOUCH_START_ACTIVE,O.touchDownActivateCallback),r.addEventListener(a.default.TAP,O.tapCallback)})})},onImageRendered:b,pointNearTool:_,toolType:y});t.simpleAngle=S,t.simpleAngleTouch=O},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.seedAnnotateTouch=t.seedAnnotate=void 0;var a=y(n(1)),o=y(n(0)),r=y(n(10)),i=y(n(12)),l=y(n(21)),d=y(n(15)),u=y(n(7)),s=y(n(16)),c=y(n(31)),f=y(n(9)),v=y(n(5)),g=y(n(22)),m=y(n(17)),h=n(2),p=n(4),E=n(3),T=n(11);function y(e){return e&&e.__esModule?e:{default:e}}var M="seedAnnotate";var _={getTextCallback:function(e){e(prompt("Enter your annotation:"))},changeTextCallback:function(e,t,n){n(prompt("Change your annotation:"))},drawHandles:!1,drawHandlesOnHover:!0,currentLetter:"A",currentNumber:0,showCoordinates:!0,countUp:!0};function x(e){return{visible:!0,active:!0,color:void 0,handles:{end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function b(e,t,n){if(!1===t.visible)return!1;if(t.handles.end){var a=o.default.cornerstone.pixelToCanvas(e,t.handles.end);return o.default.cornerstoneMath.point.distance(a,n)<25}}function S(e){var t=e.detail,n=(0,h.getToolState)(e.currentTarget,M);if(n)for(var a=o.default.cornerstone,r=t.enabledElement,i=(0,E.getNewContext)(t.canvasContext.canvas),s=t.canvasContext.canvas.width,c=d.default.getToolWidth(),v=O.getConfiguration(),g=function(e){var o=n.data[e];if(!1===o.visible)return"continue";(0,E.draw)(i,function(e){(0,E.setShadow)(e,v);var n=u.default.getColorIfActive(o),i=a.pixelToCanvas(t.element,o.handles.end);(0,E.drawCircle)(e,t.element,o.handles.end,6,{color:n});var d={drawHandlesIfActive:v&&v.drawHandlesOnHover};if(v.drawHandles&&(0,f.default)(e,t,i,n,d),o.text&&""!==o.text){var g=function(e){var t="";t=v.showCoordinates?e.text+" x: "+Math.round(e.handles.end.x)+" y: "+Math.round(e.handles.end.y):e.text;return t}(o),h=(0,T.textBoxWidth)(e,g,5),p=l.default.getFontSize()+10,M=Math.max(h,p)/2+5;i.x>s/2&&(M=-M);var _=void 0;if(!o.handles.textBox.hasMoved){_={x:i.x-h/2+M,y:i.y-p/2};var x=a.internal.getTransform(r);x.invert();var b=x.transformPoint(_.x,_.y);o.handles.textBox.x=b.x,o.handles.textBox.y=b.y}(0,m.default)(e,t.element,o.handles.textBox,g,o.handles,y,n,c,0,!1)}})},p=0;p<n.data.length;p++)g(p);function y(e){return[e.end]}}var O=(0,r.default)({addNewMeasurement:function(e){var t=o.default.cornerstone,n=e.element,a=O.getConfiguration(),r=x(e);function i(e){null===e?(0,h.removeToolState)(n,M,r):r.text=e,r.active=!1,t.updateImage(n)}(0,h.addToolState)(n,M,r),t.updateImage(n),(0,c.default)(e,M,r,r.handles.end,function(){(0,s.default)(e,r.handles)&&(0,h.removeToolState)(n,M,r),void 0===r.text&&a.getTextCallback(i),t.updateImage(n)})},createNewMeasurement:x,onImageRendered:S,pointNearTool:b,toolType:M,mouseDoubleClickCallback:function(e){var t=e.detail,n=o.default.cornerstone,a=t.element,r=void 0,i=(0,p.getToolOptions)(M,a);if((0,v.default)(t.which,i.mouseButtonMask)){var l=O.getConfiguration(),d=t.currentPoints.canvas,u=(0,h.getToolState)(a,M);if(u){for(var s=0;s<u.data.length;s++)if(r=u.data[s],b(a,r,d)||(0,g.default)(r.handles.textBox,d))return r.active=!0,n.updateImage(a),l.changeTextCallback(r,t,c),e.stopImmediatePropagation(),!1;e.preventDefault(),e.stopPropagation()}}function c(e,t,o){!0===o?(0,h.removeToolState)(a,M,e):e.text=t,e.active=!1,n.updateImage(a)}}});O.setConfiguration(_);var C=(0,i.default)({addNewMeasurement:function(e){var t=o.default.cornerstone,n=e.element,a=O.getConfiguration(),r=x(e);function i(e){null===e?(0,h.removeToolState)(n,M,r):r.text=e,r.active=!1,t.updateImage(n)}(0,h.addToolState)(n,M,r),t.updateImage(n),(0,c.default)(e,M,r,r.handles.end,function(){(0,s.default)(e,r.handles)&&(0,h.removeToolState)(n,M,r),void 0===r.text&&a.getTextCallback(i),t.updateImage(n)})},createNewMeasurement:x,onImageRendered:S,pointNearTool:b,toolType:M,pressCallback:function(e){var t=e.detail,n=o.default.cornerstone,r=t.element,i=void 0;function l(e,t,o){console.log("pressCallback doneChangingTextCallback"),!0===o?(0,h.removeToolState)(r,M,e):e.text=t,e.active=!1,n.updateImage(r),r.addEventListener(a.default.TOUCH_START,C.touchStartCallback),r.addEventListener(a.default.TOUCH_START_ACTIVE,C.touchDownActivateCallback),r.addEventListener(a.default.TAP,C.tapCallback)}var d=O.getConfiguration(),u=t.currentPoints.canvas,s=(0,h.getToolState)(r,M);if(!s)return!1;if(t.handlePressed)return r.removeEventListener(a.default.TOUCH_START,C.touchStartCallback),r.removeEventListener(a.default.TOUCH_START_ACTIVE,C.touchDownActivateCallback),r.removeEventListener(a.default.TAP,C.tapCallback),d.changeTextCallback(t.handlePressed,t,l),e.stopImmediatePropagation(),!1;for(var c=0;c<s.data.length;c++)if(i=s.data[c],b(r,i,u)||(0,g.default)(i.handles.textBox,u))return i.active=!0,n.updateImage(r),r.removeEventListener(a.default.TOUCH_START,C.touchStartCallback),r.removeEventListener(a.default.TOUCH_START_ACTIVE,C.touchDownActivateCallback),r.removeEventListener(a.default.TAP,C.tapCallback),d.changeTextCallback(i,t,l),e.stopImmediatePropagation(),!1;e.preventDefault(),e.stopPropagation()}});t.seedAnnotate=O,t.seedAnnotateTouch=C},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=l(n(24)),o=l(n(1)),r=l(n(0)),i=n(3);function l(e){return e&&e.__esModule?e:{default:e}}function d(e,t,n,a,o){var r={left:0,top:0,width:t.width,height:t.height},i=a*Math.min(1e3,t.width),l=o*Math.min(1e3,t.height);return{topLeft:{x:(r={left:r.left+i,top:r.top+l,width:r.width-2*i,height:r.height-2*l}).left,y:r.top},bottomRight:{x:r.left+r.width,y:r.top+r.height}}}function u(e){var t=e.detail,n=(0,i.getNewContext)(t.canvasContext.canvas),a=t.image,o=t.viewport,l=r.default.cornerstone.metaData.get("imagePlaneModule",a.imageId),u=void 0,c=void 0;if(l?(u=l.rowPixelSpacing||l.rowImagePixelSpacing,c=l.columnPixelSpacing||l.colImagePixelSpacing):(u=a.rowPixelSpacing,c=a.columnPixelSpacing),u&&c){var f={width:n.canvas.width,height:n.canvas.height},v={width:a.width,height:a.height},g=10/u*o.scale,m=10/c*o.scale,h=d(0,f,0,.25,.05),p=d(0,f,0,.05,.15);if(f.width&&f.height&&v.width&&v.height&&h&&p){var E=s.getConfiguration(),T=Object.assign({},{hscaleBounds:h,vscaleBounds:p,verticalMinorTick:g,horizontalMinorTick:m,minorTickLength:12.5,majorTickLength:25,verticalLine:{start:{x:p.bottomRight.x,y:p.topLeft.y},end:{x:p.bottomRight.x,y:p.bottomRight.y}},horizontalLine:{start:{x:h.topLeft.x,y:h.bottomRight.y},end:{x:h.bottomRight.x,y:h.bottomRight.y}}},E),y={color:T.color,lineWidth:T.lineWidth},M=function(e){for(var t=0,n=[];e.verticalLine.start.y+t*e.verticalMinorTick<=e.vscaleBounds.bottomRight.y;){var a={x:e.verticalLine.start.x,y:e.verticalLine.start.y+t*e.verticalMinorTick},o={x:0,y:e.verticalLine.start.y+t*e.verticalMinorTick};o.x=t%5==0?e.verticalLine.start.x-e.majorTickLength:e.verticalLine.start.x-e.minorTickLength,n.push({start:a,end:o}),t++}return n}(T),_=function(e){for(var t=0,n=[];e.horizontalLine.start.x+t*e.horizontalMinorTick<=e.hscaleBounds.bottomRight.x;){var a={x:e.horizontalLine.start.x+t*e.horizontalMinorTick,y:e.horizontalLine.start.y},o={x:e.horizontalLine.start.x+t*e.horizontalMinorTick,y:0};o.y=t%5==0?e.horizontalLine.start.y-e.majorTickLength:e.horizontalLine.start.y-e.minorTickLength,n.push({start:a,end:o}),t++}return n}(T);(0,i.draw)(n,function(e){e.shadowColor=T.shadowColor,e.shadowBlur=T.shadowBlur,(0,i.drawLine)(e,void 0,T.verticalLine.start,T.verticalLine.end,y,"canvas"),(0,i.drawLine)(e,void 0,T.horizontalLine.start,T.horizontalLine.end,y,"canvas"),(0,i.drawLines)(e,void 0,M,y,"canvas"),(0,i.drawLines)(e,void 0,_,y,"canvas")})}}}var s=(0,a.default)(u);s.setConfiguration({color:"white",lineWidth:2,shadowColor:"black",shadowBlur:4}),s.disable=function(e){e.removeEventListener(o.default.IMAGE_RENDERED,u),r.default.cornerstone.updateImage(e)},t.default=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"image/png",a=e.querySelector("canvas");if(a.msToBlob){var o=a.msToBlob();return window.navigator.msSaveBlob(o,t)}var r=document.createElement("a");if(r.download=t,r.href=a.toDataURL(n,1),document.createEvent){var i=document.createEvent("MouseEvents");i.initMouseEvent("click",!0,!0,window,0,0,0,0,0,!1,!1,!1,!1,0,null),r.dispatchEvent(i)}else r.fireEvent&&r.fireEvent("onclick")}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(n(1)),o=r(n(0));function r(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=e.detail;return t.viewport.rotation+=t.rotation,o.default.cornerstone.setViewport(t.element,t.viewport),!1}var l={activate:function(e){e.removeEventListener(a.default.TOUCH_ROTATE,i),e.addEventListener(a.default.TOUCH_ROTATE,i)},disable:function(e){e.removeEventListener(a.default.TOUCH_ROTATE,i)}};t.default=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.rotateTouchDrag=t.rotate=void 0;var a=u(n(1)),o=u(n(0)),r=u(n(14)),i=u(n(56)),l=u(n(5)),d=n(4);function u(e){return e&&e.__esModule?e:{default:e}}var s="rotate";function c(e,t,n){var a=e.element.getBoundingClientRect(e.element),r=e.element.clientWidth,i=e.element.clientHeight,l=e.viewport.scale,d=e.viewport.translation,u={x:a.left+r/2+d.x*l,y:a.top+i/2+d.y*l},s=t,c={x:e.currentPoints.client.x,y:e.currentPoints.client.y},f=Math.sqrt(Math.pow(u.x-s.x,2)+Math.pow(u.y-s.y,2)),v=Math.sqrt(Math.pow(u.x-c.x,2)+Math.pow(u.y-c.y,2)),g=Math.sqrt(Math.pow(s.x-c.x,2)+Math.pow(s.y-c.y,2)),m=180*Math.acos((Math.pow(f,2)+Math.pow(v,2)-Math.pow(g,2))/(2*f*v))/Math.PI;(s.x-u.x)*(c.y-u.y)-(s.y-u.y)*(c.x-u.x)<0&&(m=-m),e.viewport.rotation=n+m,o.default.cornerstone.setViewport(e.element,e.viewport)}function f(e,t,n){var a=n.detail;v.strategy(a,e,t),o.default.cornerstone.setViewport(a.element,a.viewport),n.preventDefault(),n.stopPropagation()}var v=(0,r.default)(function(e){var t=e.detail,n=t.element,o=(0,d.getToolOptions)(s,n),r={x:t.currentPoints.client.x,y:t.currentPoints.client.y},i=t.viewport.rotation;if((0,l.default)(t.which,o.mouseButtonMask)){var u=f.bind({},r,i),c=function e(t){var n=t.detail.element;n.removeEventListener(a.default.MOUSE_DRAG,u),n.removeEventListener(a.default.MOUSE_UP,e),n.removeEventListener(a.default.MOUSE_CLICK,e)};n.addEventListener(a.default.MOUSE_DRAG,u),n.addEventListener(a.default.MOUSE_UP,c),n.addEventListener(a.default.MOUSE_CLICK,c),e.preventDefault(),e.stopPropagation()}},s);v.strategies={default:c,horizontal:function(e){e.viewport.rotation+=e.deltaPoints.page.x/e.viewport.scale,o.default.cornerstone.setViewport(e.element,e.viewport)},vertical:function(e){e.viewport.rotation+=e.deltaPoints.page.y/e.viewport.scale,o.default.cornerstone.setViewport(e.element,e.viewport)}},v.strategy=c;var g=(0,i.default)(function(e){var t=e.detail,n=t.element,o={x:t.currentPoints.client.x,y:t.currentPoints.client.y},r=t.viewport.rotation,i=f.bind({},o,r);n.addEventListener(a.default.TOUCH_DRAG,i),n.addEventListener(a.default.TOUCH_END,function e(t){var n=t.detail.element;n.removeEventListener(a.default.TOUCH_DRAG,i),n.removeEventListener(a.default.TOUCH_END,e)}),e.preventDefault(),e.stopPropagation()},s);t.rotate=v,t.rotateTouchDrag=g},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.rectangleRoiTouch=t.rectangleRoi=void 0;var a=v(n(0)),o=v(n(10)),r=v(n(12)),i=v(n(15)),l=v(n(7)),d=v(n(9)),u=v(n(20)),s=n(2),c=v(n(17)),f=n(3);function v(e){return e&&e.__esModule?e:{default:e}}var g="rectangleRoi";function m(e){return{visible:!0,active:!0,invalidated:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function h(e,t,n){if(!1===t.visible)return!1;var o=a.default.cornerstone,r=o.pixelToCanvas(e,t.handles.start),i=o.pixelToCanvas(e,t.handles.end),l={left:Math.min(r.x,i.x),top:Math.min(r.y,i.y),width:Math.abs(r.x-i.x),height:Math.abs(r.y-i.y)};return a.default.cornerstoneMath.rect.distanceToPoint(l,n)<5}function p(e){var t=e.toString().split(".");return t[0]=t[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),t.join(".")}function E(e){var t=e.detail,n=(0,s.getToolState)(e.currentTarget,g);if(n){var o=a.default.cornerstone,r=t.image,v=t.element,m=i.default.getToolWidth(),h=T.getConfiguration(),E=o.metaData.get("generalSeriesModule",r.imageId),y=o.metaData.get("imagePlaneModule",r.imageId),M=void 0,_=void 0,x=void 0;y?(_=y.rowPixelSpacing||y.rowImagePixelSpacing,x=y.columnPixelSpacing||y.colImagePixelSpacing):(_=r.rowPixelSpacing,x=r.columnPixelSpacing),E&&(M=E.modality);for(var b=(0,f.getNewContext)(t.canvasContext.canvas),S=function(e){var a=n.data[e];if(!1===a.visible)return"continue";(0,f.draw)(b,function(e){(0,f.setShadow)(e,h);var n=l.default.getColorIfActive(a);if((0,f.drawRect)(e,v,a.handles.start,a.handles.end,{color:n}),h&&h.drawHandlesOnHover)if(!0===a.active)(0,d.default)(e,t,a.handles,n);else{(0,d.default)(e,t,a.handles,n,{drawHandlesIfActive:!0})}else(0,d.default)(e,t,a.handles,n);var i=void 0,s=void 0,g=void 0;if(!1===a.invalidated)s=a.meanStdDev,g=a.meanStdDevSUV,i=a.area;else{var E={left:Math.min(a.handles.start.x,a.handles.end.x),top:Math.min(a.handles.start.y,a.handles.end.y),width:Math.abs(a.handles.start.x-a.handles.end.x),height:Math.abs(a.handles.start.y-a.handles.end.y)};if(!r.color)s=function(e,t){for(var n=0,a=0,o=0,r=0,i=t.top;i<t.top+t.height;i++)for(var l=t.left;l<t.left+t.width;l++)n+=e[r],a+=e[r]*e[r],o++,r++;if(0===o)return{count:o,mean:0,variance:0,stdDev:0};var d=n/o,u=a/o-d*d;return{count:o,mean:d,variance:u,stdDev:Math.sqrt(u)}}(o.getPixels(v,E.left,E.top,E.width,E.height),E),"PT"===M&&(g={mean:(0,u.default)(r,(s.mean-r.intercept)/r.slope),stdDev:(0,u.default)(r,(s.stdDev-r.intercept)/r.slope)}),s&&!isNaN(s.mean)&&(a.meanStdDev=s,a.meanStdDevSUV=g);i=E.width*(x||1)*(E.height*(_||1)),isNaN(i)||(a.area=i),a.invalidated=!1}var T=function(e){var t=e.meanStdDev,n=e.meanStdDevSUV,a=e.area,o=[];if(t&&t.mean){var r="";"CT"===M&&(r=" HU");var i="Mean: "+p(t.mean.toFixed(2))+r,l="StdDev: "+p(t.stdDev.toFixed(2))+r;if(n&&void 0!==n.mean){i+=" SUV: "+p(n.mean.toFixed(2)),l+=" SUV: "+p(n.stdDev.toFixed(2))}o.push(i),o.push(l)}if(a){var d=" mm"+String.fromCharCode(178);_&&x||(d=" pixels"+String.fromCharCode(178));var u="Area: "+p(a.toFixed(2))+d;o.push(u)}return o}(a);a.handles.textBox.hasMoved||(a.handles.textBox.x=Math.max(a.handles.start.x,a.handles.end.x),a.handles.textBox.y=(a.handles.start.y+a.handles.end.y)/2),(0,c.default)(e,v,a.handles.textBox,T,a.handles,C,n,m,0,!0)})},O=0;O<n.data.length;O++)S(O)}function C(e){var t=Math.min(e.start.x,e.end.x),n=Math.min(e.start.y,e.end.y),a=Math.abs(e.start.x-e.end.x),o=Math.abs(e.start.y-e.end.y);return[{x:t+a/2,y:n},{x:t,y:n+o/2},{x:t+a/2,y:n+o},{x:t+a,y:n+o/2}]}}var T=(0,o.default)({createNewMeasurement:m,onImageRendered:E,pointNearTool:h,toolType:g}),y=(0,r.default)({createNewMeasurement:m,onImageRendered:E,pointNearTool:h,toolType:g});t.rectangleRoi=T,t.rectangleRoiTouch=y},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.probeTouch=t.probe=void 0;var a=g(n(0)),o=g(n(10)),r=g(n(12)),i=g(n(7)),l=g(n(21)),d=g(n(9)),u=g(n(11)),s=g(n(40)),c=g(n(20)),f=n(2),v=n(3);function g(e){return e&&e.__esModule?e:{default:e}}var m="probe";function h(e){return{visible:!0,active:!0,color:void 0,handles:{end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0}}}}function p(e,t,n){if(!1===t.visible)return!1;var o=a.default.cornerstone.pixelToCanvas(e,t.handles.end);return a.default.cornerstoneMath.point.distance(o,n)<5}function E(e){var t=e.detail,n=(0,f.getToolState)(e.currentTarget,m);if(n)for(var o=a.default.cornerstone,r=(0,v.getNewContext)(t.canvasContext.canvas),g=l.default.getFontSize(),h=function(e){var a=n.data[e];if(!1===a.visible)return"continue";(0,v.draw)(r,function(e){var n=i.default.getColorIfActive(a);(0,d.default)(e,t,a.handles,n);var r=Math.round(a.handles.end.x),l=Math.round(a.handles.end.y),f=void 0,v=void 0,m=void 0;if(r>=0&&l>=0&&r<t.image.columns&&l<t.image.rows){if(t.image.color)v=r+", "+l,m="R: "+(f=(0,s.default)(t.element,r,l,1,1))[0]+" G: "+f[1]+" B: "+f[2];else{var h=(f=o.getStoredPixels(t.element,r,l,1,1))[0],p=h*t.image.slope+t.image.intercept,E=(0,c.default)(t.image,h);v=r+", "+l,m="SP: "+h+" MO: "+parseFloat(p.toFixed(3)),E&&(m+=" SUV: "+parseFloat(E.toFixed(3)))}var T={x:a.handles.end.x+3,y:a.handles.end.y-3},y=o.pixelToCanvas(t.element,T);(0,u.default)(e,m,y.x,y.y+g+5,n),(0,u.default)(e,v,y.x,y.y,n)}})},p=0;p<n.data.length;p++)h(p)}var T=(0,o.default)({createNewMeasurement:h,onImageRendered:E,pointNearTool:p,toolType:m}),y=(0,r.default)({createNewMeasurement:h,onImageRendered:E,pointNearTool:p,toolType:m});t.probe=T,t.probeTouch=y},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(n(0));function o(e){return e&&e.__esModule?e:{default:e}}var r=(0,o(n(35)).default)(function(e){var t=e.detail,n=r.getConfiguration();n&&n.testPointers(t)&&(t.viewport.translation.x+=t.deltaPoints.page.x/t.viewport.scale,t.viewport.translation.y+=t.deltaPoints.page.y/t.viewport.scale,a.default.cornerstone.setViewport(t.element,t.viewport),e.preventDefault(),e.stopPropagation())});r.setConfiguration({testPointers:function(e){return e.numPointers>=2}}),t.default=r},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.panTouchDrag=t.pan=void 0;var a=u(n(1)),o=u(n(0)),r=u(n(14)),i=u(n(18)),l=u(n(5)),d=n(4);function u(e){return e&&e.__esModule?e:{default:e}}var s="pan";function c(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,f),t.removeEventListener(a.default.MOUSE_UP,c),t.removeEventListener(a.default.MOUSE_CLICK,c)}function f(e){var t=e.detail,n=t.viewport.scale,a=t.viewport.scale;t.image.rowPixelSpacing<t.image.columnPixelSpacing?n*=t.image.columnPixelSpacing/t.image.rowPixelSpacing:t.image.columnPixelSpacing<t.image.rowPixelSpacing&&(a*=t.image.rowPixelSpacing/t.image.columnPixelSpacing),t.viewport.translation.x+=t.deltaPoints.page.x/n,t.viewport.translation.y+=t.deltaPoints.page.y/a,o.default.cornerstone.setViewport(t.element,t.viewport),e.preventDefault(),e.stopPropagation()}var v=(0,r.default)(function(e){var t=e.detail,n=t.element,o=(0,d.getToolOptions)(s,n);(0,l.default)(t.which,o.mouseButtonMask)&&(n.addEventListener(a.default.MOUSE_DRAG,f),n.addEventListener(a.default.MOUSE_UP,c),n.addEventListener(a.default.MOUSE_CLICK,c),e.preventDefault(),e.stopPropagation())},s),g=(0,i.default)(f,s);t.pan=v,t.panTouchDrag=g},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=s(n(0)),o=s(n(66)),r=s(n(24)),i=s(n(7)),l=n(11),d=s(l),u=n(3);function s(e){return e&&e.__esModule?e:{default:e}}var c=(0,r.default)(function(e){var t=e.detail,n=t.element,r=function(e){var t=a.default.cornerstone,n=t.getEnabledElement(e),r=t.metaData.get("imagePlaneModule",n.image.imageId);if(r&&r.rowCosines&&r.columnCosines){var i=o.default.getOrientationString(r.rowCosines),l=o.default.getOrientationString(r.columnCosines),d=o.default.invertOrientationString(i);return{top:o.default.invertOrientationString(l),bottom:l,left:d,right:i}}}(n);if(r){var s=function(e){var t=a.default.cornerstone,n=t.getEnabledElement(e),o=void 0;o={x:n.image.width/2,y:5};var r=t.pixelToCanvas(e,o);o={x:n.image.width/2,y:n.image.height-5};var i=t.pixelToCanvas(e,o);o={x:5,y:n.image.height/2};var l=t.pixelToCanvas(e,o);return o={x:n.image.width-10,y:n.image.height/2},{top:r,bottom:i,left:l,right:t.pixelToCanvas(e,o)}}(n),f=(0,u.getNewContext)(t.canvasContext.canvas),v=i.default.getToolColor(),g=(0,l.textBoxWidth)(f,r.top,0),m=(0,l.textBoxWidth)(f,r.left,0),h=(0,l.textBoxWidth)(f,r.right,0),p=(0,l.textBoxWidth)(f,r.bottom,0);(0,d.default)(f,r.top,s.top.x-g/2,s.top.y,v),(0,d.default)(f,r.left,s.left.x-m/2,s.left.y,v);var E=c.getConfiguration();E&&E.drawAllMarkers&&((0,d.default)(f,r.right,s.right.x-h/2,s.right.y,v),(0,d.default)(f,r.bottom,s.bottom.x-p/2,s.bottom.y,v))}});t.default=c},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.magnifyTouchDrag=t.magnify=void 0;var a=s(n(1)),o=s(n(0)),r=n(33),i=s(n(5)),l=n(4),d=n(8),u=n(3);function s(e){return e&&e.__esModule?e:{default:e}}var c="magnify",f={magnifySize:300,magnificationLevel:5},v=void 0,g=void 0,m=void 0,h=void 0;function p(e){var t=e.detail,n=t.element;n.removeEventListener(a.default.MOUSE_DRAG,_),n.removeEventListener(a.default.MOUSE_UP,p),n.removeEventListener(a.default.MOUSE_CLICK,p),E(t)}function E(e){e.element.querySelector(".magnifyTool").style.display="none",document.body.style.cursor="default",S()}function T(e){var t=e.detail,n=t.element,r=(0,l.getToolOptions)(c,n);(e.isTouchEvent||(0,i.default)(t.which,r.mouseButtonMask))&&(n.addEventListener(a.default.MOUSE_DRAG,_),n.addEventListener(a.default.TOUCH_DRAG,_),n.addEventListener(a.default.MOUSE_UP,p),n.addEventListener(a.default.TOUCH_END,p),n.addEventListener(a.default.MOUSE_CLICK,p),n.addEventListener(a.default.NEW_IMAGE,y),function(e){S();var t=e.enabledElement;void 0===t&&(t=o.default.cornerstone.getEnabledElement(e.element));var n=C.getConfiguration().magnificationLevel,a=t.canvas,r=t.image;(h=document.createElement("div")).width=a.width*n,h.height=a.height*n,o.default.cornerstone.enable(h);var i=o.default.cornerstone.getEnabledElement(h),l=o.default.cornerstone.getViewport(t.element);(m=i.canvas).width=a.width*n,m.height=a.height*n,i.viewport=Object.assign({},l),l.scale*=n,o.default.cornerstone.displayImage(h,r),o.default.cornerstone.setViewport(h,l)}(t),window.requestAnimationFrame(function(){return x(t)}),e.preventDefault(),e.stopPropagation())}function y(e){var t=e.detail;t.currentPoints=g,x(t)}function M(e){var t=e.detail,n=t.element;n.removeEventListener(a.default.TOUCH_DRAG_END,M),n.removeEventListener(a.default.TOUCH_END,M),n.removeEventListener(a.default.NEW_IMAGE,y),E(t)}function _(e){var t=e.detail,n=t.element;x(t),!0===t.isTouchEvent&&(n.addEventListener(a.default.TOUCH_DRAG_END,M),n.addEventListener(a.default.TOUCH_END,M)),e.preventDefault(),e.stopPropagation()}function x(e){var t=e.element,n=t.querySelector(".magnifyTool");if(n||b(e.element),void 0!==m){var a=C.getConfiguration(),r=a.magnifySize,i=a.magnificationLevel,l=t.querySelector("canvas:not(.magnifyTool)"),s=(0,u.getNewContext)(n),c=r,f=o.default.cornerstone.pixelToCanvas(e.element,e.currentPoints.image);(0,d.clipToBox)(f,l),s.clearRect(0,0,r,r);var g={left:0,top:0,width:r,height:r};(0,u.fillBox)(s,g,"transparent");var h={x:f.x*i-.5*c,y:f.y*i-.5*c};"Safari"===v&&(h.x=Math.max(h.x,0),h.y=Math.max(h.y,0)),h.x=Math.min(h.x,m.width),h.y=Math.min(h.y,m.height),s.drawImage(m,h.x,h.y,c,c,0,0,c,c),n.style.top=f.y-.5*r+"px",n.style.left=f.x-.5*r+"px",e.isTouchEvent&&(n.style.top=f.y-.5*r-120+"px"),n.style.display="block",document.body.style.cursor="none"}}function b(e){if(null===e.querySelector(".magnifyTool")){var t=document.createElement("canvas");t.classList.add("magnifyTool");var n=C.getConfiguration();t.width=n.magnifySize,t.height=n.magnifySize,t.style.position="absolute",t.style.display="none",e.appendChild(t)}}function S(){void 0!==h&&(o.default.cornerstone.disable(h),h=void 0,m=void 0)}function O(e){e.removeEventListener(a.default.MOUSE_DOWN,T),function(e){var t=e.querySelector(".magnifyTool");t&&e.removeChild(t)}(e)}var C={enable:function(e){var t=C.getConfiguration(t);if(!v){var n=(0,r.getBrowserInfo)().split(" ");v=n[0]}b(e)},activate:function(e,t){(0,l.setToolOptions)(c,e,{mouseButtonMask:t}),e.removeEventListener(a.default.MOUSE_DOWN,T),e.addEventListener(a.default.MOUSE_DOWN,T),b(e)},deactivate:O,disable:O,getConfiguration:function(){return f},setConfiguration:function(e){f=e}};function P(e){e.removeEventListener(a.default.TOUCH_START,T),e.addEventListener(a.default.TOUCH_START,T)}function I(e){e.removeEventListener(a.default.TOUCH_START,T)}var L={activate:P,deactivate:I,enable:P,disable:I};t.magnify=C,t.magnifyTouchDrag=L},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.lengthTouch=t.length=void 0;var a=v(n(0)),o=v(n(10)),r=v(n(12)),i=v(n(17)),l=v(n(15)),d=v(n(7)),u=v(n(9)),s=n(2),c=v(n(27)),f=n(3);function v(e){return e&&e.__esModule?e:{default:e}}var g="length";function m(e){return{visible:!0,active:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function h(e,t,n){return!1!==t.visible&&(0,c.default)(e,t.handles.start,t.handles.end,n)<25}function p(e){var t=e.detail,n=(0,s.getToolState)(e.currentTarget,g);if(n){var o=a.default.cornerstone,r=(0,f.getNewContext)(t.canvasContext.canvas),c=t.image,v=t.element,m=l.default.getToolWidth(),h=E.getConfiguration(),p=o.metaData.get("imagePlaneModule",c.imageId),T=void 0,y=void 0;p?(T=p.rowPixelSpacing||p.rowImagePixelSpacing,y=p.columnPixelSpacing||p.colImagePixelSpacing):(T=c.rowPixelSpacing,y=c.columnPixelSpacing);for(var M=function(e){var a=n.data[e];if(!1===a.visible)return"continue";(0,f.draw)(r,function(e){(0,f.setShadow)(e,h);var n=d.default.getColorIfActive(a);(0,f.drawLine)(e,v,a.handles.start,a.handles.end,{color:n});var o={drawHandlesIfActive:h&&h.drawHandlesOnHover};(0,u.default)(e,t,a.handles,n,o);var r=(a.handles.end.x-a.handles.start.x)*(y||1),l=(a.handles.end.y-a.handles.start.y)*(T||1),s=Math.sqrt(r*r+l*l);if(a.length=s,!a.handles.textBox.hasMoved){var c={x:Math.max(a.handles.start.x,a.handles.end.x)};c.x===a.handles.start.x?c.y=a.handles.start.y:c.y=a.handles.end.y,a.handles.textBox.x=c.x,a.handles.textBox.y=c.y}var g=function(e,t,n){var a=" mm";t&&n||(a=" pixels");return""+e.length.toFixed(2)+a}(a,T,y);(0,i.default)(e,v,a.handles.textBox,g,a.handles,x,n,m,10,!0)})},_=0;_<n.data.length;_++)M(_)}function x(e){var t={x:(e.start.x+e.end.x)/2,y:(e.start.y+e.end.y)/2};return[e.start,t,e.end]}}var E=(0,o.default)({createNewMeasurement:m,onImageRendered:p,pointNearTool:h,toolType:g}),T=(0,r.default)({createNewMeasurement:m,onImageRendered:p,pointNearTool:h,toolType:g});t.length=E,t.lengthTouch=T},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=i(n(24)),o=i(n(11)),r=n(3);function i(e){return e&&e.__esModule?e:{default:e}}var l=(0,a.default)(function(e){var t=e.detail,n=t.image.stats,a=(0,r.getNewContext)(t.canvasContext.canvas),i=[];Object.keys(n).forEach(function(e){var t=e+" : "+n[e];i.push(t)}),(0,o.default)(a,i,0,0,"orange"),i.forEach(function(e){console.log(e)})});t.default=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.highlightTouch=t.highlight=void 0;var a=s(n(0)),o=s(n(51)),r=s(n(12)),i=s(n(7)),l=s(n(9)),d=n(2),u=n(3);function s(e){return e&&e.__esModule?e:{default:e}}var c="highlight";function f(e){var t=(0,d.getToolState)(e.event.currentTarget,c);if(!(t&&t.data&&t.data.length>0))return{visible:!0,active:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0}}}}function v(e,t,n){var o=a.default.cornerstone,r=o.pixelToCanvas(e,t.handles.start),i=o.pixelToCanvas(e,t.handles.end),l=Math.min(r.x,i.x),d=Math.min(r.y,i.y),u=Math.abs(r.x-i.x),s=Math.abs(r.y-i.y),c=!1;return n.x>=l&&n.x<=l+u&&n.y>=d&&n.y<=d+s&&(c=!0),c}function g(e,t,n){if(!1===t.visible)return!1;var o=a.default.cornerstone,r=o.pixelToCanvas(e,t.handles.start),i=o.pixelToCanvas(e,t.handles.end),l={left:Math.min(r.x,i.x),top:Math.min(r.y,i.y),width:Math.abs(r.x-i.x),height:Math.abs(r.y-i.y)};return a.default.cornerstoneMath.rect.distanceToPoint(l,n)<5}function m(e){var t=e.detail,n=(0,d.getToolState)(e.currentTarget,c);if(void 0!==n){var a=(0,u.getNewContext)(t.canvasContext.canvas),o=n.data[0];!1!==o.visible&&o&&(0,u.draw)(a,function(e){var n={color:"transparent",fillStyle:"rgba(0,0,0,0.7)"};(0,u.fillOutsideRect)(e,t.element,o.handles.start,o.handles.end,n);var a=i.default.getColorIfActive(o);n={color:a,lineDash:[4]},(0,u.drawRect)(e,t.element,o.handles.start,o.handles.end,n),(0,l.default)(e,t,o.handles,a)})}}var h=(0,o.default)({createNewMeasurement:f,onImageRendered:m,pointNearTool:g,pointInsideRect:v,toolType:c},!0),p=(0,r.default)({createNewMeasurement:f,onImageRendered:m,pointNearTool:g,pointInsideRect:v,toolType:c},!0);t.highlight=h,t.highlightTouch=p},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Sculpter=void 0;var a,o=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),r=n(0),i=(a=r)&&a.__esModule?a:{default:a},l=n(52),d=n(34),u=n(8);t.Sculpter=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return o(e,[{key:"sculpt",value:function(e,t){this._setData(e,t),this._pushHandles(),this._insertNewHandles(),this._consolidateHandles()}},{key:"_setData",value:function(e,t){var n=l.freehandSculpter.getConfiguration();this._eventData=e,this._element=e.element,this._image=e.image,this._mousePoint=e.currentPoints.image,this._dataHandles=t,this._toolSize=n.toolSizeImage,this._minSpacing=n.minSpacing,this._maxSpacing=n.maxSpacing}},{key:"_pushHandles",value:function(){for(var e=this._dataHandles,t=this._mousePoint,n=this._toolSize,a=0;a<e.length;a++){var o=i.default.cornerstoneMath.point.distance(e[a],t);o<n&&this._pushOneHandle(a,o)}}},{key:"_pushOneHandle",value:function(t,n){var a=this._dataHandles,o=a[t],r=this._mousePoint,i=this._toolSize,l=(o.x-r.x)/n,d=(o.y-r.y)/n,s={x:r.x+i*l,y:r.y+i*d};(0,u.clipToBox)(s,this._image),o.x=s.x,o.y=s.y;var c=e.getPreviousHandleIndex(t,a.length);a[c].lines.pop(),a[c].lines.push(o)}},{key:"_insertNewHandles",value:function(){for(var e=this._findNewHandleIndicies(),t=0,n=0;n<e.length;n++){var a=e[n]+1+t;this._insertHandleRadially(a),t++}}},{key:"_findNewHandleIndicies",value:function(){for(var t=this._dataHandles,n=[],a=0;a<t.length;a++){var o=i.default.cornerstone.pixelToCanvas(this._element,t[a]),r=e.getNextHandleIndex(a,t.length),l=i.default.cornerstone.pixelToCanvas(this._element,t[r]);i.default.cornerstoneMath.point.distance(o,l)>this._maxSpacing&&n.push(a)}return n}},{key:"_insertHandleRadially",value:function(t){var n=this._dataHandles,a=t-1,o=e.getNextHandleIndexBeforeInsert(t,n.length),r=this._getInsertPosition(t,a,o),i=new d.FreehandHandleData(r);n.splice(t,0,i),n[a].lines.pop(),n[a].lines.push(n[t]),t===n.length-1?n[t].lines.push(n[0]):n[t].lines.push(n[t+1])}},{key:"_getInsertPosition",value:function(e,t,n){var a=this._toolSize,o=this._mousePoint,r=this._dataHandles,l={x:(r[t].x+r[n].x)/2,y:(r[t].y+r[n].y)/2},d=i.default.cornerstoneMath.point.distance(o,l),s=void 0;if(d<a){var c={x:(l.x-o.x)/d,y:(l.y-o.y)/d};s={x:o.x+a*c.x,y:o.y+a*c.y}}else s=l;return(0,u.clipToBox)(s,this._image),s}},{key:"_consolidateHandles",value:function(){if(this._dataHandles.length>3){var e=this._findCloseHandlePairs();this._mergeCloseHandles(e)}}},{key:"_mergeCloseHandles",value:function(t){for(var n=0,a=0;a<t.length;a++){var o=e.getCorrectedPair(t[a],n);this._combineHandles(o),n++}var r=this._findCloseHandlePairs();r.length&&this._mergeCloseHandles(r)}},{key:"_findCloseHandlePairs",value:function(){for(var t=this._dataHandles,n=this._element,a=[],o=t.length,r=0;r<o;r++){var l=i.default.cornerstone.pixelToCanvas(n,t[r]),d=e.getNextHandleIndex(r,t.length),u=i.default.cornerstone.pixelToCanvas(n,t[d]);if(i.default.cornerstoneMath.point.distance(l,u)<this._minSpacing){var s=[r,d];a.push(s),0===r&&(o-=1),r++}}return a}},{key:"_combineHandles",value:function(t){var n=this._dataHandles,a={x:(n[t[0]].x+n[t[1]].x)/2,y:(n[t[0]].y+n[t[1]].y)/2};(0,u.clipToBox)(a,this._image),n[t[0]].x=a.x,n[t[0]].y=a.y;var o=e.getNextHandleIndex(t[1],n.length);n[t[0]].lines.pop(),n[t[0]].lines.push(n[o]),n.splice(t[1],1)}}],[{key:"getNextHandleIndex",value:function(e,t){return e===t-1?0:e+1}},{key:"getNextHandleIndexBeforeInsert",value:function(e,t){return e===t?0:e}},{key:"getPreviousHandleIndex",value:function(e,t){return 0===e?t-1:e-1}},{key:"getCorrectedPair",value:function(e,t){var n=[e[0]-t,e[1]-t];return n[1]<0&&(n[1]=0),n}}]),e}()},function(e,t,n){"use strict";function a(e,t,n){return a=e.y,o=t.y,r=n.y,!(!(o<a&&a<r||r<a&&a<o)||!function(e,t,n){if(t.x>e.x&&n.x>e.x)return!0;if(t.x===n.x)return e.x<t.x;if(t.x>n.x){var a=t;t=n,n=a}var o=function(e,t,n){var a=(n.y-t.y)/(n.x-t.x);return{value:t.x+a*(e.x-t.x),gradient:a}}(e,t,n);return Math.sign(o.gradient)*e.y>o.value}(e,t,n));var a,o,r}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){for(var n=!1,o=e.length-1,r=0;r<e.length;r++)a(t,e[r],e[o])&&(n=!n),o=r;return n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){var a={count:0,mean:0,variance:0,stdDev:0},o=function(e,t,n){for(var a={value:0,squared:0,count:0},o=0,r=t.top;r<t.top+t.height;r++)for(var l=t.left;l<t.left+t.width;l++){var d={x:l,y:r};i(n,d,a,e[o]),o++}return a}(e,t,n);return 0===o.count?a:(a.count=o.count,a.mean=o.value/o.count,a.variance=o.squared/o.count-a.mean*a.mean,a.stdDev=Math.sqrt(a.variance),a)};var a,o=n(92),r=(a=o)&&a.__esModule?a:{default:a};function i(e,t,n,a){(0,r.default)(e,t)&&(n.value+=a,n.squared+=a*a,n.count++)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=0,a=e.length-1;t=t||1;for(var o=0;o<e.length;o++)n+=(e[a].x+e[o].x)*(e[a].y-e[o].y),a=o;return Math.abs(n*t/2)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.ClickedLineData=function e(t,n){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.toolIndex=t,this.handleIndexArray=n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=e.detail;if(t&&null!==t.handleNearby){!function(e,t){var n=(0,i.getToolState)(e.element,u);if(void 0===n)return;var a=t.handleIndex,o=t.toolIndex,r=n.data[o];if(r.handles.length<=3)return;a===r.handles.length-1?(r.handles[a-1].lines.pop(),r.handles[a-1].lines.push(r.handles[0])):0===a?(r.handles[r.handles.length-1].lines.pop(),r.handles[r.handles.length-1].lines.push(r.handles[a+1])):(r.handles[a-1].lines.pop(),r.handles[a-1].lines.push(r.handles[a+1]));r.handles.splice(a,1),r.invalidated=!0,r.active=!0,r.highlight=!0,d.default.cornerstone.updateImage(e.element)}(n,{toolIndex:t.toolIndex,handleIndex:t.handleNearby})}else{var a=new o.FreehandLineFinder(n).findLine();a&&function(e,t){var n=(0,i.getToolState)(e.element,u);if(void 0===n)return;var a=n.data[t.toolIndex],o=function(e){for(var t=e.handleIndexArray,n=1/0,a=t.includes(0),o=0;o<t.length;o++){var r=t[o];0!==r&&r<n&&(n=r)}a&&1===n&&(n=0);return++n}(t);if(o===1/0)return;var l=new r.FreehandHandleData(e.currentPoints.image);a.handles.splice(o,0,l),a.handles[o-1].lines.pop(),a.handles[o-1].lines.push(e.currentPoints.image),o===a.handles.length-1?a.handles[o].lines.push(a.handles[0]):a.handles[o].lines.push(a.handles[o+1]);a.active=!0,a.highlight=!0,a.invalidated=!0,d.default.cornerstone.updateImage(e.element)}(n,a)}e.preventDefault(),e.stopPropagation()};var a,o=n(53),r=n(34),i=n(2),l=n(0),d=(a=l)&&a.__esModule?a:{default:a};var u="freehand"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){e.detail;var n=a.freehand.getConfiguration();return!0===n.movingTextBox?(function(e,t){var n=a.freehand.getConfiguration();n.movingTextBox=!1,t.data[n.currentTool].invalidated=!0,n.currentHandle=0,n.currentTool=-1}(0,t),"textBox"):n.modifying?(function(e,t){var n=a.freehand.getConfiguration(),o=n.currentTool,r=t.data[o].handles;if(r.invalidHandlePlacement){var i=n.currentHandle,l=r[i],d=void 0;if(0===i){var u=r.length-1;d=r[u]}else d=r[i-1];l.x=n.dragOrigin.x,l.y=n.dragOrigin.y,d.lines[0]=l,r.invalidHandlePlacement=!1}}(0,t),"handle"):null};var a=n(23)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var n=o.freehand.getConfiguration();n.movingTextBox&&function(e){var t=o.freehand.getConfiguration();e.hasMoved=!0,e.x=t.mouseLocation.handles.start.x,e.y=t.mouseLocation.handles.start.y}(e),n.modifying&&function(e,t){var n=o.freehand.getConfiguration();if(t.handles.invalidHandlePlacement=i.default.modify(t.handles,e),t.active=!0,t.highlight=!0,t.handles[e].x=n.mouseLocation.handles.start.x,t.handles[e].y=n.mouseLocation.handles.start.y,e){var a=t.handles[e-1].lines.length-1,r=t.handles[e-1].lines[a];r.x=n.mouseLocation.handles.start.x,r.y=n.mouseLocation.handles.start.y}}(e,t)};var a,o=n(23),r=n(54),i=(a=r)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.eraserTouch=t.eraser=void 0;var a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(46)),o=l(n(0)),r=l(n(14)),i=l(n(56));function l(e){return e&&e.__esModule?e:{default:e}}function d(e){var t=e.detail.currentPoints.canvas,n=e.detail.element;Object.keys(a).forEach(function(e){var r=a[e],i=a.getToolState(n,e);i&&i.data.forEach(function(i){"function"==typeof r.pointNearTool&&r.pointNearTool(n,i,t)&&(a.removeToolState(n,e,i),o.default.cornerstone.updateImage(n))})})}var u=(0,r.default)(d,"eraser"),s=(0,i.default)(d,"eraser");t.eraser=u,t.eraserTouch=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ellipticalRoiTouch=t.ellipticalRoi=void 0;var a=m(n(0)),o=m(n(10)),r=m(n(12)),i=m(n(15)),l=m(n(7)),d=m(n(9)),u=m(n(41)),s=m(n(62)),c=m(n(20)),f=m(n(17)),v=n(2),g=n(3);function m(e){return e&&e.__esModule?e:{default:e}}var h="ellipticalRoi";function p(e){return{visible:!0,active:!0,invalidated:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function E(e,t,n,o){if(!1===t.visible)return!1;var r=a.default.cornerstone,i=r.pixelToCanvas(e,t.handles.start),l=r.pixelToCanvas(e,t.handles.end),d={left:Math.min(i.x,l.x)+o/2,top:Math.min(i.y,l.y)+o/2,width:Math.abs(i.x-l.x)-o,height:Math.abs(i.y-l.y)-o},s={left:Math.min(i.x,l.x)-o/2,top:Math.min(i.y,l.y)-o/2,width:Math.abs(i.x-l.x)+o,height:Math.abs(i.y-l.y)+o},c=(0,u.default)(d,n);return!(!(0,u.default)(s,n)||c)}function T(e){var t=e.toString().split(".");return t[0]=t[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),t.join(".")}function y(e){var t=e.detail,n=(0,v.getToolState)(e.currentTarget,h);if(n){var o=a.default.cornerstone,r=t.image,u=t.element,m=i.default.getToolWidth(),p=M.getConfiguration(),E=o.metaData.get("generalSeriesModule",r.imageId),y=o.metaData.get("imagePlaneModule",r.imageId),_=void 0,x=void 0,b=void 0;y?(x=y.rowPixelSpacing||y.rowImagePixelSpacing,b=y.columnPixelSpacing||y.colImagePixelSpacing):(x=r.rowPixelSpacing,b=r.columnPixelSpacing),E&&(_=E.modality);for(var S=(0,g.getNewContext)(t.canvasContext.canvas),O=function(e){var a=n.data[e];if(!1===a.visible)return"continue";(0,g.draw)(S,function(e){(0,g.setShadow)(e,p);var n=l.default.getColorIfActive(a);if((0,g.drawEllipse)(e,u,a.handles.start,a.handles.end,{color:n}),p&&p.drawHandlesOnHover)if(!0===a.active)(0,d.default)(e,t,a.handles,n);else{(0,d.default)(e,t,a.handles,n,{drawHandlesIfActive:!0})}else(0,d.default)(e,t,a.handles,n);var i=void 0,v=void 0,h=void 0;if(!1===a.invalidated)v=a.meanStdDev,h=a.meanStdDevSUV,i=a.area;else{var E={left:Math.round(Math.min(a.handles.start.x,a.handles.end.x)),top:Math.round(Math.min(a.handles.start.y,a.handles.end.y)),width:Math.round(Math.abs(a.handles.start.x-a.handles.end.x)),height:Math.round(Math.abs(a.handles.start.y-a.handles.end.y))};if(!r.color){var y=o.getPixels(u,E.left,E.top,E.width,E.height);v=(0,s.default)(y,E),"PT"===_&&(h={mean:(0,c.default)(r,(v.mean-r.intercept)/r.slope),stdDev:(0,c.default)(r,(v.stdDev-r.intercept)/r.slope)}),v&&!isNaN(v.mean)&&(a.meanStdDev=v,a.meanStdDevSUV=h)}i=Math.PI*(E.width*(b||1)/2)*(E.height*(x||1)/2),isNaN(i)||(a.area=i),a.invalidated=!1}a.handles.textBox.hasMoved||(a.handles.textBox.x=Math.max(a.handles.start.x,a.handles.end.x),a.handles.textBox.y=(a.handles.start.y+a.handles.end.y)/2);var M=function(e){var t=e.meanStdDev,n=e.meanStdDevSUV,a=e.area,o=[];if(t&&void 0!==t.mean){var r="";"CT"===_&&(r=" HU");var i="Mean: "+T(t.mean.toFixed(2))+r,l="StdDev: "+T(t.stdDev.toFixed(2))+r;if(n&&void 0!==n.mean){i+=" SUV: "+T(n.mean.toFixed(2)),l+=" SUV: "+T(n.stdDev.toFixed(2))}o.push(i),o.push(l)}if(a){var d=" mm"+String.fromCharCode(178);x&&b||(d=" pixels"+String.fromCharCode(178));var u="Area: "+T(a.toFixed(2))+d;o.push(u)}return o}(a);(0,f.default)(e,u,a.handles.textBox,M,a.handles,P,n,m,0,!0)})},C=0;C<n.data.length;C++)O(C)}function P(e){var t=Math.min(e.start.x,e.end.x),n=Math.min(e.start.y,e.end.y),a=Math.abs(e.start.x-e.end.x),o=Math.abs(e.start.y-e.end.y);return[{x:t+a/2,y:n},{x:t,y:n+o/2},{x:t+a/2,y:n+o},{x:t+a,y:n+o/2}]}}var M=(0,o.default)({createNewMeasurement:p,onImageRendered:y,pointNearTool:function(e,t,n){return E(e,t,n,15)},toolType:h}),_=(0,r.default)({createNewMeasurement:p,onImageRendered:y,pointNearTool:function(e,t,n){return E(e,t,n,25)},toolType:h});t.ellipticalRoi=M,t.ellipticalRoiTouch=_},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.dragProbeTouch=t.dragProbe=void 0;var a=h(n(1)),o=h(n(0)),r=h(n(14)),i=h(n(18)),l=h(n(21)),d=h(n(7)),u=n(11),s=h(u),c=h(n(40)),f=h(n(20)),v=h(n(5)),g=n(4),m=n(3);function h(e){return e&&e.__esModule?e:{default:e}}var p="dragProbe",E=void 0;function T(e){var t=o.default.cornerstone,n=t.getEnabledElement(e.element),a=(0,m.getNewContext)(n.canvas),r=d.default.getActiveColor(),i=l.default.getFontSize(),u=x.getConfiguration(),v=Math.round(e.currentPoints.image.x),g=Math.round(e.currentPoints.image.y);v<0||g<0||v>=e.image.columns||g>=e.image.rows||(0,m.draw)(a,function(n){(0,m.setShadow)(n,u);var a=void 0,o=void 0,l=void 0;if(e.image.color)a=(0,c.default)(e.element,v,g,1,1),o=v+", "+g,l="R: "+a[0]+" G: "+a[1]+" B: "+a[2]+" A: "+a[3];else{var d=(a=t.getStoredPixels(e.element,v,g,1,1))[0],h=d*e.image.slope+e.image.intercept,p=(0,f.default)(e.image,d);o=v+", "+g,l="SP: "+d+" MO: "+parseFloat(h.toFixed(3)),p&&(l+=" SUV: "+parseFloat(p.toFixed(3)))}var E={x:e.currentPoints.image.x+3,y:e.currentPoints.image.y-3},T=t.pixelToCanvas(e.element,E);(0,s.default)(n,l,T.x,T.y+i+5,r),(0,s.default)(n,o,T.x,T.y,r)})}function y(e){var t=e.detail,n=t.element;n.removeEventListener(a.default.IMAGE_RENDERED,M),n.removeEventListener(a.default.MOUSE_DRAG,_),n.removeEventListener(a.default.MOUSE_UP,y),n.removeEventListener(a.default.MOUSE_CLICK,y),o.default.cornerstone.updateImage(t.element)}function M(){E&&(x.strategy(E),E=null)}function _(e){var t=e.detail,n=t.element;E=t,o.default.cornerstone.updateImage(n),e.preventDefault(),e.stopPropagation()}var x=(0,r.default)(function(e){var t=e.detail,n=t.element,o=(0,g.getToolOptions)(p,n);(0,v.default)(t.which,o.mouseButtonMask)&&(n.addEventListener(a.default.IMAGE_RENDERED,M),n.addEventListener(a.default.MOUSE_DRAG,_),n.addEventListener(a.default.MOUSE_UP,y),n.addEventListener(a.default.MOUSE_CLICK,y),x.strategy(t),e.preventDefault(),e.stopPropagation())},p);x.strategies={default:T,minimal:function(e){var t=o.default.cornerstone,n=e.element,a=t.getEnabledElement(n),r=a.image,i=(0,m.getNewContext)(a.canvas),v=d.default.getActiveColor(),g=x.getConfiguration(),h=void 0;(h=!0===e.isTouchEvent?t.pageToPixel(n,e.currentPoints.page.x,e.currentPoints.page.y-4*l.default.getFontSize()):t.pageToPixel(n,e.currentPoints.page.x,e.currentPoints.page.y-l.default.getFontSize()/2)).x<0||h.y<0||h.x>=r.columns||h.y>=r.rows||(0,m.draw)(i,function(a){(0,m.setShadow)(a,g);var o=t.metaData.get("generalSeriesModule",r.imageId),i=void 0;o&&(i=o.modality);var d=void 0,p="";if(r.color)p="R: "+(d=(0,c.default)(n,h.x,h.y,1,1))[0]+" G: "+d[1]+" B: "+d[2];else{var E=(d=t.getStoredPixels(n,h.x,h.y,1,1))[0],T=E*e.image.slope+e.image.intercept,y=parseFloat(T.toFixed(2));if("CT"===i)p+="HU: "+y;else if("PT"===i){p+=y;var M=(0,f.default)(e.image,E);M&&(p+=" SUV: "+parseFloat(M.toFixed(2)))}else p+=y}var _=t.pixelToCanvas(n,h),x=void 0,b=(0,u.textBoxWidth)(a,p,5);x=!0===e.isTouchEvent?{x:-b/2,y:-l.default.getFontSize()-10-12}:{x:12,y:-(l.default.getFontSize()+10)/2},(0,m.drawCircle)(a,n,_,6,{color:v},"canvas"),(0,s.default)(a,p,_.x+x.x,_.y+x.y,v)})}},x.strategy=T;var b={fireOnTouchStart:!0,touchStartCallback:function(e){e.detail.element.addEventListener(a.default.IMAGE_RENDERED,M)},touchEndCallback:function(e){var t=e.detail.element;t.removeEventListener(a.default.IMAGE_RENDERED,M),o.default.cornerstone.updateImage(t)}},S=(0,i.default)(_,p,b);t.dragProbe=x,t.dragProbeTouch=S},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(n(0));function o(e){return e&&e.__esModule?e:{default:e}}function r(e){a.default.cornerstone.fitToWindow(e.element)}var i=(0,o(n(57)).default)(function(e){var t=e.detail;i.strategy(t),e.preventDefault(),e.stopPropagation()});i.strategies={default:r},i.strategy=r,t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.crosshairsTouch=t.crosshairs=void 0;var a=c(n(1)),o=c(n(0)),r=c(n(13)),i=n(2),l=c(n(5)),d=n(45),u=c(n(19)),s=n(4);function c(e){return e&&e.__esModule?e:{default:e}}var f="crosshairs";function v(e){var t=e.detail;e.stopImmediatePropagation();var n=(0,i.getToolState)(e.currentTarget,f);if(n){var a=o.default.cornerstone,l=e.currentTarget,s=a.getEnabledElement(l).image.imageId,c=a.metaData.get("imagePlaneModule",s);if(c){var v=t.currentPoints.image,g=(0,d.imagePointToPatientPoint)(v,c);n.data[0].synchronizationContext.getSourceElements().forEach(function(e){if(e!==l){var t=Number.MAX_VALUE,n=-1,o=(0,i.getToolState)(e,"stack");if(void 0!==o){var d=o.data[0];if(d.imageIds.forEach(function(e,o){var r=a.metaData.get("imagePlaneModule",e);if(r&&r.imagePositionPatient&&r.rowCosines&&r.columnCosines){var i=(0,u.default)(r.imagePositionPatient),l=(0,u.default)(r.rowCosines),d=(0,u.default)(r.columnCosines).clone().cross(l.clone()),s=Math.abs(d.clone().dot(i)-d.clone().dot(g));s<t&&(t=s,n=o)}}),n!==d.currentImageIdIndex&&-1!==n&&void 0!==d.imageIds[n]){var s=r.default.getStartLoadHandler(),c=r.default.getEndLoadHandler(),f=r.default.getErrorLoadingHandler();s&&s(e);(!0===d.preventCache?a.loadImage(d.imageIds[n]):a.loadAndCacheImage(d.imageIds[n])).then(function(t){var o=a.getViewport(e);d.currentImageIdIndex=n,a.displayImage(e,t,o),c&&c(e,t)},function(t){var a=d.imageIds[n];f&&f(e,a,t)})}}}})}}}function g(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,h),t.removeEventListener(a.default.MOUSE_UP,g)}function m(e){var t=e.detail,n=t.element,o=(0,s.getToolOptions)(f,n);(0,l.default)(t.which,o.mouseButtonMask)&&(n.addEventListener(a.default.MOUSE_DRAG,h),n.addEventListener(a.default.MOUSE_UP,g),v(e),e.preventDefault(),e.stopPropagation())}function h(e){v(e),e.preventDefault(),e.stopPropagation()}function p(e,t,n){(0,s.setToolOptions)(f,e,{mouseButtonMask:t}),(0,i.clearToolState)(e,f),(0,i.addToolState)(e,f,{synchronizationContext:n}),e.removeEventListener(a.default.MOUSE_DOWN,m),e.addEventListener(a.default.MOUSE_DOWN,m)}function E(e){e.removeEventListener(a.default.MOUSE_DOWN,m)}var T={activate:p,deactivate:E,enable:p,disable:E};function y(e){var t=e.detail.element;t.removeEventListener(a.default.TOUCH_DRAG,_),t.removeEventListener(a.default.TOUCH_DRAG_END,y)}function M(e){var t=e.detail.element;return t.addEventListener(a.default.TOUCH_DRAG,_),t.addEventListener(a.default.TOUCH_DRAG_END,y),v(e),!1}function _(e){v(e),e.preventDefault(),e.stopPropagation()}function x(e,t){(0,i.clearToolState)(e,f),(0,i.addToolState)(e,f,{synchronizationContext:t}),e.removeEventListener(a.default.TOUCH_START,M),e.addEventListener(a.default.TOUCH_START,M)}function b(e){e.removeEventListener(a.default.TOUCH_START,M)}var S={activate:x,deactivate:b,enable:x,disable:b};t.crosshairs=T,t.crosshairsTouch=S},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,a,o,l){var d=e.length>0?r.default.cornerstoneMath.point.findClosestPoint(e,t):t,u=[{x:n.left+n.width/2,y:n.top},{x:n.left,y:n.top+n.height/2},{x:n.left+n.width/2,y:n.top+n.height},{x:n.left+n.width,y:n.top+n.height/2}],s=r.default.cornerstoneMath.point.findClosestPoint(u,d),c={color:o,lineWidth:l,lineDash:[2,3]};(0,i.drawLine)(a,void 0,d,s,c,"canvas")};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.arrowAnnotateTouch=t.arrowAnnotate=void 0;var a=x(n(1)),o=x(n(0)),r=x(n(10)),i=x(n(12)),l=x(n(15)),d=x(n(21)),u=x(n(7)),s=x(n(9)),c=x(n(63)),f=x(n(30)),v=x(n(28)),g=x(n(16)),m=x(n(5)),h=x(n(22)),p=x(n(17)),E=n(2),T=n(4),y=x(n(27)),M=n(3),_=n(11);function x(e){return e&&e.__esModule?e:{default:e}}var b="arrowAnnotate";var S={getTextCallback:function(e){e(prompt("Enter your annotation:"))},changeTextCallback:function(e,t,n){n(prompt("Change your annotation:"))},drawHandles:!1,drawHandlesOnHover:!0,arrowFirst:!0};function O(e){return{visible:!0,active:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!1},textBox:{active:!1,hasMoved:!1,movesIndependently:!1,drawnIndependently:!0,allowedOutsideImage:!0,hasBoundingBox:!0}}}}function C(e,t,n){return!1!==t.visible&&(0,y.default)(e,t.handles.start,t.handles.end,n)<25}function P(e){var t=e.detail,n=(0,E.getToolState)(e.currentTarget,b);if(n)for(var a=t.enabledElement,r=o.default.cornerstone,i=(0,M.getNewContext)(t.canvasContext.canvas),f=l.default.getToolWidth(),v=I.getConfiguration(),g=function(e){var o=n.data[e];if(!1===o.visible)return"continue";(0,M.draw)(i,function(e){(0,M.setShadow)(e,v);var n=u.default.getColorIfActive(o),i=r.pixelToCanvas(t.element,o.handles.start),l=r.pixelToCanvas(t.element,o.handles.end);v.arrowFirst?(0,c.default)(e,l,i,n,f):(0,c.default)(e,i,l,n,f);var g={drawHandlesIfActive:v&&v.drawHandlesOnHover};v.drawHandles&&(0,s.default)(e,t,o.handles,n,g);var m=function(e){return e.text}(o);if(m&&""!==m){var E=(0,_.textBoxWidth)(e,m,5),T=d.default.getFontSize()+10,y=Math.max(E,T)/2+5;if(l.x<i.x&&(y=-y),!o.handles.textBox.hasMoved){var x=void 0;x=v.arrowFirst?{x:l.x-E/2+y,y:l.y-T/2}:{x:i.x-E/2-y,y:i.y-T/2};var b=r.internal.getTransform(a);b.invert();var S=b.transformPoint(x.x,x.y);o.handles.textBox.x=S.x,o.handles.textBox.y=S.y}(0,p.default)(e,t.element,o.handles.textBox,m,o.handles,h,n,f,0,!1)}})},m=0;m<n.data.length;m++)g(m);function h(e){var t={x:(e.start.x+e.end.x)/2,y:(e.start.y+e.end.y)/2};return[e.start,t,e.end]}}var I=(0,r.default)({addNewMeasurement:function(e){var t=e.element,n=O(e),r=o.default.cornerstone;function i(e){null===e?(0,E.removeToolState)(t,b,n):n.text=e,n.active=!1,r.updateImage(t),t.addEventListener(a.default.MOUSE_MOVE,I.mouseMoveCallback),t.addEventListener(a.default.MOUSE_DOWN,I.mouseDownCallback),t.addEventListener(a.default.MOUSE_DOWN_ACTIVATE,I.mouseDownActivateCallback),t.addEventListener(a.default.MOUSE_DOUBLE_CLICK,I.mouseDoubleClickCallback)}(0,E.addToolState)(t,b,n),t.removeEventListener(a.default.MOUSE_MOVE,I.mouseMoveCallback),t.removeEventListener(a.default.MOUSE_DOWN,I.mouseDownCallback),t.removeEventListener(a.default.MOUSE_DOWN_ACTIVATE,I.mouseDownActivateCallback),t.removeEventListener(a.default.MOUSE_DOUBLE_CLICK,I.mouseDoubleClickCallback),r.updateImage(t),(0,f.default)(e,b,n,n.handles.end,function(){(0,g.default)(e,n.handles)&&(0,E.removeToolState)(t,b,n);var a=I.getConfiguration();void 0===n.text&&a.getTextCallback(i),r.updateImage(t)})},createNewMeasurement:O,onImageRendered:P,pointNearTool:C,toolType:b,mouseDoubleClickCallback:function(e){var t=e.detail,n=t.element,a=o.default.cornerstone,r=(0,T.getToolOptions)(b,n),i=void 0;if((0,m.default)(t.which,r.mouseButtonMask)){var l=I.getConfiguration(),d=t.currentPoints.canvas,u=(0,E.getToolState)(n,b);if(u)for(var s=0;s<u.data.length;s++)if(i=u.data[s],C(n,i,d)||(0,h.default)(i.handles.textBox,d))return i.active=!0,a.updateImage(n),l.changeTextCallback(i,t,c),e.stopImmediatePropagation(),!1}function c(e,t,o){!0===o?(0,E.removeToolState)(n,b,e):e.text=t,e.active=!1,a.updateImage(n)}}});I.setConfiguration(S);var L=(0,i.default)({addNewMeasurement:function(e){var t=e.element,n=O(e),r=o.default.cornerstone;function i(e){null===e?(0,E.removeToolState)(t,b,n):n.text=e,n.active=!1,r.updateImage(t),t.addEventListener(a.default.TOUCH_PRESS,L.pressCallback),t.addEventListener(a.default.TOUCH_START_ACTIVE,L.touchDownActivateCallback),t.addEventListener(a.default.TAP,L.tapCallback)}(0,E.addToolState)(t,b,n),t.removeEventListener(a.default.TOUCH_PRESS,L.pressCallback),t.removeEventListener(a.default.TOUCH_START_ACTIVE,L.touchDownActivateCallback),t.removeEventListener(a.default.TAP,L.tapCallback),r.updateImage(t),(0,v.default)(e,b,n,n.handles.end,function(){r.updateImage(t),(0,g.default)(e,n.handles)&&(0,E.removeToolState)(t,b,n);var a=I.getConfiguration();void 0===n.text&&a.getTextCallback(i)})},createNewMeasurement:O,onImageRendered:P,pointNearTool:C,toolType:b,pressCallback:function(e){var t=e.detail,n=t.element,r=o.default.cornerstone,i=void 0;function l(e,t,o){console.log("pressCallback doneChangingTextCallback"),!0===o?(0,E.removeToolState)(n,b,e):e.text=t,e.active=!1,r.updateImage(n),n.addEventListener(a.default.TOUCH_START,L.touchStartCallback),n.addEventListener(a.default.TOUCH_START_ACTIVE,L.touchDownActivateCallback),n.addEventListener(a.default.TAP,L.tapCallback)}var d=I.getConfiguration(),u=t.currentPoints.canvas,s=(0,E.getToolState)(n,b);if(s){if(t.handlePressed)return n.removeEventListener(a.default.TOUCH_START,L.touchStartCallback),n.removeEventListener(a.default.TOUCH_START_ACTIVE,L.touchDownActivateCallback),n.removeEventListener(a.default.TAP,L.tapCallback),d.changeTextCallback(t.handlePressed,t,l),e.stopImmediatePropagation(),!1;for(var c=0;c<s.data.length;c++)if(i=s.data[c],C(n,i,u)||(0,h.default)(i.handles.textBox,u))return i.active=!0,r.updateImage(n),n.removeEventListener(a.default.TOUCH_START,L.touchStartCallback),n.removeEventListener(a.default.TOUCH_START_ACTIVE,L.touchDownActivateCallback),n.removeEventListener(a.default.TAP,L.tapCallback),d.changeTextCallback(i,t,l),e.stopImmediatePropagation(),!1;e.preventDefault(),e.stopPropagation()}}});t.arrowAnnotate=I,t.arrowAnnotateTouch=L},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.angleTouch=t.angle=void 0;var a=v(n(0)),o=v(n(10)),r=v(n(12)),i=v(n(11)),l=v(n(42)),d=v(n(7)),u=v(n(9)),s=n(2),c=v(n(27)),f=n(3);function v(e){return e&&e.__esModule?e:{default:e}}var g="angle";function m(e){return{visible:!0,active:!0,color:void 0,handles:{start:{x:e.currentPoints.image.x-20,y:e.currentPoints.image.y+10,highlight:!0,active:!1},end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0},start2:{x:e.currentPoints.image.x-20,y:e.currentPoints.image.y+10,highlight:!0,active:!1},end2:{x:e.currentPoints.image.x,y:e.currentPoints.image.y+20,highlight:!0,active:!1}}}}function h(e,t,n){return!1!==t.visible&&((0,c.default)(e,t.handles.start,t.handles.end,n)<5||(0,c.default)(e,t.handles.start2,t.handles.end2,n)<5)}function p(e){var t=e.detail,n=(0,s.getToolState)(e.currentTarget,g);if(void 0!==n)for(var o=(0,f.getNewContext)(t.canvasContext.canvas),r=E.getConfiguration(),c=a.default.cornerstone,v=function(e){var a=n.data[e];if(!1===a.visible)return"continue";(0,f.draw)(o,function(e){(0,f.setShadow)(e,r);var n=d.default.getColorIfActive(a);(0,f.drawJoinedLines)(e,t.element,a.handles.end,[a.handles.start,a.handles.end2],{color:n}),(0,u.default)(e,t,a.handles);var o=(Math.ceil(a.handles.start.x)-Math.ceil(a.handles.end.x))*t.image.columnPixelSpacing,s=(Math.ceil(a.handles.start.y)-Math.ceil(a.handles.end.y))*t.image.rowPixelSpacing,v=(Math.ceil(a.handles.start2.x)-Math.ceil(a.handles.end2.x))*t.image.columnPixelSpacing,g=(Math.ceil(a.handles.start2.y)-Math.ceil(a.handles.end2.y))*t.image.rowPixelSpacing,m=Math.acos(Math.abs((o*v+s*g)/(Math.sqrt(o*o+s*s)*Math.sqrt(v*v+g*g))));m*=180/Math.PI;var h=(0,l.default)(m,2).toString()+String.fromCharCode(parseInt("00B0",16)),p=c.pixelToCanvas(t.element,a.handles.start2),E=c.pixelToCanvas(t.element,a.handles.end2),T=(p.x+E.x)/2,y=(p.y+E.y)/2;(0,i.default)(e,h,T,y,n)})},m=0;m<n.data.length;m++)v(m)}var E=(0,o.default)({createNewMeasurement:m,onImageRendered:p,pointNearTool:h,toolType:g}),T=(0,r.default)({createNewMeasurement:m,onImageRendered:p,pointNearTool:h,toolType:g});t.angle=E,t.angleTouch=T},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=u(n(1)),o=u(n(0)),r=u(n(39)),i=u(n(58)),l=u(n(6)),d=n(4);function u(e){return e&&e.__esModule?e:{default:e}}var s=void 0,c=void 0,f=void 0,v=void 0,g=void 0,m=void 0,h=void 0,p=void 0,E=1,T=0,y=!1,M=!1,_=void 0,x=700,b=5,S="touchInput";function O(e){var t=o.default.cornerstone,n=e.currentTarget||e.srcEvent.currentTarget,i=t.getEnabledElement(n);if(i.image){var d=void 0,u=void 0,S=void 0,O=void 0;switch(e.preventDefault(),(e.pointers&&e.pointers.length>1||e.touches&&e.touches.length>1)&&(M=!1,clearTimeout(h)),e.type){case"tap":M=!1,clearTimeout(h),(c={page:o.default.cornerstoneMath.point.pageToPoint(e.pointers[0]),image:t.pageToPixel(n,e.pointers[0].pageX,e.pointers[0].pageY),client:{x:e.pointers[0].clientX,y:e.pointers[0].clientY}}).canvas=t.pixelToCanvas(n,c.image),d=a.default.TAP,g={event:e,viewport:t.getViewport(n),image:i.image,element:n,currentPoints:c,type:d,isTouchEvent:!0},(0,l.default)(n,d,g);break;case"doubletap":M=!1,clearTimeout(h),(c={page:o.default.cornerstoneMath.point.pageToPoint(e.pointers[0]),image:t.pageToPixel(n,e.pointers[0].pageX,e.pointers[0].pageY),client:{x:e.pointers[0].clientX,y:e.pointers[0].clientY}}).canvas=t.pixelToCanvas(n,c.image),d=a.default.DOUBLE_TAP,g={event:e,viewport:t.getViewport(n),image:i.image,element:n,currentPoints:c,type:d,isTouchEvent:!0},(0,l.default)(n,d,g);break;case"pinchstart":M=!1,clearTimeout(h),E=1;break;case"pinchmove":if(M=!1,clearTimeout(h),!0===y){E=e.scale,y=!1;break}u=(e.scale-E)/E,(s={page:e.center,image:t.pageToPixel(n,e.center.x,e.center.y)}).canvas=t.pixelToCanvas(n,s.image),d=a.default.TOUCH_PINCH,g={event:e,startPoints:s,viewport:t.getViewport(n),image:i.image,element:n,direction:e.scale<1?1:-1,scaleChange:u,type:d,isTouchEvent:!0},(0,l.default)(n,d,g),E=e.scale;break;case"touchstart":E=1,clearTimeout(h),clearTimeout(m),m=setTimeout(function(){(s={page:o.default.cornerstoneMath.point.pageToPoint(e.touches[0]),image:t.pageToPixel(n,e.touches[0].pageX,e.touches[0].pageY),client:{x:e.touches[0].clientX,y:e.touches[0].clientY}}).canvas=t.pixelToCanvas(n,s.image),d=a.default.TOUCH_START,e.touches.length>1&&(d=a.default.MULTI_TOUCH_START),g={event:e,viewport:t.getViewport(n),image:i.image,element:n,startPoints:s,currentPoints:s,type:d,isTouchEvent:!0},!0===(0,l.default)(n,d,g)&&(d=a.default.TOUCH_START_ACTIVE,e.touches.length>1&&(d=a.default.MULTI_TOUCH_START_ACTIVE),g.type=d,(0,l.default)(n,d,g)),f=(0,r.default)(s)},50),M=!0,p=0,h=setTimeout(function(){M&&((c={page:o.default.cornerstoneMath.point.pageToPoint(e.touches[0]),image:t.pageToPixel(n,e.touches[0].pageX,e.touches[0].pageY),client:{x:e.touches[0].clientX,y:e.touches[0].clientY}}).canvas=t.pixelToCanvas(n,s.image),d=a.default.TOUCH_PRESS,g={event:e,viewport:t.getViewport(n),image:i.image,element:n,currentPoints:c,type:d,isTouchEvent:!0},(0,l.default)(n,d,g))},x);break;case"touchend":E=1,M=!1,clearTimeout(h),setTimeout(function(){(s={page:o.default.cornerstoneMath.point.pageToPoint(e.changedTouches[0]),image:t.pageToPixel(n,e.changedTouches[0].pageX,e.changedTouches[0].pageY),client:{x:e.changedTouches[0].clientX,y:e.changedTouches[0].clientY}}).canvas=t.pixelToCanvas(n,s.image),d=a.default.TOUCH_END,g={event:e,viewport:t.getViewport(n),image:i.image,element:n,startPoints:s,currentPoints:s,type:d,isTouchEvent:!0},(0,l.default)(n,d,g)},50);break;case"panmove":S={x:e.deltaX-_.x,y:e.deltaY-_.y},_={x:e.deltaX,y:e.deltaY},(c={page:{x:f.page.x+S.x,y:f.page.y+S.y},image:t.pageToPixel(n,f.page.x+S.x,f.page.y+S.y),client:{x:f.client.x+S.x,y:f.client.y+S.y}}).canvas=t.pixelToCanvas(n,c.image),v={page:o.default.cornerstoneMath.point.subtract(c.page,f.page),image:o.default.cornerstoneMath.point.subtract(c.image,f.image),client:o.default.cornerstoneMath.point.subtract(c.client,f.client),canvas:o.default.cornerstoneMath.point.subtract(c.canvas,f.canvas)},(p+=Math.sqrt(v.page.x*v.page.x+v.page.y*v.page.y))>b&&(M=!1,clearTimeout(h)),d=a.default.TOUCH_DRAG,e.pointers.length>1&&(d=a.default.MULTI_TOUCH_DRAG),g={viewport:t.getViewport(n),image:i.image,element:n,startPoints:s,lastPoints:f,currentPoints:c,deltaPoints:v,numPointers:e.pointers.length,type:d,isTouchEvent:!0},(0,l.default)(n,d,g),f=(0,r.default)(c);break;case"panstart":_={x:e.deltaX,y:e.deltaY},(c={page:o.default.cornerstoneMath.point.pageToPoint(e.pointers[0]),image:t.pageToPixel(n,e.pointers[0].pageX,e.pointers[0].pageY),client:{x:e.pointers[0].clientX,y:e.pointers[0].clientY}}).canvas=t.pixelToCanvas(n,c.image),f=(0,r.default)(c);break;case"panend":if(M=!1,clearTimeout(h),!f)return!1;(c={page:o.default.cornerstoneMath.point.pageToPoint(e.pointers[0]),image:t.pageToPixel(n,e.pointers[0].pageX,e.pointers[0].pageY),client:{x:e.pointers[0].clientX,y:e.pointers[0].clientY}}).canvas=t.pixelToCanvas(n,c.image),v={page:o.default.cornerstoneMath.point.subtract(c.page,f.page),image:o.default.cornerstoneMath.point.subtract(c.image,f.image),client:o.default.cornerstoneMath.point.subtract(c.client,f.client),canvas:o.default.cornerstoneMath.point.subtract(c.canvas,f.canvas)},d=a.default.TOUCH_DRAG_END,g={event:e.srcEvent,viewport:t.getViewport(n),image:i.image,element:n,startPoints:s,lastPoints:f,currentPoints:c,deltaPoints:v,type:d,isTouchEvent:!0},(0,l.default)(n,d,g),2===e.pointers.length-e.changedPointers.length&&(y=!0);break;case"rotatemove":M=!1,clearTimeout(h),O=e.rotation-T,T=e.rotation,d=a.default.TOUCH_ROTATE,g={event:e.srcEvent,viewport:t.getViewport(n),image:i.image,element:n,rotation:O,type:d},(0,l.default)(n,d,g)}return!1}}function C(e){i.default.disable(e);["touchstart","touchend"].forEach(function(t){e.removeEventListener(t,O)});var t=(0,d.getToolOptions)(S,e).hammer;t&&t.off("tap doubletap panstart panmove panend pinchstart pinchmove rotatemove",O)}var P={enable:function(e){C(e);var t=o.default.Hammer,n={inputClass:t.SUPPORT_POINTER_EVENTS?t.PointerEventInput:t.TouchInput},a=new t.Manager(e,n),r={pointers:0,direction:t.DIRECTION_ALL,threshold:0},l=new t.Pan(r),u=new t.Pinch({threshold:0}),s=new t.Rotate({threshold:0});u.recognizeWith(l),u.recognizeWith(s),s.recognizeWith(l);var c=new t.Tap({event:"doubletap",taps:2,interval:1500,threshold:50,posThreshold:50});c.recognizeWith(l),a.add([c,l,s,u]),a.on("tap doubletap panstart panmove panend pinchstart pinchmove rotatemove",O),i.default.enable(e),["touchstart","touchend"].forEach(function(t){e.addEventListener(t,O)});var f=(0,d.getToolOptions)(S,e);f.hammer=a,(0,d.setToolOptions)(S,e,f)},disable:C};t.default=P},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=i(n(1)),o=i(n(0)),r=i(n(6));function i(e){return e&&e.__esModule?e:{default:e}}function l(e){var t=o.default.cornerstone,n=e.currentTarget,i=t.getEnabledElement(n);if(i.image&&!("mousewheel"===e.type&&0===e.wheelDeltaY||"DOMMouseScroll"===e.type&&1===e.axis)){e.preventDefault();var l=void 0,d=void 0;void 0!==e.pageX&&void 0!==e.pageY?(l=e.pageX,d=e.pageY):(l=e.x,d=e.y);var u=t.pageToPixel(n,l,d),s=((e=window.event&&window.event.wheelDelta?window.event:e).wheelDelta?e.wheelDelta:e.deltaY?-e.deltaY:e.detail?-e.detail:e.wheelDelta)<0?-1:1,c={element:n,viewport:t.getViewport(n),image:i.image,direction:s,pageX:l,pageY:d,imageX:u.x,imageY:u.y};(0,r.default)(n,a.default.MOUSE_WHEEL,c)}}var d=["mousewheel","DOMMouseScroll"];function u(e){d.forEach(function(t){e.removeEventListener(t,l)})}var s={enable:function(e){u(e),d.forEach(function(t){e.addEventListener(t,l)})},disable:u};t.default=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=l(n(1)),o=l(n(0)),r=l(n(39)),i=l(n(6));function l(e){return e&&e.__esModule?e:{default:e}}var d=!0,u=void 0,s=200;function c(e){return"number"!=typeof e.buttons?e.which:0===e.buttons?0:e.buttons%2==1?1:e.buttons%4==2?3:e.buttons%8==4?2:0}function f(){d=!1}function v(e){var t=o.default.cornerstone,n=e.currentTarget,l=t.getEnabledElement(n);if(l.image){var d=a.default.MOUSE_DOUBLE_CLICK,u={page:o.default.cornerstoneMath.point.pageToPoint(e),image:t.pageToPixel(n,e.pageX,e.pageY),client:{x:e.clientX,y:e.clientY}};u.canvas=t.pixelToCanvas(n,u.image);var s=(0,r.default)(u),c={event:e,which:e.which,viewport:t.getViewport(n),image:l.image,element:n,startPoints:u,lastPoints:s,currentPoints:u,deltaPoints:{x:0,y:0},type:d};(0,i.default)(n,d,c)}}function g(e){var t=o.default.cornerstone,n=e.currentTarget,l=t.getEnabledElement(n);if(l.image){u=setTimeout(f,s);var v=a.default.MOUSE_DOWN;n.removeEventListener("mousemove",m);var g={page:o.default.cornerstoneMath.point.pageToPoint(e),image:t.pageToPixel(n,e.pageX,e.pageY),client:{x:e.clientX,y:e.clientY}};g.canvas=t.pixelToCanvas(n,g.image);var h=(0,r.default)(g),p={event:e,which:c(e),viewport:t.getViewport(n),image:l.image,element:n,startPoints:g,lastPoints:h,currentPoints:g,deltaPoints:{x:0,y:0},type:v};(0,i.default)(p.element,v,p)&&(p.type=a.default.MOUSE_DOWN_ACTIVATE,(0,i.default)(p.element,a.default.MOUSE_DOWN_ACTIVATE,p));var E=c(e);document.addEventListener("mousemove",T),document.addEventListener("mouseup",function e(r){clearTimeout(u);var s=a.default.MOUSE_UP;d&&(s=a.default.MOUSE_CLICK);var c={page:o.default.cornerstoneMath.point.pageToPoint(r),image:t.pageToPixel(n,r.pageX,r.pageY),client:{x:r.clientX,y:r.clientY}};c.canvas=t.pixelToCanvas(n,c.image);var f={page:o.default.cornerstoneMath.point.subtract(c.page,h.page),image:o.default.cornerstoneMath.point.subtract(c.image,h.image),client:o.default.cornerstoneMath.point.subtract(c.client,h.client),canvas:o.default.cornerstoneMath.point.subtract(c.canvas,h.canvas)},v={event:r,which:E,viewport:t.getViewport(n),image:l.image,element:n,startPoints:g,lastPoints:h,currentPoints:c,deltaPoints:f,type:s};(0,i.default)(v.element,s,v),document.removeEventListener("mousemove",T),document.removeEventListener("mouseup",e),n.addEventListener("mousemove",m),d=!0})}function T(e){var d=a.default.MOUSE_DRAG,u={page:o.default.cornerstoneMath.point.pageToPoint(e),image:t.pageToPixel(n,e.pageX,e.pageY),client:{x:e.clientX,y:e.clientY}};u.canvas=t.pixelToCanvas(n,u.image);var s={page:o.default.cornerstoneMath.point.subtract(u.page,h.page),image:o.default.cornerstoneMath.point.subtract(u.image,h.image),client:o.default.cornerstoneMath.point.subtract(u.client,h.client),canvas:o.default.cornerstoneMath.point.subtract(u.canvas,h.canvas)},c={which:E,viewport:t.getViewport(n),image:l.image,element:n,startPoints:g,lastPoints:h,currentPoints:u,deltaPoints:s,type:d,ctrlKey:e.ctrlKey,metaKey:e.metaKey,shiftKey:e.shiftKey};(0,i.default)(c.element,d,c),h=(0,r.default)(u)}}function m(e){var t=o.default.cornerstone,n=e.currentTarget,l=t.getEnabledElement(n);if(l.image){var d=a.default.MOUSE_MOVE,u={page:o.default.cornerstoneMath.point.pageToPoint(e),image:t.pageToPixel(n,e.pageX,e.pageY),client:{x:e.clientX,y:e.clientY}};u.canvas=t.pixelToCanvas(n,u.image);var s=(0,r.default)(u),c={page:o.default.cornerstoneMath.point.pageToPoint(e),image:t.pageToPixel(n,e.pageX,e.pageY),client:{x:e.clientX,y:e.clientY}};c.canvas=t.pixelToCanvas(n,c.image);var f={page:o.default.cornerstoneMath.point.subtract(c.page,s.page),image:o.default.cornerstoneMath.point.subtract(c.image,s.image),client:o.default.cornerstoneMath.point.subtract(c.client,s.client),canvas:o.default.cornerstoneMath.point.subtract(c.canvas,s.canvas)},v={viewport:t.getViewport(n),image:l.image,element:n,startPoints:u,lastPoints:s,currentPoints:c,deltaPoints:f,type:d};(0,i.default)(n,d,v),s=(0,r.default)(c)}}function h(e){e.removeEventListener("mousedown",g),e.removeEventListener("mousemove",m),e.removeEventListener("dblclick",v)}var p={enable:function(e){h(e),e.addEventListener("mousedown",g),e.addEventListener("mousemove",m),e.addEventListener("dblclick",v)},disable:h};t.default=p},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=i(n(1)),o=i(n(0)),r=i(n(6));function i(e){return e&&e.__esModule?e:{default:e}}var l=void 0,d=void 0;function u(e){var t=o.default.cornerstone,n=e.currentTarget,i=t.getEnabledElement(n);if(i.image){var u={event:window.event||e,element:n,viewport:t.getViewport(n),image:i.image,currentPoints:{page:{x:l,y:d},image:t.pageToPixel(n,l,d)},keyCode:e.keyCode,which:e.which};u.currentPoints.canvas=t.pixelToCanvas(n,u.currentPoints.image);var s={keydown:a.default.KEY_DOWN,keypress:a.default.KEY_PRESS,keyup:a.default.KEY_UP};(0,r.default)(n,s[e.type],u)}}function s(e){l=e.pageX,d=e.pageY}var c=["keydown","keypress","keyup"];var f={enable:function(e){c.forEach(function(t){e.removeEventListener(t,u),e.addEventListener(t,u)}),e.removeEventListener("mousemove",s),e.addEventListener("mousemove",s)},disable:function(e){c.forEach(function(t){e.removeEventListener(t,u)}),e.removeEventListener("mousemove",s)}};t.default=f},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.stopClip=t.playClip=void 0;var a=d(n(1)),o=d(n(0)),r=d(n(13)),i=n(2),l=d(n(6));function d(e){return e&&e.__esModule?e:{default:e}}var u="playClip";function s(e){var t=e.intervalId;void 0!==t&&(e.intervalId=void 0,e.usingFrameTimeVector?clearTimeout(t):clearInterval(t))}t.playClip=function(e,t){var n=void 0,d=void 0;if(void 0===e)throw new Error("playClip: element must not be undefined");var c=(0,i.getToolState)(e,"stack");if(c&&c.data&&c.data.length){var f=o.default.cornerstone,v=void 0;if(c.data.length>1){var g=(0,i.getToolState)(e,"stackRenderer");g&&g.data&&g.data.length&&(v=g.data[0])}var m=c.data[0],h=(0,i.getToolState)(e,u);h&&h.data&&h.data.length?s(n=h.data[0]):(n={intervalId:void 0,framesPerSecond:30,lastFrameTimeStamp:void 0,frameRate:0,frameTimeVector:void 0,ignoreFrameTimeVector:!1,usingFrameTimeVector:!1,speed:1,reverse:!1,loop:!0},(0,i.addToolState)(e,u,n)),(t<0||t>0)&&(n.framesPerSecond=Number(t),n.reverse=n.framesPerSecond<0,n.ignoreFrameTimeVector=!0),!0!==n.ignoreFrameTimeVector&&n.frameTimeVector&&n.frameTimeVector.length===m.imageIds.length&&(d=function(e,t){var n=void 0,a=void 0,o=void 0,r=0,i=e.length,l=[];for(l.isTimeVarying=!1,("number"!=typeof t||t<=0)&&(t=1),n=1;n<i;n++)o=Number(e[n])/t|0,l.push(o),1===n?a=o:o!==a&&(l.isTimeVarying=!0),r+=o;return l.length>0&&(o=l.isTimeVarying?r/l.length|0:l[0],l.push(o)),l}(n.frameTimeVector,n.speed));var p=function(){var t=void 0,o=void 0,i=void 0,d=m.currentImageIdIndex,u=m.imageIds.length;if(n.reverse?d--:d++,!n.loop&&(d<0||d>=u))return s(n),void function(e){var t={element:e};(0,l.default)(e,a.default.CLIP_STOPPED,t)}(e);d>=u&&(d=0),d<0&&(d=u-1),d!==m.currentImageIdIndex&&(t=r.default.getStartLoadHandler(),o=r.default.getEndLoadHandler(),i=r.default.getErrorLoadingHandler(),t&&t(e),(!0===m.preventCache?f.loadImage(m.imageIds[d]):f.loadAndCacheImage(m.imageIds[d])).then(function(t){try{m.currentImageIdIndex=d,v?(v.currentImageIdIndex=d,v.render(e,c.data)):f.displayImage(e,t),o&&o(e,t)}catch(e){return}},function(t){var n=m.imageIds[d];i&&i(e,n,t)}))};d&&d.length>0&&d.isTimeVarying?(n.usingFrameTimeVector=!0,n.intervalId=setTimeout(function e(){n.intervalId=setTimeout(e,d[m.currentImageIdIndex]),p()},0)):(n.usingFrameTimeVector=!1,n.intervalId=setInterval(p,1e3/Math.abs(n.framesPerSecond)))}},t.stopClip=function(e){var t=(0,i.getToolState)(e,u);t&&t.data&&t.data.length&&s(t.data[0])}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),r=n(0),i=(a=r)&&a.__esModule?a:{default:a},l=n(2);var d=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.currentImageIdIndex=0,this.layerIds=[],this.findImageFn=void 0}return o(e,[{key:"render",value:function(e,t){var n=this;if(!Number.isInteger(this.currentImageIdIndex))throw new Error("FusionRenderer: render - Image ID Index is not an integer");if(!this.findImageFn)throw new Error("No findImage function has been defined");t||(t=(0,l.getToolState)(e,"stack").data);var a=i.default.cornerstone,o=t[0],r=o.imageIds[this.currentImageIdIndex],d=t.slice(1,t.length);a.loadAndCacheImage(r).then(function(t){var i=n.layerIds[0];i?a.setLayerImage(e,t,i):(i=a.addLayer(e,t,o.options),n.layerIds.push(i)),a.displayImage(e,t),d.forEach(function(t,o){var l=n.findImageFn(t.imageIds,r),d=o+1,u=n.layerIds[d];u||(u=a.addLayer(e,void 0,t.options),n.layerIds.push(u)),l?a.loadAndCacheImage(l).then(function(t){a.setLayerImage(e,t,u),a.updateImage(e)}):(a.setLayerImage(e,void 0,u),a.setActiveLayer(e,i),a.updateImage(e))})})}}]),e}();t.default=d},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=n(112),r=(a=o)&&a.__esModule?a:{default:a};var i={};i.FusionRenderer=r.default,t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=n(24),r=(a=o)&&a.__esModule?a:{default:a},i=n(2),l=n(3);var d=6;var u=(0,r.default)(function(e){var t=e.detail,n=t.element,a=t.enabledElement.canvas.width,o=t.enabledElement.canvas.height;if(!a||!o)return!1;var r=(0,l.getNewContext)(t.enabledElement.canvas);(0,l.draw)(r,function(e){var t=u.getConfiguration(),r=void 0;r="horizontal"===t.orientation?{left:0,top:o-d,width:a,height:d}:{left:0,top:0,width:d,height:o},(0,l.fillBox)(e,r,t.backgroundColor);var s=(0,i.getToolState)(n,"stack");if(s&&s.data&&s.data.length){var c=s.data[0].imageIds,f=s.data[0].currentImageIdIndex,v=a/c.length,g=o/c.length,m=v*f,h=g*f;r="horizontal"===t.orientation?{left:m,top:o-d,width:v,height:d}:{left:0,top:h,width:d,height:g},(0,l.fillBox)(e,r,t.fillColor)}})});u.setConfiguration({backgroundColor:"rgb(19, 63, 141)",fillColor:"white",orientation:"horizontal"}),t.default=u},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=u(n(1)),o=u(n(0)),r=u(n(44)),i=u(n(13)),l=n(2),d=n(33);function u(e){return e&&e.__esModule?e:{default:e}}var s="stackPrefetch",c="prefetch",f={maxImagesToPrefetch:1/0},v=void 0,g=10;var m=function(e){return Math.max.apply(null,e)},h=function(e){return Math.min.apply(null,e)};function p(e){var t=(0,l.getToolState)(e,"stack");if(t&&t.data&&t.data.length){var n=t.data[0],a=(0,l.getToolState)(e,s);if(a){var d=a.data[0]||{};if(d.indicesToRequest&&d.indicesToRequest.length||(d.enabled=!1),!1!==d.enabled)if(a.data[0].indicesToRequest.sort(function(e,t){return e-t}),d.indicesToRequest.slice().forEach(function(e){var t=n.imageIds[e];t&&(o.default.cornerstone.imageCache.getImageLoadObject(t)&&I(e))}),d.indicesToRequest.length){r.default.clearRequestStack(c);for(var u,v,g,p,E=(u=d.indicesToRequest,v=n.currentImageIdIndex,g=[],p=[],u.forEach(function(e){e<v?g.push(e):e>v&&p.push(e)}),{low:u.indexOf(m(g)),high:u.indexOf(h(p))}),T=void 0,y=void 0,M=i.default.getErrorLoadingHandler(),_=E.low,x=E.high;_>=0||x<d.indicesToRequest.length;){var b=n.currentImageIdIndex,S=b-d.indicesToRequest[_]>f.maxImagesToPrefetch,O=d.indicesToRequest[x]-b>f.maxImagesToPrefetch,C=!S&&_>=0,P=!O&&x<d.indicesToRequest.length;if(!P&&!C)break;C&&(y=d.indicesToRequest[_--],T=n.imageIds[y],r.default.addRequest(e,T,c,!1,L,w)),P&&(y=d.indicesToRequest[x++],T=n.imageIds[y],r.default.addRequest(e,T,c,!1,L,w))}r.default.startGrabbing()}}}function I(e){var t=d.indicesToRequest.indexOf(e);t>-1&&d.indicesToRequest.splice(t,1)}function L(e){I(n.imageIds.indexOf(e.imageId))}function w(t){console.log("prefetch errored: "+t),M&&M(e,T,t,"stackPrefetch")}}function E(e){return function(t){var n=t.detail,a=void 0;try{a=(0,l.getToolState)(e,"stack")}catch(e){return}if(a&&a.data&&a.data.length){var o=a.data[0].imageIds.indexOf(n.imageId);if(!(o<0)){var r=(0,l.getToolState)(e,s);r&&r.data&&r.data.length&&r.data[0].indicesToRequest.push(o)}}}}function T(e){clearTimeout(v),v=setTimeout(function(){var t=e.target;try{p(t)}catch(e){return}},g)}var y={enable:function(e){(0,l.getToolState)(e,s).data=[];var t=(0,l.getToolState)(e,"stack");if(t&&t.data&&t.data.length){var n=t.data[0];if(!0!==n.preventCache){var r={indicesToRequest:function(e,t){e=Math.round(e)||0;var n=[],a=(t=Math.round(t)||0)-e+1;if(a<=0)return n;for(;a--;)n[a]=t--;return n}(0,n.imageIds.length-1),enabled:!0,direction:1},i=r.indicesToRequest.indexOf(n.currentImageIdIndex);r.indicesToRequest.splice(i,1),(0,l.addToolState)(e,s,r),p(e),e.removeEventListener(a.default.NEW_IMAGE,T),e.addEventListener(a.default.NEW_IMAGE,T);var d=E(e);o.default.cornerstone.events.removeEventListener(a.default.IMAGE_CACHE_PROMISE_REMOVED,d),o.default.cornerstone.events.addEventListener(a.default.IMAGE_CACHE_PROMISE_REMOVED,d)}else console.warn("A stack that should not be cached was given the stackPrefetch")}},disable:function(e){clearTimeout(v),e.removeEventListener(a.default.NEW_IMAGE,T);var t=E(e);o.default.cornerstone.events.removeEventListener(a.default.IMAGE_CACHE_PROMISE_REMOVED,t);var n=(0,l.getToolState)(e,s);n&&n.data.length&&(n.data[0].enabled=!1,r.default.clearRequestStack(c))},getConfiguration:function(){return f},setConfiguration:function(e){f=e,e.maxSimultaneousRequests&&(0,d.setMaxSimultaneousRequests)(e.maxSimultaneousRequests)}};t.default=y},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.stackScrollMultiTouch=t.stackScrollTouchDrag=t.stackScrollWheel=t.stackScroll=void 0;var a=f(n(1)),o=f(n(18)),r=f(n(35)),i=f(n(14)),l=f(n(29)),d=f(n(5)),u=f(n(43)),s=n(2),c=n(4);function f(e){return e&&e.__esModule?e:{default:e}}var v="stackScroll";function g(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,m),t.removeEventListener(a.default.MOUSE_UP,g),t.removeEventListener(a.default.MOUSE_CLICK,g)}function m(e){var t=e.detail,n=t.element,a=(0,s.getToolState)(n,"stack");if(a&&a.data&&a.data.length){var o=a.data[0],r=h.getConfiguration(),i=!0;r&&void 0!==r.allowSkipping&&(i=r.allowSkipping);var l=Math.max(2,n.offsetHeight/Math.max(o.imageIds.length,8));r&&r.stackScrollSpeed&&(l=r.stackScrollSpeed);var d=(0,c.getToolOptions)(v,n),f=d.deltaY||0;if(f+=t.deltaPoints.page.y,Math.abs(f)>=l){var g=Math.round(f/l);(0,u.default)(n,g,!1,i),d.deltaY=f%l}else d.deltaY=f;(0,c.setToolOptions)(v,n,d),e.preventDefault(),e.stopPropagation()}}var h=(0,i.default)(function(e){var t=e.detail,n=t.element,o=(0,c.getToolOptions)(v,n);if((0,d.default)(t.which,o.mouseButtonMask))return o.deltaY=0,(0,c.setToolOptions)(v,n,o),n.addEventListener(a.default.MOUSE_DRAG,m),n.addEventListener(a.default.MOUSE_UP,g),n.addEventListener(a.default.MOUSE_CLICK,g),e.stopImmediatePropagation(),!1},v),p=(0,l.default)(function(e){var t=e.detail,n=-t.direction,a=h.getConfiguration(),o=!1,r=!0;a&&(o=void 0!==a.loop&&a.loop,r=void 0===a.allowSkipping||a.allowSkipping),(0,u.default)(t.element,n,o,r)}),E={eventData:{deltaY:0}},T=(0,o.default)(m,"stackScrollTouchDrag",E);var y=(0,r.default)(function(e){var t=e.detail,n=y.getConfiguration();n&&n.testPointers(t)&&m(e)},E);y.setConfiguration({testPointers:function(e){return e.numPointers>=3}}),t.stackScroll=h,t.stackScrollWheel=p,t.stackScrollTouchDrag=T,t.stackScrollMultiTouch=y},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(n(43));function o(e){return e&&e.__esModule?e:{default:e}}var r={UP:38,DOWN:40};var i=(0,o(n(61)).default)(function(e){var t=e.detail,n=t.keyCode;if(n===r.UP||n===r.DOWN){var o=1;n===r.DOWN&&(o=-1),(0,a.default)(t.element,o)}});t.default=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a},i=n(26),l=n(2);var d={save:function(e){var t={imageIdToolState:i.globalImageIdSpecificToolStateManager.saveToolState(),elementToolState:{},elementViewport:{}};return e.forEach(function(e){var n=(0,l.getElementToolStateManager)(e);n!==i.globalImageIdSpecificToolStateManager&&(t.elementToolState[e.id]=n.saveToolState(),t.elementViewport[e.id]=r.default.cornerstone.getViewport(e))}),t},restore:function(e){if(e.hasOwnProperty("imageIdToolState")&&e.hasOwnProperty("elementToolState")&&e.hasOwnProperty("elementViewport")){var t=r.default.cornerstone;return i.globalImageIdSpecificToolStateManager.restoreToolState(e.imageIdToolState),Object.keys(e.elementViewport).forEach(function(n){var a=document.getElementById(n);if(a&&e.elementToolState.hasOwnProperty(n)){var o=(0,l.getElementToolStateManager)(a);if(o!==i.globalImageIdSpecificToolStateManager){o.restoreToolState(e.elementToolState[n]);var r=e.elementViewport[n];t.setViewport(a,r),t.updateImage(a)}}}),e}}};t.default=d},function(e,t,n){"use strict";function a(){var e={};return{get:function(t,n){if(!1!==e.hasOwnProperty(t)){var a=e[t];if(!1!==a.hasOwnProperty(n))return a[n]}},add:function(t,n,a){!1===e.hasOwnProperty(t)&&(e[t]={});var o=e[t];!1===o.hasOwnProperty(n)&&(o[n]={data:[]}),o[n].data.push(a)},remove:function(t,n,a){if(!1!==e.hasOwnProperty(t)){var o=e[t];if(!1!==o.hasOwnProperty(n)){for(var r=o[n],i=-1,l=0;l<r.data.length;l++)r.data[l]===a&&(i=l);-1!==i&&r.data.splice(i,1)}}}}}Object.defineProperty(t,"__esModule",{value:!0});var o=a();t.newFrameOfReferenceSpecificToolStateManager=a,t.globalFrameOfReferenceSpecificToolStateManager=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.addStackStateManager=t.newStackSpecificToolStateManager=t.stackSpecificStateManager=void 0;var a=n(26),o=n(2);function r(e,t){var n={};return{get:function(a,o){return e.indexOf(o)>=0?(!1===n.hasOwnProperty(o)&&(n[o]={data:[]}),n[o]):t.get(a,o)},add:function(a,o,r){if(!(e.indexOf(o)>=0))return t.add(a,o,r);!1===n.hasOwnProperty(o)&&(n[o]={data:[]}),n[o].data.push(r)},saveToolState:function(){return n},restoreToolState:function(e){n=e},toolState:n}}var i=[];function l(e,t){var n=(0,o.getElementToolStateManager)(e);n||(n=a.globalImageIdSpecificToolStateManager);var l=["stack","stackPrefetch","playClip","volume","slab","referenceLines","crosshairs","stackRenderer"];t&&(l=l.concat(t));var d=r(l,n);i.push(d),(0,o.setElementToolStateManager)(e,d)}var d={newStackSpecificToolStateManager:r,addStackStateManager:l};t.stackSpecificStateManager=d,t.newStackSpecificToolStateManager=r,t.addStackStateManager=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.newTimeSeriesSpecificToolStateManager=t.addTimeSeriesStateManager=void 0;var a=n(26),o=n(2);function r(e,t){var n={};return{get:function(a,o){return e.indexOf(o)>=0?(!1===n.hasOwnProperty(o)&&(n[o]={data:[]}),n[o]):t.get(a,o)},add:function(a,o,r){if(!(e.indexOf(o)>=0))return t.add(a,o,r);!1===n.hasOwnProperty(o)&&(n[o]={data:[]}),n[o].data.push(r)}}}var i=[];t.addTimeSeriesStateManager=function(e,t){t=t||["timeSeries"];var n=(0,o.getElementToolStateManager)(e);void 0===n&&(n=a.globalImageIdSpecificToolStateManager);var l=r(t,n);i.push(l),(0,o.setElementToolStateManager)(e,l)},t.newTimeSeriesSpecificToolStateManager=r},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){if(n!==t){var a=r.default.cornerstone,o=a.getViewport(t),i=a.getViewport(n);i.scale===o.scale&&i.translation.x===o.translation.x&&i.translation.y===o.translation.y||(i.scale=o.scale,i.translation.x=o.translation.x,i.translation.y=o.translation.y,e.setViewport(n,i))}};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){if(n!==t){var l=a.default.cornerstone,d=(0,o.getToolState)(t,"stack").data[0],u=(0,o.getToolState)(n,"stack").data[0],s=d.currentImageIdIndex;if((s=(0,i.default)(s,0,u.imageIds.length-1))!==u.currentImageIdIndex){var c=r.default.getStartLoadHandler(),f=r.default.getEndLoadHandler(),v=r.default.getErrorLoadingHandler();c&&c(n);(!0===u.preventCache?l.loadImage(u.imageIds[s]):l.loadAndCacheImage(u.imageIds[s])).then(function(t){var a=l.getViewport(n);u.currentImageIdIndex=s,e.displayImage(n,t,a),f&&f(n,t)},function(e){var t=u.imageIds[s];v&&v(n,t,e)})}}};var a=l(n(0)),o=n(2),r=l(n(13)),i=l(n(8));function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,l,d){if(n!==t){var u=a.default.cornerstone,s=u.getEnabledElement(t),c=u.metaData.get("imagePlaneModule",s.image.imageId);if(void 0!==c&&void 0!==c.imagePositionPatient){var f=(0,i.default)(c.imagePositionPatient),v=(0,o.getToolState)(n,"stack").data[0],g=Number.MAX_VALUE,m=-1;if(d){var h=f.clone().add(d);if(v.imageIds.forEach(function(e,t){var n=u.metaData.get("imagePlaneModule",e);if(void 0!==n&&void 0!==n.imagePositionPatient){var a=(0,i.default)(n.imagePositionPatient),o=h.distanceToSquared(a);o<g&&(g=o,m=t)}}),m!==v.currentImageIdIndex&&-1!==m){var p=r.default.getStartLoadHandler(),E=r.default.getEndLoadHandler(),T=r.default.getErrorLoadingHandler();v.currentImageIdIndex=m;var y=v.imageIds[m];p&&p(n);(!0===v.preventCache?u.loadImage(y):u.loadAndCacheImage(y)).then(function(t){var a=u.getViewport(n);v.currentImageIdIndex===m&&(e.displayImage(n,t,a),E&&E(n,t))},function(e){var t=v.imageIds[m];T&&T(n,t,e)})}}}}};var a=l(n(0)),o=n(2),r=l(n(13)),i=l(n(19));function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){if(n!==t){var l=a.default.cornerstone,d=l.getEnabledElement(t).image,u=l.metaData.get("imagePlaneModule",d.imageId);if(void 0!==u&&void 0!==u.imagePositionPatient){var s=(0,i.default)(u.imagePositionPatient),c=(0,o.getToolState)(n,"stack").data[0],f=Number.MAX_VALUE,v=-1;if(c.imageIds.forEach(function(e,t){var n=l.metaData.get("imagePlaneModule",e);if(void 0!==n&&void 0!==n.imagePositionPatient){var a=(0,i.default)(n.imagePositionPatient).distanceToSquared(s);a<f&&(f=a,v=t)}}),v!==c.currentImageIdIndex){var g=r.default.getStartLoadHandler(),m=r.default.getEndLoadHandler(),h=r.default.getErrorLoadingHandler();c.currentImageIdIndex=v;var p=c.imageIds[v];if(g&&g(n),-1!==v){(!0===c.preventCache?l.loadImage(p):l.loadAndCacheImage(p)).then(function(t){var a=l.getViewport(n);c.currentImageIdIndex===v&&(e.displayImage(n,t,a),m&&m(n,t))},function(e){var t=c.imageIds[v];h&&h(n,t,e)})}}}}};var a=l(n(0)),o=n(2),r=l(n(13)),i=l(n(19));function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,l){if(t!==n&&l&&l.direction){var d=a.default.cornerstone,u=(0,o.getToolState)(n,"stack").data[0],s=u.currentImageIdIndex+l.direction;if(s=(0,i.default)(s,0,u.imageIds.length-1),u.currentImageIdIndex!==s){var c=r.default.getStartLoadHandler(),f=r.default.getEndLoadHandler(),v=r.default.getErrorLoadingHandler();u.currentImageIdIndex=s;var g=u.imageIds[s];c&&c(n);(!0===u.preventCache?d.loadImage(g):d.loadAndCacheImage(g)).then(function(t){var a=d.getViewport(n);u.currentImageIdIndex===s&&(e.displayImage(n,t,a),f&&f(n,t))},function(e){var t=u.imageIds[s];v&&v(n,t,e)})}}};var a=l(n(0)),o=n(2),r=l(n(13)),i=l(n(8));function l(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=l(n(1)),o=l(n(0)),r=l(n(19)),i=n(4);function l(e){return e&&e.__esModule?e:{default:e}}function d(e){return e.filter(function(e,t,n){return n.indexOf(e)===t})}t.default=function(e,t){var n=o.default.cornerstone,l=this,u=[],s=[],c=!1,f={},v=t;function g(e,t){l.enabled&&u.length&&s.length&&(c=!0,s.forEach(function(n){var a=s.indexOf(n);if(-1!==a){var o=f.imageIds.targetElements[a],r=u.indexOf(e);if(-1!==r){var i=f.imageIds.sourceElements[r],d=void 0;i===o?d=0:void 0!==f.distances[i]&&(d=f.distances[i][o]),v(l,e,n,t,d)}}}),c=!1)}function m(e){var t=e.detail;!0!==c&&g(e.currentTarget,t)}function h(e){var t=e.detail.element;l.remove(t),(0,i.clearToolOptionsByElement)(t)}this.enabled=!0,this.setHandler=function(e){v=e},this.getHandler=function(){return v},this.getDistances=function(){u.length&&s.length&&(f.distances={},f.imageIds={sourceElements:[],targetElements:[]},u.forEach(function(e){var t=n.getEnabledElement(e);if(t&&t.image){var a=t.image.imageId,o=n.metaData.get("imagePlaneModule",a);if(o&&o.imagePositionPatient){var i=(0,r.default)(o.imagePositionPatient);f.hasOwnProperty(t)||(f.distances[a]={},f.imageIds.sourceElements.push(a),s.forEach(function(t){var o=n.getEnabledElement(t);if(o&&o.image){var l=o.image.imageId;if(f.imageIds.targetElements.push(l),e!==t&&a!==l&&!f.distances[a].hasOwnProperty(l)){var d=n.metaData.get("imagePlaneModule",l);if(d&&d.imagePositionPatient){var u=(0,r.default)(d.imagePositionPatient);f.distances[a][l]=u.clone().sub(i)}}}}),Object.keys(f.distances[a]).length||delete f.distances[a])}}}))},this.addSource=function(t){-1===u.indexOf(t)&&(u.push(t),e.split(" ").forEach(function(e){t.addEventListener(e,m)}),l.getDistances(),l.updateDisableHandlers())},this.addTarget=function(e){-1===s.indexOf(e)&&(s.push(e),l.getDistances(),v(l,e,e,0),l.updateDisableHandlers())},this.add=function(e){l.addSource(e),l.addTarget(e)},this.removeSource=function(t){var n=u.indexOf(t);-1!==n&&(u.splice(n,1),e.split(" ").forEach(function(e){t.removeEventListener(e,m)}),l.getDistances(),g(t),l.updateDisableHandlers())},this.removeTarget=function(e){var t=s.indexOf(e);-1!==t&&(s.splice(t,1),l.getDistances(),v(l,e,e,0),l.updateDisableHandlers())},this.remove=function(e){l.removeTarget(e),l.removeSource(e)},this.getSourceElements=function(){return u},this.getTargetElements=function(){return s},this.displayImage=function(e,t,a){c=!0,n.displayImage(e,t,a),c=!1},this.setViewport=function(e,t){c=!0,n.setViewport(e,t),c=!1},this.updateDisableHandlers=function(){d(u.concat(s)).forEach(function(e){e.removeEventListener(a.default.ELEMENT_DISABLED,h),e.addEventListener(a.default.ELEMENT_DISABLED,h)})},this.destroy=function(){d(u.concat(s)).forEach(function(e){l.remove(e)})}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){n!==t&&r.default.cornerstone.updateImage(n)};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){if(n!==t){var a=r.default.cornerstone,o=a.getViewport(t),i=a.getViewport(n);i.voi.windowWidth===o.voi.windowWidth&&i.voi.windowCenter===o.voi.windowCenter&&i.invert===o.invert||(i.voi.windowWidth=o.voi.windowWidth,i.voi.windowCenter=o.voi.windowCenter,i.invert=o.invert,e.setViewport(n,i))}};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.timeSeriesScrollTouchDrag=t.timeSeriesScrollWheel=t.timeSeriesScroll=void 0;var a=c(n(1)),o=c(n(14)),r=c(n(18)),i=c(n(29)),l=c(n(36)),d=c(n(5)),u=n(2),s=n(4);function c(e){return e&&e.__esModule?e:{default:e}}var f="timeSeriesScroll";function v(e){var t=e.detail.element;t.removeEventListener(a.default.MOUSE_DRAG,g),t.removeEventListener(a.default.MOUSE_UP,v),t.removeEventListener(a.default.MOUSE_CLICK,v)}function g(e){var t=e.detail,n=t.element;e.data.deltaY+=t.deltaPoints.page.y;var a=(0,u.getToolState)(t.element,"timeSeries");if(void 0!==a&&void 0!==a.data&&0!==a.data.length){var o=a.data[0],r=n.offsetHeight/o.stacks.length;if(void 0!==e.data.options&&void 0!==e.data.options.timeSeriesScrollSpeed&&(r=e.data.options.timeSeriesScrollSpeed),e.data.deltaY>=r||e.data.deltaY<=-r){var i=Math.round(e.data.deltaY/r),d=e.data.deltaY%r;(0,l.default)(t.element,i),e.data.deltaY=d}return!1}}var m=(0,o.default)(function(e){var t=e.detail,n=t.element,o=(0,s.getToolOptions)(f,n);if((0,d.default)(t.which,o.mouseButtonMask))return o.deltaY=0,(0,s.setToolOptions)(f,n,o),n.addEventListener(a.default.MOUSE_DRAG,g),n.addEventListener(a.default.MOUSE_UP,v),n.addEventListener(a.default.MOUSE_CLICK,v),e.stopImmediatePropagation(),!1},f),h=(0,i.default)(function(e){var t=e.detail,n=-t.direction;(0,l.default)(t.element,n)}),p=(0,r.default)(function(e){var t=e.originalEvent.detail,n={deltaY:0};n.deltaY+=t.deltaPoints.page.y;var a=(0,u.getToolState)(t.element,"stack");if(void 0!==a&&void 0!==a.data&&0!==a.data.length){if(n.deltaY>=3||n.deltaY<=-3){var o=n.deltaY/3,r=n.deltaY%3;(0,l.default)(n.element,o),n.deltaY=r}return!1}});t.timeSeriesScroll=m,t.timeSeriesScrollWheel=h,t.timeSeriesScrollTouchDrag=p},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,o=n(2),r=n(36),i=(a=r)&&a.__esModule?a:{default:a};var l="timeSeriesPlayer";var d={start:function(e,t){if(void 0===e)throw new Error("playClip: element must not be undefined");void 0===t&&(t=30);var n=(0,o.getToolState)(e,"timeSeries");if(void 0!==n&&void 0!==n.data&&0!==n.data.length){var a=(0,o.getToolState)(e,l),r=void 0;void 0===a||0===a.data.length?(r={intervalId:void 0,framesPerSecond:t,lastFrameTimeStamp:void 0,frameRate:0},(0,o.addToolState)(e,l,r)):(r=a.data[0]).framesPerSecond=t,void 0===r.intervalId&&(r.intervalId=setInterval(function(){r.framesPerSecond>0?(0,i.default)(e,1,!0):(0,i.default)(e,-1,!0)},1e3/Math.abs(r.framesPerSecond)))}},stop:function(e){var t=(0,o.getToolState)(e,l);if(t&&t.data&&t.data.length){var n=t.data[0];clearInterval(n.intervalId),n.intervalId=void 0}}};t.default=d},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){var e=o.default.cornerstone,t=this;t.samples=[],this.set=function(n){t.samples=n,(0,r.default)(e.events,a.default.LINE_SAMPLE_UPDATED)}};var a=i(n(1)),o=i(n(0)),r=i(n(6));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=i(n(1)),o=i(n(0)),r=i(n(6));function i(e){return e&&e.__esModule?e:{default:e}}var l=new function(){var e=o.default.cornerstone,t=this;t.measurements=[],this.add=function(n){var o={index:t.measurements.push(n),measurement:n};(0,r.default)(e.events,a.default.MEASUREMENT_ADDED,o)},this.remove=function(n){var o=t.measurements[n];t.measurements.splice(n,1);var i={index:n,measurement:o};(0,r.default)(e.events,a.default.MEASUREMENT_REMOVED,i)}};t.default=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=c(n(0)),o=c(n(10)),r=c(n(9)),i=n(2),l=c(n(133)),d=c(n(132)),u=c(n(11)),s=n(3);function c(e){return e&&e.__esModule?e:{default:e}}var f="probe4D";var v=(0,o.default)({createNewMeasurement:function(e){var t=(0,i.getToolState)(e.element,"timeSeries");if(void 0!==t&&void 0!==t.data&&0!==t.data.length){var n=t.data[0],o={timeSeries:n,lineSample:new d.default,imageIdIndex:n.stacks[n.currentStackIndex].currentImageIdIndex,visible:!0,handles:{end:{x:e.currentPoints.image.x,y:e.currentPoints.image.y,highlight:!0,active:!0}}};return function(e){var t=a.default.cornerstone,n=[];e.timeSeries.stacks.forEach(function(a){(!0===a.preventCache?t.loadImage(a.imageIds[e.imageIdIndex]):t.loadAndCacheImage(a.imageIds[e.imageIdIndex])).then(function(t){var a=Math.round(e.handles.end.x)+Math.round(e.handles.end.y)*t.width,o=t.getPixelData()[a];n.push(o)})}),e.lineSample.set(n)}(o),l.default.add(o),o}},onImageRendered:function(e){var t=a.default.cornerstone,n=e.detail,o=(0,i.getToolState)(e.currentTarget,f);if(o){var l=n.canvasContext;l.setTransform(1,0,0,1,0,0);for(var d=function(e){(0,s.draw)(l,function(a){var i=o.data[e];(0,r.default)(a,n,i.handles,"white");var l={x:i.handles.end.x+3,y:i.handles.end.y-3},d=t.pixelToCanvas(n.element,l);(0,u.default)(a,i.handles.end.x+", "+i.handles.end.y,d.x,d.y,"white")})},c=0;c<o.data.length;c++)d(c)}},toolType:f});t.default=v},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,o){var r={color:n,lineWidth:o};(0,a.drawCircle)(e,void 0,t,6,r,"canvas")};var a=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n,o,r){var i={x:t,y:n},l={x:t+o,y:n+r};(0,a.drawEllipse)(e,void 0,i,l,{},"canvas")};var a=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){e.style.webkitUserSelect="none",e.style.webkitTouchCallout="none",e.style.mozUserSelect="none",e.style.msUserSelect="none",e.style.oUserSelect="none",e.style.khtmlUserSelect="none",e.style.userSelect="none",e.unselectable="on",e.oncontextmenu=function(){return!1},!0===t&&(e.style.pointerEvents="none")}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){return r.default.cornerstone.setToPixelCoordinateSystem(e,t,.1),{fontSize:n/e.viewport.scale/.1,lineHeight:n/e.viewport.scale/.1,fontScale:.1}};var a,o=n(0),r=(a=o)&&a.__esModule?a:{default:a}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.replace("H","f");return t=(t=(t=(t=(t=(t=t.replace("F","h")).replace("R","l")).replace("L","r")).replace("A","p")).replace("P","a")).toUpperCase()}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){for(var t=(0,o.default)(e),n="",r=t.x<0?"R":"L",i=t.y<0?"A":"P",l=t.z<0?"F":"H",d=new a.default.cornerstoneMath.Vector3(Math.abs(t.x),Math.abs(t.y),Math.abs(t.z)),u=0;u<3;u++)if(d.x>1e-4&&d.x>d.y&&d.x>d.z)n+=r,d.x=0;else if(d.y>1e-4&&d.y>d.x&&d.y>d.z)n+=i,d.y=0;else{if(!(d.z>1e-4&&d.z>d.x&&d.z>d.y))break;n+=l,d.z=0}return n};var a=r(n(0)),o=r(n(19));function r(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=l(n(1)),o=l(n(0)),r=n(2),i=l(n(67));function l(e){return e&&e.__esModule?e:{default:e}}var d="referenceLines";function u(e){var t=e.detail,n=(0,r.getToolState)(e.currentTarget,d);if(void 0!==n){var a=n.data[0].synchronizationContext.getSourceElements(),i=n.data[0].renderer,l=t.canvasContext.canvas.getContext("2d");o.default.cornerstone.setToPixelCoordinateSystem(t.enabledElement,l),a.forEach(function(n){n!==e.currentTarget&&i(l,t,e.currentTarget,n)})}}var s={enable:function(e,t,n){n=n||i.default,(0,r.addToolState)(e,d,{synchronizationContext:t,renderer:n}),e.removeEventListener(a.default.IMAGE_RENDERED,u),e.addEventListener(a.default.IMAGE_RENDERED,u),o.default.cornerstone.updateImage(e)},disable:function(e){e.removeEventListener(a.default.IMAGE_RENDERED,u),o.default.cornerstone.updateImage(e)}};t.default=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=i(n(68)),o=i(n(141)),r=i(n(67));function i(e){return e&&e.__esModule?e:{default:e}}var l={calculateReferenceLine:a.default,tool:o.default,renderActiveReferenceLine:r.default};t.default=l}])});
//# sourceMappingURL=cornerstoneTools.min.js.map
},{}],5:[function(require,module,exports){
/*! cornerstone-wado-image-loader - 2.1.4 - 2018-07-11 | (c) 2016 Chris Hafey | https://github.com/cornerstonejs/cornerstoneWADOImageLoader */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("cornerstoneWADOImageLoader",[],t):"object"==typeof exports?exports.cornerstoneWADOImageLoader=t():e.cornerstoneWADOImageLoader=t()}(this,function(){return function(e){var t={};function r(a){if(t[a])return t[a].exports;var n=t[a]={i:a,l:!1,exports:{}};return e[a].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,a){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},r.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=63)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(56),o=(a=n)&&a.__esModule?a:{default:a};var i=void 0,l=void 0,u={set cornerstone(e){i=e,(0,o.default)(i)},get cornerstone(){if(!i){if(!window||!window.cornerstone)throw new Error("cornerstoneWADOImageLoader requires a copy of Cornerstone to work properly. Please add cornerstoneWADOImageLoader.external.cornerstone = cornerstone; to your application.");i=window.cornerstone,(0,o.default)(i)}return i},set dicomParser(e){l=e},get dicomParser(){if(!l){if(!window||!window.dicomParser)throw new Error("cornerstoneWADOImageLoader requires a copy of dicomParser to work properly. Please add cornerstoneWADOImageLoader.external.dicomParser = dicomParser; to your application.");l=window.dicomParser}return l}};t.default=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){for(var t=e[0],r=e[0],a=void 0,n=e.length,o=1;o<n;o++)a=e[o],t=Math.min(t,a),r=Math.max(r,a);return{min:t,max:r}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=void 0;function n(e,t){var r=function(e,t,r){var n=a._malloc(e.length);a.writeArrayToMemory(e,n);var o=a._malloc(4),i=a._malloc(4),l=a._malloc(4),u=a._malloc(4),d=a._malloc(4),s=(new Date).getTime();if(0!==a.ccall("jp2_decode","number",["number","number","number","number","number","number","number"],[n,e.length,o,i,l,u,d]))return console.log("[opj_decode] decoding failed!"),a._free(n),a._free(a.getValue(o,"*")),a._free(l),a._free(u),a._free(i),void a._free(d);var f=a.getValue(o,"*"),c={length:a.getValue(i,"i32"),sx:a.getValue(l,"i32"),sy:a.getValue(u,"i32"),nbChannels:a.getValue(d,"i32"),perf_timetodecode:void 0,pixelData:void 0},p=c.sx*c.sy*c.nbChannels,m=new Int32Array(a.HEAP32.buffer,f,p);if(1===t)if(Uint8Array.from)c.pixelData=Uint8Array.from(m);else{c.pixelData=new Uint8Array(p);for(var g=0;g<p;g++)c.pixelData[g]=m[g]}else if(r)if(Int16Array.from)c.pixelData=Int16Array.from(m);else{c.pixelData=new Int16Array(p);for(var v=0;v<p;v++)c.pixelData[v]=m[v]}else if(Uint16Array.from)c.pixelData=Uint16Array.from(m);else{c.pixelData=new Uint16Array(p);for(var b=0;b<p;b++)c.pixelData[b]=m[b]}var x=(new Date).getTime();return c.perf_timetodecode=x-s,a._free(n),a._free(o),a._free(f),a._free(i),a._free(l),a._free(u),a._free(d),c}(t,e.bitsAllocated<=8?1:2,1===e.pixelRepresentation);return e.columns=r.sx,e.rows=r.sy,e.pixelData=r.pixelData,r.nbChannels>1&&(e.photometricInterpretation="RGB"),e}function o(e){if(!e.usePDFJS&&"undefined"==typeof OpenJPEG)throw new Error("OpenJPEG decoder not loaded");if(!(a||(a=OpenJPEG())&&a._jp2_decode))throw new Error("OpenJPEG failed to initialize")}t.default=function(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return o(r),a.usePDFJS||r.usePDFJS?function(e,t){var r=new JpxImage;r.parse(t);var a=r.tiles.length;if(1!==a)throw new Error("JPEG2000 decoder returned a tileCount of "+a+", when 1 is expected");return e.columns=r.width,e.rows=r.height,e.pixelData=r.tiles[0].items,e}(e,t):n(e,t)},t.initializeJPEG2000=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=void 0;function n(){if("undefined"==typeof CharLS)throw new Error("No JPEG-LS decoder loaded");if(!(a||(a=CharLS())&&a._jpegls_decode))throw new Error("JPEG-LS failed to initialize")}t.default=function(e,t){n();var r=function(e,t){var r=a._malloc(e.length);a.writeArrayToMemory(e,r);var n=a._malloc(4),o=a._malloc(4),i=a._malloc(4),l=a._malloc(4),u=a._malloc(4),d=a._malloc(4),s=a._malloc(4),f=a._malloc(4),c=a._malloc(4),p={result:a.ccall("jpegls_decode","number",["number","number","number","number","number","number","number","number","number","number","number"],[r,e.length,n,o,i,l,u,d,f,s,c]),width:a.getValue(i,"i32"),height:a.getValue(l,"i32"),bitsPerSample:a.getValue(u,"i32"),stride:a.getValue(d,"i32"),components:a.getValue(f,"i32"),allowedLossyError:a.getValue(s,"i32"),interleaveMode:a.getValue(c,"i32"),pixelData:void 0},m=a.getValue(n,"*");return p.bitsPerSample<=8?(p.pixelData=new Uint8Array(p.width*p.height*p.components),p.pixelData.set(new Uint8Array(a.HEAP8.buffer,m,p.pixelData.length))):t?(p.pixelData=new Int16Array(p.width*p.height*p.components),p.pixelData.set(new Int16Array(a.HEAP16.buffer,m,p.pixelData.length))):(p.pixelData=new Uint16Array(p.width*p.height*p.components),p.pixelData.set(new Uint16Array(a.HEAP16.buffer,m,p.pixelData.length))),a._free(r),a._free(m),a._free(n),a._free(o),a._free(i),a._free(l),a._free(u),a._free(d),a._free(f),a._free(c),p}(t,1===e.pixelRepresentation);if(0!==r.result&&6!==r.result)throw new Error("JPEG-LS decoder failed to decode frame (error code "+r.result+")");return e.columns=r.width,e.rows=r.height,e.pixelData=r.pixelData,e},t.initializeJPEGLS=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.internal=t.xhrRequest=t.getOptions=t.setOptions=void 0;var a,n=r(53),o=(a=n)&&a.__esModule?a:{default:a},i=r(6);var l={xhrRequest:o.default,setOptions:i.setOptions,getOptions:i.getOptions};t.setOptions=i.setOptions,t.getOptions=i.getOptions,t.xhrRequest=o.default,t.internal=l},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.indexOf(":"),r=e.substring(t+1),a=r.indexOf("frame="),n=void 0;if(-1!==a){var o=r.substr(a+6);n=parseInt(o,10),r=r.substr(0,a-1)}return{scheme:e.substr(0,t),url:r,frame:n}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setOptions=function(e){a=Object.assign(a,e)},t.getOptions=function(){return a};var a={beforeSend:function(){},imageCreated:function(){},strict:!1,useWebWorkers:!0,decodeConfig:{usePDFJS:!1}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){return t=t||0,e&&e.Value?e.Value.length<=t?r:e.Value[t]:r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default="2.1.4"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getInfo=s;var a,n=r(0),o=(a=n)&&a.__esModule?a:{default:a},i=r(4);var l=0,u={},d={};function s(){return{cacheSizeInBytes:l,numberOfDataSetsCached:Object.keys(u).length}}t.default={isLoaded:function(e){return void 0!==u[e]},load:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.xhrRequest,r=arguments[2],a=o.default.cornerstone,n=o.default.dicomParser;if(u[e])return new Promise(function(t){u[e].cacheCount++,t(u[e].dataSet)});if(d[e])return d[e].cacheCount++,d[e];var f=t(e,r),c=new Promise(function(t,r){f.then(function(o){var i=new Uint8Array(o),d=void 0;try{d=n.parseDicom(i)}catch(e){return r(e)}u[e]={dataSet:d,cacheCount:c.cacheCount},l+=d.byteArray.length,t(d),a.triggerEvent(a.events,"datasetscachechanged",{uri:e,action:"loaded",cacheInfo:s()})},r).then(function(){delete d[e]},function(){delete d[e]})});return c.cacheCount=1,d[e]=c,c},unload:function(e){var t=o.default.cornerstone;u[e]&&(u[e].cacheCount--,0===u[e].cacheCount&&(l-=u[e].dataSet.byteArray.length,delete u[e],t.triggerEvent(t.events,"datasetscachechanged",{uri:e,action:"unloaded",cacheInfo:s()})))},getInfo:s,purge:function(){u={},d={}},get:function(e){if(u[e])return u[e].dataSet}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=(0,o.default)(e.pixelData),a=!(i(e.smallestPixelValue)&&i(e.largestPixelValue));!0!==t||a?(e.smallestPixelValue=r.min,e.largestPixelValue=r.max):(e.smallestPixelValue!==r.min&&console.warn("Image smallestPixelValue tag is incorrect. Rendering performance will suffer considerably."),e.largestPixelValue!==r.max&&console.warn("Image largestPixelValue tag is incorrect. Rendering performance will suffer considerably."))};var a,n=r(1),o=(a=n)&&a.__esModule?a:{default:a};function i(e){return"number"==typeof e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if("undefined"==typeof jpeg||void 0===jpeg.lossless||void 0===jpeg.lossless.Decoder)throw new Error("No JPEG Lossless decoder loaded");var r=e.bitsAllocated<=8?1:2,a=t.buffer,n=(new jpeg.lossless.Decoder).decode(a,t.byteOffset,t.length,r);return 0===e.pixelRepresentation?16===e.bitsAllocated?(e.pixelData=new Uint16Array(n.buffer),e):(e.pixelData=new Uint8Array(n.buffer),e):(e.pixelData=new Int16Array(n.buffer),e)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if("undefined"==typeof JpegImage)throw new Error("No JPEG Baseline decoder loaded");var r=new JpegImage;return r.parse(t),r.colorTransform=!1,8===e.bitsAllocated?(e.pixelData=r.getData(e.columns,e.rows),e):16===e.bitsAllocated?(e.pixelData=r.getData16(e.columns,e.rows),e):void 0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(8===e.bitsAllocated)return e.planarConfiguration?function(e,t){for(var r=t,a=e.rows*e.columns,n=new ArrayBuffer(a*e.samplesPerPixel),o=new DataView(r.buffer,r.byteOffset),i=new Int8Array(r.buffer,r.byteOffset),l=new Int8Array(n),u=0,d=o.getInt32(0,!0),s=0;s<d;++s){u=s*a;var f=o.getInt32(4*(s+1),!0),c=o.getInt32(4*(s+2),!0);0===c&&(c=r.length);for(var p=a*d;f<c;){var m=i[f++];if(m>=0&&m<=127)for(var g=0;g<m+1&&u<p;++g)l[u]=i[f++],u++;else if(m<=-1&&m>=-127)for(var v=i[f++],b=0;b<1-m&&u<p;++b)l[u]=v,u++}}return e.pixelData=new Uint8Array(n),e}(e,t):function(e,t){for(var r=t,a=e.rows*e.columns,n=new ArrayBuffer(a*e.samplesPerPixel),o=new DataView(r.buffer,r.byteOffset),i=new Int8Array(r.buffer,r.byteOffset),l=new Int8Array(n),u=0,d=o.getInt32(0,!0),s=0;s<d;++s){u=s;var f=o.getInt32(4*(s+1),!0),c=o.getInt32(4*(s+2),!0);0===c&&(c=r.length);for(var p=a*d;f<c;){var m=i[f++];if(m>=0&&m<=127)for(var g=0;g<m+1&&u<p;++g)l[u]=i[f++],u+=e.samplesPerPixel;else if(m<=-1&&m>=-127)for(var v=i[f++],b=0;b<1-m&&u<p;++b)l[u]=v,u+=e.samplesPerPixel}}return e.pixelData=new Uint8Array(n),e}(e,t);if(16===e.bitsAllocated)return function(e,t){for(var r=t,a=e.rows*e.columns,n=new ArrayBuffer(a*e.samplesPerPixel*2),o=new DataView(r.buffer,r.byteOffset),i=new Int8Array(r.buffer,r.byteOffset),l=new Int8Array(n),u=o.getInt32(0,!0),d=0;d<u;++d){var s=0,f=0===d?1:0,c=o.getInt32(4*(d+1),!0),p=o.getInt32(4*(d+2),!0);for(0===p&&(p=r.length);c<p;){var m=i[c++];if(m>=0&&m<=127)for(var g=0;g<m+1&&s<a;++g)l[2*s+f]=i[c++],s++;else if(m<=-1&&m>=-127)for(var v=i[c++],b=0;b<1-m&&s<a;++b)l[2*s+f]=v,s++}}return 0===e.pixelRepresentation?e.pixelData=new Uint16Array(n):e.pixelData=new Int16Array(n),e}(e,t);throw new Error("unsupported pixel format for RLE")}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(16===e.bitsAllocated){var r=t.buffer,a=t.byteOffset,n=t.length;a%2&&(r=r.slice(a),a=0),0===e.pixelRepresentation?e.pixelData=new Uint16Array(r,a,n/2):e.pixelData=new Int16Array(r,a,n/2);for(var o=0;o<e.pixelData.length;o++)e.pixelData[o]=(255&(i=e.pixelData[o]))<<8|i>>8&255}else 8===e.bitsAllocated&&(e.pixelData=t);var i;return e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var r=t.buffer,a=t.byteOffset,n=t.length;return 16===e.bitsAllocated?(a%2&&(r=r.slice(a),a=0),0===e.pixelRepresentation?e.pixelData=new Uint16Array(r,a,n/2):e.pixelData=new Int16Array(r,a,n/2)):8===e.bitsAllocated||1===e.bitsAllocated?e.pixelData=t:32===e.bitsAllocated&&(a%2&&(r=r.slice(a),a=0),e.pixelData=new Float32Array(r,a,n/4)),e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=s(r(15)),n=s(r(14)),o=s(r(13)),i=s(r(12)),l=s(r(11)),u=s(r(3)),d=s(r(2));function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e,t,r,s,f){var c=(new Date).getTime();if("1.2.840.10008.1.2"===t)e=(0,a.default)(e,r);else if("1.2.840.10008.1.2.1"===t)e=(0,a.default)(e,r);else if("1.2.840.10008.1.2.2"===t)e=(0,n.default)(e,r);else if("1.2.840.10008.1.2.1.99"===t)e=(0,a.default)(e,r);else if("1.2.840.10008.1.2.5"===t)e=(0,o.default)(e,r);else if("1.2.840.10008.1.2.4.50"===t)e=(0,i.default)(e,r);else if("1.2.840.10008.1.2.4.51"===t)e=(0,i.default)(e,r);else if("1.2.840.10008.1.2.4.57"===t)e=(0,l.default)(e,r);else if("1.2.840.10008.1.2.4.70"===t)e=(0,l.default)(e,r);else if("1.2.840.10008.1.2.4.80"===t)e=(0,u.default)(e,r);else if("1.2.840.10008.1.2.4.81"===t)e=(0,u.default)(e,r);else if("1.2.840.10008.1.2.4.90"===t)e=(0,d.default)(e,r,s,f);else{if("1.2.840.10008.1.2.4.91"!==t)throw new Error("no decoder for transfer syntax "+t);e=(0,d.default)(e,r,s,f)}var p=void 0!==e.pixelRepresentation&&1===e.pixelRepresentation,m=p&&void 0!==e.bitsStored?32-e.bitsStored:void 0;if(p&&void 0!==m)for(var g=0;g<e.pixelData.length;g++)e.pixelData[g]=e.pixelData[g]<<m>>m;var v=(new Date).getTime();return e.decodeTimeInMS=v-c,e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=s(r(0)),n=s(r(31)),o=s(r(30)),i=s(r(27)),l=s(r(26)),u=s(r(1)),d=s(r(25));function s(e){return e&&e.__esModule?e:{default:e}}var f="";t.default=function(e,t,r,s){if(!t||!t.length)return Promise.reject(new Error("The file does not contain image data."));var c=a.default.cornerstone,p=document.createElement("canvas"),m=(0,n.default)(e),g=(0,o.default)(m,r,t,p,s);return new Promise(function(t,a){g.then(function(a){var n=c.metaData.get("imagePlaneModule",e)||{},o=c.metaData.get("voiLutModule",e)||{},s=c.metaData.get("modalityLutModule",e)||{},m=c.metaData.get("sopCommonModule",e)||{},g=(0,i.default)(a.photometricInterpretation);if(!(0,d.default)(a,r)&&(function(e){32===e.bitsAllocated?e.pixelData=new Float32Array(e.pixelData):16===e.bitsAllocated?0===e.pixelRepresentation?e.pixelData=new Uint16Array(e.pixelData):e.pixelData=new Int16Array(e.pixelData):e.pixelData=new Uint8Array(e.pixelData)}(a),g)){p.height=a.rows,p.width=a.columns;var v=p.getContext("2d").createImageData(a.columns,a.rows);(0,l.default)(a,v),a.imageData=v,a.pixelData=v.data;var b=(0,u.default)(a.pixelData);a.smallestPixelValue=b.min,a.largestPixelValue=b.max}var x,P={imageId:e,color:g,columnPixelSpacing:n.pixelSpacing?n.pixelSpacing[1]:void 0,columns:a.columns,height:a.rows,intercept:s.rescaleIntercept?s.rescaleIntercept:0,invert:"MONOCHROME1"===a.photometricInterpretation,minPixelValue:a.smallestPixelValue,maxPixelValue:a.largestPixelValue,rowPixelSpacing:n.pixelSpacing?n.pixelSpacing[0]:void 0,rows:a.rows,sizeInBytes:a.pixelData.length,slope:s.rescaleSlope?s.rescaleSlope:1,width:a.columns,windowCenter:o.windowCenter?o.windowCenter[0]:void 0,windowWidth:o.windowWidth?o.windowWidth[0]:void 0,decodeTimeInMS:a.decodeTimeInMS,floatPixelData:void 0};if(a.pixelData instanceof Float32Array){var y=a.pixelData,h=function(e){for(var t=(0,u.default)(e),r=Math.abs(t.max-t.min)/65535,a=t.min,n=e.length,o=new Uint16Array(n),i=65535,l=0,d=0;d<n;d++){var s=Math.floor((e[d]-a)/r);o[d]=s,i=Math.min(i,s),l=Math.max(l,s)}return{min:i,max:l,intPixelData:o,slope:r,intercept:a}}(y);P.minPixelValue=h.min,P.maxPixelValue=h.max,P.slope=h.slope,P.intercept=h.intercept,P.floatPixelData=y,P.getPixelData=function(){return h.intPixelData}}else P.getPixelData=function(){return a.pixelData};if(P.color&&(P.getCanvas=function(){return f===e?p:(p.height=P.rows,p.width=P.columns,p.getContext("2d").putImageData(a.imageData,0,0),f=e,p)}),s.modalityLUTSequence&&s.modalityLUTSequence.length>0&&"1.2.840.10008.5.1.4.1.1.12.1"!==(x=m.sopClassUID)&&"1.2.840.10008.5.1.4.1.1.12.2.1"!==x&&(P.modalityLUT=s.modalityLUTSequence[0]),o.voiLUTSequence&&o.voiLUTSequence.length>0&&(P.voiLUT=o.voiLUTSequence[0]),P.color&&(P.windowWidth=255,P.windowCenter=127),void 0===P.windowCenter||void 0===P.windowWidth){var w=P.maxPixelValue*P.slope+P.intercept,_=P.minPixelValue*P.slope+P.intercept;P.windowWidth=w-_,P.windowCenter=(w+_)/2}t(P)},a)})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=[];t.default={add:function(e,t){a[e]=t},get:function(e){return a[e]},remove:function(e){a[e]=void 0},purge:function(){a=[]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.loadImage=t.getLoaderForScheme=t.loadImageFromPromise=void 0;var a=d(r(17)),n=d(r(5)),o=d(r(9)),i=d(r(20)),l=d(r(51)),u=r(4);function d(e){return e&&e.__esModule?e:{default:e}}function s(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments[3],u=arguments[4],d=arguments[5],s=(new Date).getTime(),f={cancelFn:void 0};return f.promise=new Promise(function(c,p){e.then(function(e){var m=(0,l.default)(e,r),g=e.string("x00020010"),v=(new Date).getTime(),b=(0,a.default)(t,m,g,u);!function(e,t){e.decache=function(){var e=(0,n.default)(t);o.default.unload(e.url)}}(f,t),b.then(function(t){t.data=e,t.sharedCacheKey=i;var r=(new Date).getTime();t.loadTimeInMS=v-s,t.totalTimeInMS=r-s,void 0!==d&&void 0!==d.imageDoneCallback&&d.imageDoneCallback(t),c(t)},function(t){p({error:t,dataSet:e})})},function(e){p({error:e})})}),f}function f(e){return"dicomweb"===e||"wadouri"===e?u.xhrRequest:"dicomfile"===e?i.default:void 0}t.loadImageFromPromise=s,t.getLoaderForScheme=f,t.loadImage=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=(0,n.default)(e),i=t.loader;return void 0===i&&(i=f(r.scheme)),o.default.isLoaded(r.url)?function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments[3],o=arguments[4],i=(new Date).getTime();return{promise:new Promise(function(u,d){var s=(new Date).getTime(),f=void 0;try{var c=(0,l.default)(e,r),p=e.string("x00020010");f=(0,a.default)(t,c,p,o)}catch(t){return void d({error:t,dataSet:e})}f.then(function(t){t.data=e,t.sharedCacheKey=n;var r=(new Date).getTime();t.loadTimeInMS=s-i,t.totalTimeInMS=r-i,u(t)},d)}),cancelFn:void 0}}(o.default.get(r.url,i,e),e,r.frame,r.url,t):s(o.default.load(r.url,i,e),e,r.frame,r.url,t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(r(5)),n=o(r(24));function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=(0,a.default)(e),r=parseInt(t.url,10),o=n.default.get(r);return new Promise(function(e,t){var r=new FileReader;r.onload=function(t){var r=t.target.result;e(r)},r.onerror=t,r.readAsArrayBuffer(o)})}},function(e,t,r){"use strict";function a(e,t){return e&1<<t}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){for(var n=new Uint8Array(r),o=0;o<r;o++){var i=e[Math.floor(o/8)+t],l=o%8;n[o]=a(i,l)?1:0}return n}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(21),o=(a=n)&&a.__esModule?a:{default:a};t.default=function(e,t){var r=e.elements.x7fe00010||e.elements.x7fe00008,a=e.uint16("x00280100"),n=e.uint16("x00280010"),i=e.uint16("x00280011"),l=e.uint16("x00280002"),u=r.dataOffset,d=n*i*l,s=void 0;if(8===a){if((s=u+t*d)>=e.byteArray.length)throw new Error("frame exceeds size of pixelData");return new Uint8Array(e.byteArray.buffer,s,d)}if(16===a){if((s=u+t*d*2)>=e.byteArray.length)throw new Error("frame exceeds size of pixelData");return new Uint8Array(e.byteArray.buffer,s,2*d)}if(1===a){if((s=u+t*d*.125)>=e.byteArray.length)throw new Error("frame exceeds size of pixelData");return(0,o.default)(e.byteArray,s,d)}if(32===a){if((s=u+t*d*4)>=e.byteArray.length)throw new Error("frame exceeds size of pixelData");return new Uint8Array(e.byteArray.buffer,s,4*d)}throw new Error("unsupported pixel format")}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var r=o.default.dicomParser;if(e.elements.x7fe00010&&e.elements.x7fe00010.basicOffsetTable.length)return r.readEncapsulatedImageFrame(e,e.elements.x7fe00010,t);if(function(e){var t=e.intString("x00280008"),r=e.elements.x7fe00010;return t!==r.fragments.length}(e)){var a=r.createJPEGBasicOffsetTable(e,e.elements.x7fe00010);return r.readEncapsulatedImageFrame(e,e.elements.x7fe00010,t,a)}return r.readEncapsulatedPixelDataFromFragments(e,e.elements.x7fe00010,t)};var a,n=r(0),o=(a=n)&&a.__esModule?a:{default:a}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=[];t.default={add:function(e){return"dicomfile:"+(a.push(e)-1)},get:function(e){return a[e]},remove:function(e){a[e]=void 0},purge:function(){a=[]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(t=t||e.transferSyntax,8===e.bitsAllocated&&"1.2.840.10008.1.2.4.50"===t&&(3===e.samplesPerPixel||4===e.samplesPerPixel))return!0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var r=t.data;if("RGB"===e.photometricInterpretation)n(e,r);else if("YBR_RCT"===e.photometricInterpretation)n(e,r);else if("YBR_ICT"===e.photometricInterpretation)n(e,r);else if("PALETTE COLOR"===e.photometricInterpretation)(0,a.convertPALETTECOLOR)(e,r);else if("YBR_FULL_422"===e.photometricInterpretation)n(e,r);else{if("YBR_FULL"!==e.photometricInterpretation)throw new Error("No color space conversion for photometric interpretation "+e.photometricInterpretation);!function(e,t){0===e.planarConfiguration?(0,a.convertYBRFullByPixel)(e.pixelData,t):(0,a.convertYBRFullByPlane)(e.pixelData,t)}(e,r)}};var a=r(45);function n(e,t){0===e.planarConfiguration?(0,a.convertRGBColorByPixel)(e.pixelData,t):(0,a.convertRGBColorByPlane)(e.pixelData,t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return"RGB"===e||"PALETTE COLOR"===e||"YBR_FULL"===e||"YBR_FULL_422"===e||"YBR_PARTIAL_422"===e||"YBR_PARTIAL_420"===e||"YBR_RCT"===e||"YBR_ICT"===e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(1),o=(a=n)&&a.__esModule?a:{default:a};function i(e){return function(e){var t=void 0;try{return decodeURIComponent(escape(e))}catch(r){if((t=r)instanceof URIError)return e;throw t}}(String.fromCharCode.apply(null,Array.prototype.slice.apply(new Uint8Array(e))))}t.default=function(e,t,r){var a=(new Date).getTime(),n=new Blob([t],{type:"image/jpeg"});return new Promise(function(t,l){var u=new FileReader;void 0===u.readAsBinaryString?u.readAsArrayBuffer(n):u.readAsBinaryString(n),u.onload=function(){var n=new Image;n.onload=function(){r.height=n.height,r.width=n.width,e.rows=n.height,e.columns=n.width;var i=r.getContext("2d");i.drawImage(this,0,0);var l=i.getImageData(0,0,n.width,n.height),u=(new Date).getTime();e.pixelData=l.data,e.imageData=l,e.decodeTimeInMS=u-a;var d=(0,o.default)(e.pixelData);e.smallestPixelValue=d.min,e.largestPixelValue=d.max,t(e)},n.onerror=function(e){l(e)},void 0===u.readAsBinaryString?n.src="data:image/jpeg;base64,"+window.btoa(i(u.result)):n.src="data:image/jpeg;base64,"+window.btoa(u.result)},u.onerror=function(e){l(e)}})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=0,n=[],o=[],i=(0,r(6).getOptions)(),l={maxWebWorkers:navigator.hardwareConcurrency||1,startWebWorkersOnDemand:!0,webWorkerPath:"../../dist/cornerstoneWADOImageLoaderWebWorker.js",webWorkerTaskPaths:[],taskConfiguration:{decodeTask:{loadCodecsOnStartup:!0,initializeCodecsOnStartup:!1,codecsPath:"../dist/cornerstoneWADOImageLoaderCodecs.js",usePDFJS:!1,strict:i.strict}}},u=void 0,d={maxWebWorkers:0,numWebWorkers:0,numTasksQueued:0,numTasksExecuting:0,numTasksCompleted:0,totalTaskTimeInMS:0,totalTimeDelayedInMS:0};function s(){if(n.length){for(var e=0;e<o.length;e++)if("ready"===o[e].status){o[e].status="busy";var t=n.shift();t.start=(new Date).getTime();var r=(new Date).getTime();return d.totalTimeDelayedInMS+=r-t.added,o[e].task=t,o[e].worker.postMessage({taskType:t.taskType,workerIndex:e,data:t.data},t.transferList),void d.numTasksExecuting++}o.length<u.maxWebWorkers&&c()}}function f(e){if("initialize"===e.data.taskType)o[e.data.workerIndex].status="ready",s();else{var t=o[e.data.workerIndex].task.start;o[e.data.workerIndex].task.deferred.resolve(e.data.result),o[e.data.workerIndex].task=void 0,d.numTasksExecuting--,o[e.data.workerIndex].status="ready",d.numTasksCompleted++;var r=(new Date).getTime();d.totalTaskTimeInMS+=r-t,s()}}function c(){if(!(o.length>=u.maxWebWorkers)){var e=new Worker(u.webWorkerPath);o.push({worker:e,status:"initializing"}),e.addEventListener("message",f),e.postMessage({taskType:"initialize",workerIndex:o.length-1,config:u})}}function p(e){if(e=e||l,u)throw new Error("WebWorkerManager already initialized");if((u=e).maxWebWorkers=u.maxWebWorkers||navigator.hardwareConcurrency||1,!u.startWebWorkersOnDemand)for(var t=0;t<u.maxWebWorkers;t++)c()}t.default={initialize:p,loadWebWorkerTask:function(e,t){u.webWorkerTaskPaths.push(e),t&&(u.taskConfiguration=Object.assign(u.taskConfiguration,t));for(var r=0;r<o.length;r++)o[r].worker.postMessage({taskType:"loadWebWorkerTask",workerIndex:o.length-1,sourcePath:e,config:u})},addTask:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments[3];u||p();var i={},l=new Promise(function(e,t){i={resolve:e,reject:t}}),d=void 0;for(d=0;d<n.length&&!(n[d].priority<r);d++);var f=a++;return n.splice(d,0,{taskId:f,taskType:e,status:"ready",added:(new Date).getTime(),data:t,deferred:i,priority:r,transferList:o}),s(),{taskId:f,promise:l}},getStatistics:function(){return d.maxWebWorkers=u.maxWebWorkers,d.numWebWorkers=o.length,d.numTasksQueued=n.length,d},setTaskPriority:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=0;r<n.length;r++)if(n[r].taskId===e){var a=n.splice(r,1)[0];for(a.priority=t,r=0;r<n.length&&!(n[r].priority<t);r++);return n.splice(r,0,a),!0}return!1},cancelTask:function(e,t){for(var r=0;r<n.length;r++)if(n[r].taskId===e)return n.splice(r,1).deferred.reject(t),!0;return!1}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),n=s(r(29)),o=s(r(28)),i=s(r(16)),l=s(r(10)),u=r(2),d=r(3);function s(e){return e&&e.__esModule?e:{default:e}}var f=!1;function c(e,t,r,o){var s=o.priority||void 0,c=o.transferPixelData?[r.buffer]:void 0,p=(0,a.getOptions)(),m=p.strict,g=p.decodeConfig;return!1===p.useWebWorkers?(!1===f&&((0,u.initializeJPEG2000)(g),(0,d.initializeJPEGLS)(g),f=!0),new Promise(function(a,n){try{var u=[e,t,r,g,o],d=i.default.apply(void 0,u);(0,l.default)(d,m),a(d)}catch(e){n(e)}})):n.default.addTask("decodeTask",{imageFrame:e,transferSyntax:t,pixelData:r,options:o},s,c).promise}t.default=function(e,t,r,a){var n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};return"1.2.840.10008.1.2"===t?c(e,t,r,n):"1.2.840.10008.1.2.1"===t?c(e,t,r,n):"1.2.840.10008.1.2.2"===t?c(e,t,r,n):"1.2.840.10008.1.2.1.99"===t?c(e,t,r,n):"1.2.840.10008.1.2.5"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.50"===t?8!==e.bitsAllocated||3!==e.samplesPerPixel&&4!==e.samplesPerPixel?c(e,t,r,n):(0,o.default)(e,r,a):"1.2.840.10008.1.2.4.51"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.57"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.70"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.80"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.81"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.90"===t?c(e,t,r,n):"1.2.840.10008.1.2.4.91"===t?c(e,t,r,n):new Promise(function(e,r){r(new Error("No decoder for transfer syntax "+t))})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(0),o=(a=n)&&a.__esModule?a:{default:a};t.default=function(e){var t=o.default.cornerstone.metaData.get("imagePixelModule",e);return{samplesPerPixel:t.samplesPerPixel,photometricInterpretation:t.photometricInterpretation,planarConfiguration:t.planarConfiguration,rows:t.rows,columns:t.columns,bitsAllocated:t.bitsAllocated,bitsStored:t.bitsStored,pixelRepresentation:t.pixelRepresentation,smallestPixelValue:t.smallestPixelValue,largestPixelValue:t.largestPixelValue,redPaletteColorLookupTableDescriptor:t.redPaletteColorLookupTableDescriptor,greenPaletteColorLookupTableDescriptor:t.greenPaletteColorLookupTableDescriptor,bluePaletteColorLookupTableDescriptor:t.bluePaletteColorLookupTableDescriptor,redPaletteColorLookupTableData:t.redPaletteColorLookupTableData,greenPaletteColorLookupTableData:t.greenPaletteColorLookupTableData,bluePaletteColorLookupTableData:t.bluePaletteColorLookupTableData,pixelData:void 0}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getTransferSyntaxForContentType=l;var a=i(r(18)),n=i(r(33)),o=i(r(17));function i(e){return e&&e.__esModule?e:{default:e}}function l(e){var t="1.2.840.10008.1.2";e&&e.split(";").forEach(function(e){var r=e.split("=");2===r.length&&"transfer-syntax"===r[0].trim()&&(t=r[1].trim()||t)});return t}t.default=function(e,t){var r=(new Date).getTime(),i=e.substring(7);return{promise:new Promise(function(u,d){if(void 0===a.default.get(e)){var s=new Error("no metadata for imageId "+e);return d(s)}(0,n.default)(i,e,'multipart/related; type="application/octet-stream"').then(function(a){var n=l(a.contentType),i=a.imageFrame.pixelData;(0,o.default)(e,i,n,t).then(function(e){var t=(new Date).getTime();e.loadTimeInMS=t-r,u(e)},d)},d)}),cancelFn:void 0}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(4),o=r(34),i=(a=o)&&a.__esModule?a:{default:a};t.default=function(e,t){var r={accept:arguments.length>2&&void 0!==arguments[2]?arguments[2]:"application/octet-stream"};return new Promise(function(a,o){(0,n.xhrRequest)(e,t,r).then(function(e){var t=new Uint8Array(e),r=(0,i.default)(t,"\r\n\r\n");-1===r&&o(new Error("invalid response - no multipart mime header"));var n=function(e,t,r){t=t||0,r=r||e.length-t;for(var a="",n=t;n<t+r;n++)a+=String.fromCharCode(e[n]);return a}(t,0,r).split("\r\n"),l=function(e){for(var t=0;t<e.length;t++)if("--"===e[t].substr(0,2))return e[t]}(n);l||o(new Error("invalid response - no boundary marker"));var u=r+4,d=(0,i.default)(t,l,u);-1===d&&o(new Error("invalid response - terminating boundary not found"));var s=d-u-2;a({contentType:function(e){for(var t=0;t<e.length;t++)if("Content-Type:"===e[t].substr(0,13))return e[t].substr(13).trim()}(n),imageFrame:{pixelData:new Uint8Array(e,u,s)}})})})}},function(e,t,r){"use strict";function a(e,t,r){if(r+e.length>t.length)return!1;for(var a=r,n=0;n<e.length;n++)if(e[n]!==t[a++])return!1;return!0}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){r=r||0;for(var n=function(e){for(var t=new Uint8Array(e.length),r=0,a=e.length;r<a;r++)t[r]=e.charCodeAt(r);return t}(t),o=r;o<e.length;o++)if(n[0]===e[o]&&a(n,e,o))return o;return-1}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e&&e.Value&&!(t&&e.Value.length<t)){for(var r=[],a=0;a<e.Value.length;a++)r.push(parseFloat(e.Value[a]));return r}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(7),o=(a=n)&&a.__esModule?a:{default:a};t.default=function(e,t){var r=(0,o.default)(e,t);if(void 0!==r)return parseFloat(r)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(55);Object.defineProperty(t,"getNumberString",{enumerable:!0,get:function(){return u(a).default}});var n=r(36);Object.defineProperty(t,"getNumberValue",{enumerable:!0,get:function(){return u(n).default}});var o=r(35);Object.defineProperty(t,"getNumberValues",{enumerable:!0,get:function(){return u(o).default}});var i=r(7);Object.defineProperty(t,"getValue",{enumerable:!0,get:function(){return u(i).default}});var l=r(54);function u(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"metaDataProvider",{enumerable:!0,get:function(){return u(l).default}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(37),n=d(r(34)),o=d(r(33)),i=d(r(18)),l=d(r(32)),u=d(r(52));function d(e){return e&&e.__esModule?e:{default:e}}var s={getNumberString:a.getNumberString,getNumberValue:a.getNumberValue,getNumberValues:a.getNumberValues,getValue:a.getValue,metaDataProvider:a.metaDataProvider};t.default={metaData:s,findIndexOfString:n.default,getPixelData:o.default,loadImage:l.default,metaDataManager:i.default,register:u.default}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){var a=[],n=e.string(t);if(n){var o=n.split("\\");if(!(r&&o.length<r)){for(var i=0;i<o.length;i++)a.push(parseFloat(o[i]));return a}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.string("x00080016");if("1.2.840.10008.5.1.4.1.1.2"===t||"1.2.840.10008.5.1.4.1.1.2.1"===t)return 1;var r=e.floatString("x00281052"),a=e.floatString("x00281053");return void 0!==r&&void 0!==a?function(e){var t=e.uint16("x00280103"),r=e.uint16("x00280101");return 0===t?0:-1<<r-1}(e)*a+r<0?1:0:e.elements.x00283000&&e.elements.x00283000.length>0?0:e.uint16("x00280103")}},function(e,t,r){"use strict";function a(e,t){var r=t.uint16("x00283002",0);0===r&&(r=65535);for(var a={id:"1",firstValueMapped:0===e?t.uint16("x00283002",1):t.int16("x00283002",1),numBitsPerEntry:t.uint16("x00283002",2),lut:[]},n=0;n<r;n++)a.lut[n]=0===e?t.uint16("x00283006",n):t.int16("x00283006",n);return a}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(t&&t.items.length){for(var r=[],n=0;n<t.items.length;n++){var o=a(e,t.items[n].dataSet);o&&r.push(o)}return r}}},function(e,t,r){"use strict";function a(e,t){if(e.elements[t]&&6===e.elements[t].length)return[e.uint16(t,0),e.uint16(t,1),e.uint16(t,2)]}function n(e,t,r){for(var a=[],n=e.elements[t],o=0;o<r[0];o++)16===r[2]?a[o]=e.uint16(t,o):a[o]=e.byteArray[o+n.dataOffset];return a}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t={samplesPerPixel:e.uint16("x00280002"),photometricInterpretation:e.string("x00280004"),rows:e.uint16("x00280010"),columns:e.uint16("x00280011"),bitsAllocated:e.uint16("x00280100"),bitsStored:e.uint16("x00280101"),highBit:e.uint16("x00280102"),pixelRepresentation:e.uint16("x00280103"),planarConfiguration:e.uint16("x00280006"),pixelAspectRatio:e.string("x00280034")};return function(e,t){0===e.uint16("x00280103")?(t.smallestPixelValue=e.uint16("x00280106"),t.largestPixelValue=e.uint16("x00280107")):(t.smallestPixelValue=e.int16("x00280106"),t.largestPixelValue=e.int16("x00280107"))}(e,t),"PALETTE COLOR"===t.photometricInterpretation&&e.elements.x00281101&&function(e,t){t.redPaletteColorLookupTableDescriptor=a(e,"x00281101"),t.greenPaletteColorLookupTableDescriptor=a(e,"x00281102"),t.bluePaletteColorLookupTableDescriptor=a(e,"x00281103"),0===t.redPaletteColorLookupTableDescriptor[0]&&(t.redPaletteColorLookupTableDescriptor[0]=65536,t.greenPaletteColorLookupTableDescriptor[0]=65536,t.bluePaletteColorLookupTableDescriptor[0]=65536);var r=t.redPaletteColorLookupTableDescriptor[0],o=e.elements.x00281201.length===r?8:16;t.redPaletteColorLookupTableDescriptor[2]!==o&&(t.redPaletteColorLookupTableDescriptor[2]=o,t.greenPaletteColorLookupTableDescriptor[2]=o,t.bluePaletteColorLookupTableDescriptor[2]=o),t.redPaletteColorLookupTableData=n(e,"x00281201",t.redPaletteColorLookupTableDescriptor),t.greenPaletteColorLookupTableData=n(e,"x00281202",t.greenPaletteColorLookupTableDescriptor),t.bluePaletteColorLookupTableData=n(e,"x00281203",t.bluePaletteColorLookupTableDescriptor)}(e,t),t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(42);Object.defineProperty(t,"getImagePixelModule",{enumerable:!0,get:function(){return u(a).default}});var n=r(41);Object.defineProperty(t,"getLUTs",{enumerable:!0,get:function(){return u(n).default}});var o=r(40);Object.defineProperty(t,"getModalityLUTOutputPixelRepresentation",{enumerable:!0,get:function(){return u(o).default}});var i=r(39);Object.defineProperty(t,"getNumberValues",{enumerable:!0,get:function(){return u(i).default}});var l=r(57);function u(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"metaDataProvider",{enumerable:!0,get:function(){return u(l).default}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(43),n=p(r(9)),o=p(r(24)),i=p(r(23)),l=p(r(22)),u=p(r(20)),d=r(19),s=p(r(5)),f=p(r(21)),c=p(r(50));function p(e){return e&&e.__esModule?e:{default:e}}var m={getImagePixelModule:a.getImagePixelModule,getLUTs:a.getLUTs,getModalityLUTOutputPixelRepresentation:a.getModalityLUTOutputPixelRepresentation,getNumberValues:a.getNumberValues,metaDataProvider:a.metaDataProvider};t.default={metaData:m,dataSetCacheManager:n.default,fileManager:o.default,getEncapsulatedImageFrame:i.default,getUncompressedImageFrame:l.default,loadFileRequest:u.default,loadImageFromPromise:d.loadImageFromPromise,getLoaderForScheme:d.getLoaderForScheme,loadImage:d.loadImage,parseImageId:s.default,unpackBinaryFrame:f.default,register:c.default}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(62);Object.defineProperty(t,"convertRGBColorByPixel",{enumerable:!0,get:function(){return u(a).default}});var n=r(61);Object.defineProperty(t,"convertRGBColorByPlane",{enumerable:!0,get:function(){return u(n).default}});var o=r(60);Object.defineProperty(t,"convertYBRFullByPixel",{enumerable:!0,get:function(){return u(o).default}});var i=r(59);Object.defineProperty(t,"convertYBRFullByPlane",{enumerable:!0,get:function(){return u(i).default}});var l=r(58);function u(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"convertPALETTECOLOR",{enumerable:!0,get:function(){return u(l).default}})},,,,function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(4);t.default=function(e){(0,a.setOptions)(e)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){e.registerImageLoader("dicomweb",a.loadImage),e.registerImageLoader("wadouri",a.loadImage),e.registerImageLoader("dicomfile",a.loadImage),e.metaData.addProvider(n.metaDataProvider)};var a=r(19),n=r(43)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(r(23)),n=o(r(22));function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=e.elements.x7fe00010||e.elements.x7fe00008;return r?r.encapsulatedPixelData?(0,a.default)(e,t):(0,n.default)(e,t):null}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){e.registerImageLoader("wadors",o.default),e.metaData.addProvider(i.metaDataProvider)};var a,n=r(32),o=(a=n)&&a.__esModule?a:{default:a},i=r(37)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(0),o=(a=n)&&a.__esModule?a:{default:a},i=r(6);t.default=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=o.default.cornerstone,l=(0,i.getOptions)();return new Promise(function(o,i){var u=new XMLHttpRequest;u.open("get",e,!0),u.responseType="arraybuffer",l.beforeSend(u,t),Object.keys(r).forEach(function(e){u.setRequestHeader(e,r[e])}),a.deferred={resolve:o,reject:i},a.url=e,a.imageId=t,u.onloadstart=function(r){l.onloadstart&&l.onloadstart(r,a);var o={url:e,imageId:t};n.triggerEvent(n.events,"cornerstoneimageloadstart",o)},u.onloadend=function(r){l.onloadend&&l.onloadend(r,a);var o={url:e,imageId:t};n.triggerEvent(n.events,"cornerstoneimageloadend",o)},u.onreadystatechange=function(e){l.onreadystatechange?l.onreadystatechange(e,a):4===u.readyState&&(200===u.status?o(u.response,u):i(u))},u.onprogress=function(r){var o=r.loaded,i=void 0,u=void 0;r.lengthComputable&&(i=r.total,u=Math.round(o/i*100)),l.onprogress&&l.onprogress(r,a);var d={url:e,imageId:t,loaded:o,total:i,percentComplete:u};n.triggerEvent(n.events,"cornerstoneimageloadprogress",d)},u.send()})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=u(r(0)),n=u(r(35)),o=u(r(7)),i=u(r(36)),l=u(r(18));function u(e){return e&&e.__esModule?e:{default:e}}t.default=function(e,t){var r=a.default.dicomParser,u=l.default.get(t);if(u){if("generalSeriesModule"===e)return{modality:(0,o.default)(u["00080060"]),seriesInstanceUID:(0,o.default)(u["0020000e"]),seriesNumber:(0,i.default)(u["00200011"]),studyInstanceUID:(0,o.default)(u["0020000d"]),seriesDate:r.parseDA((0,o.default)(u["00080021"])),seriesTime:r.parseTM((0,o.default)(u["00080031"],0,""))};if("patientStudyModule"===e)return{patientAge:(0,i.default)(u["00101010"]),patientSize:(0,i.default)(u["00101020"]),patientWeight:(0,i.default)(u["00101030"])};if("imagePlaneModule"===e){var d=(0,n.default)(u["00200037"],6),s=(0,n.default)(u["00200032"],3),f=(0,n.default)(u["00280030"],2),c=1,p=1;f&&(p=f[0],c=f[1]);var m=null,g=null;return d&&(m=[parseFloat(d[0]),parseFloat(d[1]),parseFloat(d[2])],g=[parseFloat(d[3]),parseFloat(d[4]),parseFloat(d[5])]),{frameOfReferenceUID:(0,o.default)(u["00200052"]),rows:(0,i.default)(u["00280010"]),columns:(0,i.default)(u["00280011"]),imageOrientationPatient:d,rowCosines:m,columnCosines:g,imagePositionPatient:s,sliceThickness:(0,i.default)(u["00180050"]),sliceLocation:(0,i.default)(u["00201041"]),pixelSpacing:f,rowPixelSpacing:p,columnPixelSpacing:c}}if("imagePixelModule"===e)return{samplesPerPixel:(0,i.default)(u["00280002"]),photometricInterpretation:(0,o.default)(u["00280004"]),rows:(0,i.default)(u["00280010"]),columns:(0,i.default)(u["00280011"]),bitsAllocated:(0,i.default)(u["00280100"]),bitsStored:(0,i.default)(u["00280101"]),highBit:(0,o.default)(u["00280102"]),pixelRepresentation:(0,i.default)(u["00280103"]),planarConfiguration:(0,i.default)(u["00280006"]),pixelAspectRatio:(0,o.default)(u["00280034"]),smallestPixelValue:(0,i.default)(u["00280106"]),largestPixelValue:(0,i.default)(u["00280107"]),redPaletteColorLookupTableDescriptor:(0,n.default)(u["00281101"]),greenPaletteColorLookupTableDescriptor:(0,n.default)(u["00281102"]),bluePaletteColorLookupTableDescriptor:(0,n.default)(u["00281103"]),redPaletteColorLookupTableData:(0,n.default)(u["00281201"]),greenPaletteColorLookupTableData:(0,n.default)(u["00281202"]),bluePaletteColorLookupTableData:(0,n.default)(u["00281203"])};if("voiLutModule"===e)return{windowCenter:(0,n.default)(u["00281050"],1),windowWidth:(0,n.default)(u["00281051"],1)};if("modalityLutModule"===e)return{rescaleIntercept:(0,i.default)(u["00281052"]),rescaleSlope:(0,i.default)(u["00281053"]),rescaleType:(0,o.default)(u["00281054"])};if("sopCommonModule"===e)return{sopClassUID:(0,o.default)(u["00080016"]),sopInstanceUID:(0,o.default)(u["00080018"])};if("petIsotopeModule"===e){var v=(0,o.default)(u["00540016"]);if(void 0===v)return;return{radiopharmaceuticalInfo:{radiopharmaceuticalStartTime:r.parseTM((0,o.default)(v["00181072"],0,"")),radionuclideTotalDose:(0,i.default)(v["00181074"]),radionuclideHalfLife:(0,i.default)(v["00181075"])}}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a,n=r(7),o=(a=n)&&a.__esModule?a:{default:a};t.default=function(e,t,r){var a=(0,o.default)(e,t,r);if(void 0!==a)return parseFloat(a)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=o(r(38)),n=o(r(44));function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){a.default.register(e),n.default.register(e)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=s(r(0)),n=s(r(39)),o=s(r(5)),i=s(r(9)),l=s(r(42)),u=s(r(41)),d=s(r(40));function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e,t){var r=a.default.dicomParser,s=(0,o.default)(t),f=i.default.get(s.url);if(f){if("generalSeriesModule"===e)return{modality:f.string("x00080060"),seriesInstanceUID:f.string("x0020000e"),seriesNumber:f.intString("x00200011"),studyInstanceUID:f.string("x0020000d"),seriesDate:r.parseDA(f.string("x00080021")),seriesTime:r.parseTM(f.string("x00080031")||"")};if("patientStudyModule"===e)return{patientAge:f.intString("x00101010"),patientSize:f.floatString("x00101020"),patientWeight:f.floatString("x00101030")};if("imagePlaneModule"===e){var c=(0,n.default)(f,"x00200037",6),p=(0,n.default)(f,"x00200032",3),m=(0,n.default)(f,"x00280030",2),g=1,v=1;m&&(v=m[0],g=m[1]);var b=null,x=null;return c&&(b=[parseFloat(c[0]),parseFloat(c[1]),parseFloat(c[2])],x=[parseFloat(c[3]),parseFloat(c[4]),parseFloat(c[5])]),{frameOfReferenceUID:f.string("x00200052"),rows:f.uint16("x00280010"),columns:f.uint16("x00280011"),imageOrientationPatient:c,rowCosines:b,columnCosines:x,imagePositionPatient:p,sliceThickness:f.floatString("x00180050"),sliceLocation:f.floatString("x00201041"),pixelSpacing:m,rowPixelSpacing:v,columnPixelSpacing:g}}if("imagePixelModule"===e)return(0,l.default)(f);if("modalityLutModule"===e)return{rescaleIntercept:f.floatString("x00281052"),rescaleSlope:f.floatString("x00281053"),rescaleType:f.string("x00281054"),modalityLUTSequence:(0,u.default)(f.uint16("x00280103"),f.elements.x00283000)};if("voiLutModule"===e){var P=(0,d.default)(f);return{windowCenter:(0,n.default)(f,"x00281050",1),windowWidth:(0,n.default)(f,"x00281051",1),voiLUTSequence:(0,u.default)(P,f.elements.x00283010)}}if("sopCommonModule"===e)return{sopClassUID:f.string("x00080016"),sopInstanceUID:f.string("x00080018")};if("petIsotopeModule"===e){var y=f.elements.x00540016;if(void 0===y)return;var h=y.items[0].dataSet;return{radiopharmaceuticalInfo:{radiopharmaceuticalStartTime:r.parseTM(h.string("x00181072")||""),radionuclideTotalDose:h.floatString("x00181074"),radionuclideHalfLife:h.floatString("x00181075")}}}}}},function(e,t,r){"use strict";function a(e,t){for(var r=e.length,a=new Uint8ClampedArray(r),n=0;n<r;++n)a[n]=e[n]>>t;return a}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){for(var r=e.columns*e.rows,n=e.pixelData,o=e.redPaletteColorLookupTableData,i=e.greenPaletteColorLookupTableData,l=e.bluePaletteColorLookupTableData,u=e.redPaletteColorLookupTableData.length,d=0,s=0,f=e.redPaletteColorLookupTableDescriptor[1],c=8===e.redPaletteColorLookupTableDescriptor[2]?0:8,p=a(o,c),m=a(i,c),g=a(l,c),v=0;v<r;++v){var b=n[d++];b<f?b=0:b>f+u-1?b=u-1:b-=f,t[s++]=p[b],t[s++]=m[b],t[s++]=g[b],t[s++]=255}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw new Error("decodeRGB: ybrBuffer must not be undefined");if(e.length%3!=0)throw new Error("decodeRGB: ybrBuffer length must be divisble by 3");for(var r=e.length/3,a=0,n=0,o=r,i=2*r,l=0;l<r;l++){var u=e[n++],d=e[o++],s=e[i++];t[a++]=u+1.402*(s-128),t[a++]=u-.34414*(d-128)-.71414*(s-128),t[a++]=u+1.772*(d-128),t[a++]=255}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw new Error("decodeRGB: ybrBuffer must not be undefined");if(e.length%3!=0)throw new Error("decodeRGB: ybrBuffer length must be divisble by 3");for(var r=e.length/3,a=0,n=0,o=0;o<r;o++){var i=e[a++],l=e[a++],u=e[a++];t[n++]=i+1.402*(u-128),t[n++]=i-.34414*(l-128)-.71414*(u-128),t[n++]=i+1.772*(l-128),t[n++]=255}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw new Error("decodeRGB: rgbBuffer must not be undefined");if(e.length%3!=0)throw new Error("decodeRGB: rgbBuffer length must be divisible by 3");for(var r=e.length/3,a=0,n=0,o=r,i=2*r,l=0;l<r;l++)t[a++]=e[n++],t[a++]=e[o++],t[a++]=e[i++],t[a++]=255}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw new Error("decodeRGB: rgbBuffer must not be undefined");if(e.length%3!=0)throw new Error("decodeRGB: rgbBuffer length must be divisible by 3");for(var r=e.length/3,a=0,n=0,o=0;o<r;o++)t[n++]=e[a++],t[n++]=e[a++],t[n++]=e[a++],t[n++]=255}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=r(45);Object.keys(a).forEach(function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}})});var n=r(44);Object.defineProperty(t,"wadouri",{enumerable:!0,get:function(){return P(n).default}});var o=r(38);Object.defineProperty(t,"wadors",{enumerable:!0,get:function(){return P(o).default}});var i=r(49);Object.defineProperty(t,"configure",{enumerable:!0,get:function(){return P(i).default}});var l=r(26);Object.defineProperty(t,"convertColorSpace",{enumerable:!0,get:function(){return P(l).default}});var u=r(17);Object.defineProperty(t,"createImage",{enumerable:!0,get:function(){return P(u).default}});var d=r(30);Object.defineProperty(t,"decodeImageFrame",{enumerable:!0,get:function(){return P(d).default}});var s=r(28);Object.defineProperty(t,"decodeJPEGBaseline8BitColor",{enumerable:!0,get:function(){return P(s).default}});var f=r(31);Object.defineProperty(t,"getImageFrame",{enumerable:!0,get:function(){return P(f).default}});var c=r(1);Object.defineProperty(t,"getMinMax",{enumerable:!0,get:function(){return P(c).default}});var p=r(27);Object.defineProperty(t,"isColorImage",{enumerable:!0,get:function(){return P(p).default}});var m=r(25);Object.defineProperty(t,"isJPEGBaseline8BitColor",{enumerable:!0,get:function(){return P(m).default}});var g=r(29);Object.defineProperty(t,"webWorkerManager",{enumerable:!0,get:function(){return P(g).default}});var v=r(8);Object.defineProperty(t,"version",{enumerable:!0,get:function(){return P(v).default}});var b=r(4);Object.defineProperty(t,"internal",{enumerable:!0,get:function(){return b.internal}});var x=r(0);function P(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"external",{enumerable:!0,get:function(){return P(x).default}})}])});
//# sourceMappingURL=cornerstoneWADOImageLoader.min.js.map
},{}],6:[function(require,module,exports){
/*! dicom-parser - 1.8.1 - 2018-05-16 | (c) 2017 Chris Hafey | https://github.com/cornerstonejs/dicomParser */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("dicom-parser",[],t):"object"==typeof exports?exports["dicom-parser"]=t():e.dicomParser=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=79)}([function(e,t){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var n=r(73),i=r(72),a=r(38);function o(){return f.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(e,t){if(o()<t)throw new RangeError("Invalid typed array length");return f.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=f.prototype:(null===e&&(e=new f(t)),e.length=t),e}function f(e,t,r){if(!(f.TYPED_ARRAY_SUPPORT||this instanceof f))return new f(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return h(this,e)}return l(this,e,t,r)}function l(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);f.TYPED_ARRAY_SUPPORT?(e=t).__proto__=f.prototype:e=d(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!f.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|p(t,r),i=(e=s(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function(e,t){if(f.isBuffer(t)){var r=0|c(t.length);return 0===(e=s(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?s(e,0):d(e,t);if("Buffer"===t.type&&a(t.data))return d(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function u(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function h(e,t){if(u(t),e=s(e,t<0?0:0|c(t)),!f.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function d(e,t){var r=t.length<0?0:0|c(t.length);e=s(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function c(e){if(e>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|e}function p(e,t){if(f.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return z(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return Z(e).length;default:if(n)return z(e).length;t=(""+t).toLowerCase(),n=!0}}function g(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function m(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=f.from(t,n)),f.isBuffer(t))return 0===t.length?-1:_(e,t,r,n,i);if("number"==typeof t)return t&=255,f.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):_(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function _(e,t,r,n,i){var a,o=1,s=e.length,f=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;o=2,s/=2,f/=2,r/=2}function l(e,t){return 1===o?e[t]:e.readUInt16BE(t*o)}if(i){var u=-1;for(a=r;a<s;a++)if(l(e,a)===l(t,-1===u?0:a-u)){if(-1===u&&(u=a),a-u+1===f)return u*o}else-1!==u&&(a-=a-u),u=-1}else for(r+f>s&&(r=s-f),a=r;a>=0;a--){for(var h=!0,d=0;d<f;d++)if(l(e,a+d)!==l(t,d)){h=!1;break}if(h)return a}return-1}function b(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var a=t.length;if(a%2!=0)throw new TypeError("Invalid hex string");n>a/2&&(n=a/2);for(var o=0;o<n;++o){var s=parseInt(t.substr(2*o,2),16);if(isNaN(s))return o;e[r+o]=s}return o}function y(e,t,r,n){return C(z(t,e.length-r),e,r,n)}function v(e,t,r,n){return C(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function w(e,t,r,n){return v(e,t,r,n)}function E(e,t,r,n){return C(Z(t),e,r,n)}function x(e,t,r,n){return C(function(e,t){for(var r,n,i,a=[],o=0;o<e.length&&!((t-=2)<0);++o)r=e.charCodeAt(o),n=r>>8,i=r%256,a.push(i),a.push(n);return a}(t,e.length-r),e,r,n)}function k(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function S(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var a,o,s,f,l=e[i],u=null,h=l>239?4:l>223?3:l>191?2:1;if(i+h<=r)switch(h){case 1:l<128&&(u=l);break;case 2:128==(192&(a=e[i+1]))&&(f=(31&l)<<6|63&a)>127&&(u=f);break;case 3:a=e[i+1],o=e[i+2],128==(192&a)&&128==(192&o)&&(f=(15&l)<<12|(63&a)<<6|63&o)>2047&&(f<55296||f>57343)&&(u=f);break;case 4:a=e[i+1],o=e[i+2],s=e[i+3],128==(192&a)&&128==(192&o)&&128==(192&s)&&(f=(15&l)<<18|(63&a)<<12|(63&o)<<6|63&s)>65535&&f<1114112&&(u=f)}null===u?(u=65533,h=1):u>65535&&(u-=65536,n.push(u>>>10&1023|55296),u=56320|1023&u),n.push(u),i+=h}return function(e){var t=e.length;if(t<=A)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=A));return r}(n)}t.Buffer=f,t.SlowBuffer=function(e){+e!=e&&(e=0);return f.alloc(+e)},t.INSPECT_MAX_BYTES=50,f.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=o(),f.poolSize=8192,f._augment=function(e){return e.__proto__=f.prototype,e},f.from=function(e,t,r){return l(null,e,t,r)},f.TYPED_ARRAY_SUPPORT&&(f.prototype.__proto__=Uint8Array.prototype,f.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&f[Symbol.species]===f&&Object.defineProperty(f,Symbol.species,{value:null,configurable:!0})),f.alloc=function(e,t,r){return function(e,t,r,n){return u(t),t<=0?s(e,t):void 0!==r?"string"==typeof n?s(e,t).fill(r,n):s(e,t).fill(r):s(e,t)}(null,e,t,r)},f.allocUnsafe=function(e){return h(null,e)},f.allocUnsafeSlow=function(e){return h(null,e)},f.isBuffer=function(e){return!(null==e||!e._isBuffer)},f.compare=function(e,t){if(!f.isBuffer(e)||!f.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,a=Math.min(r,n);i<a;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},f.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},f.concat=function(e,t){if(!a(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return f.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=f.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var o=e[r];if(!f.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,i),i+=o.length}return n},f.byteLength=p,f.prototype._isBuffer=!0,f.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)g(this,t,t+1);return this},f.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},f.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},f.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?S(this,0,e):function(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return T(this,t,r);case"utf8":case"utf-8":return S(this,t,r);case"ascii":return P(this,t,r);case"latin1":case"binary":return O(this,t,r);case"base64":return k(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return R(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}.apply(this,arguments)},f.prototype.equals=function(e){if(!f.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===f.compare(this,e)},f.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},f.prototype.compare=function(e,t,r,n,i){if(!f.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;for(var a=i-n,o=r-t,s=Math.min(a,o),l=this.slice(n,i),u=e.slice(t,r),h=0;h<s;++h)if(l[h]!==u[h]){a=l[h],o=u[h];break}return a<o?-1:o<a?1:0},f.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},f.prototype.indexOf=function(e,t,r){return m(this,e,t,r,!0)},f.prototype.lastIndexOf=function(e,t,r){return m(this,e,t,r,!1)},f.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var a=!1;;)switch(n){case"hex":return b(this,e,t,r);case"utf8":case"utf-8":return y(this,e,t,r);case"ascii":return v(this,e,t,r);case"latin1":case"binary":return w(this,e,t,r);case"base64":return E(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,r);default:if(a)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),a=!0}},f.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var A=4096;function P(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function O(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function T(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",a=t;a<r;++a)i+=j(e[a]);return i}function R(e,t,r){for(var n=e.slice(t,r),i="",a=0;a<n.length;a+=2)i+=String.fromCharCode(n[a]+256*n[a+1]);return i}function I(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function D(e,t,r,n,i,a){if(!f.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<a)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function L(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,a=Math.min(e.length-r,2);i<a;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function F(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,a=Math.min(e.length-r,4);i<a;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function U(e,t,r,n,i,a){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function B(e,t,r,n,a){return a||U(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function M(e,t,r,n,a){return a||U(e,0,r,8),i.write(e,t,r,n,52,8),r+8}f.prototype.slice=function(e,t){var r,n=this.length;if(e=~~e,t=void 0===t?n:~~t,e<0?(e+=n)<0&&(e=0):e>n&&(e=n),t<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),f.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=f.prototype;else{var i=t-e;r=new f(i,void 0);for(var a=0;a<i;++a)r[a]=this[a+e]}return r},f.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||I(e,t,this.length);for(var n=this[e],i=1,a=0;++a<t&&(i*=256);)n+=this[e+a]*i;return n},f.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||I(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},f.prototype.readUInt8=function(e,t){return t||I(e,1,this.length),this[e]},f.prototype.readUInt16LE=function(e,t){return t||I(e,2,this.length),this[e]|this[e+1]<<8},f.prototype.readUInt16BE=function(e,t){return t||I(e,2,this.length),this[e]<<8|this[e+1]},f.prototype.readUInt32LE=function(e,t){return t||I(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},f.prototype.readUInt32BE=function(e,t){return t||I(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},f.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||I(e,t,this.length);for(var n=this[e],i=1,a=0;++a<t&&(i*=256);)n+=this[e+a]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},f.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||I(e,t,this.length);for(var n=t,i=1,a=this[e+--n];n>0&&(i*=256);)a+=this[e+--n]*i;return a>=(i*=128)&&(a-=Math.pow(2,8*t)),a},f.prototype.readInt8=function(e,t){return t||I(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},f.prototype.readInt16LE=function(e,t){t||I(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},f.prototype.readInt16BE=function(e,t){t||I(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},f.prototype.readInt32LE=function(e,t){return t||I(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},f.prototype.readInt32BE=function(e,t){return t||I(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},f.prototype.readFloatLE=function(e,t){return t||I(e,4,this.length),i.read(this,e,!0,23,4)},f.prototype.readFloatBE=function(e,t){return t||I(e,4,this.length),i.read(this,e,!1,23,4)},f.prototype.readDoubleLE=function(e,t){return t||I(e,8,this.length),i.read(this,e,!0,52,8)},f.prototype.readDoubleBE=function(e,t){return t||I(e,8,this.length),i.read(this,e,!1,52,8)},f.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||D(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,a=0;for(this[t]=255&e;++a<r&&(i*=256);)this[t+a]=e/i&255;return t+r},f.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||D(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,a=1;for(this[t+i]=255&e;--i>=0&&(a*=256);)this[t+i]=e/a&255;return t+r},f.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,1,255,0),f.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},f.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,2,65535,0),f.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):L(this,e,t,!0),t+2},f.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,2,65535,0),f.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):L(this,e,t,!1),t+2},f.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,4,4294967295,0),f.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):F(this,e,t,!0),t+4},f.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,4,4294967295,0),f.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):F(this,e,t,!1),t+4},f.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);D(this,e,t,r,i-1,-i)}var a=0,o=1,s=0;for(this[t]=255&e;++a<r&&(o*=256);)e<0&&0===s&&0!==this[t+a-1]&&(s=1),this[t+a]=(e/o>>0)-s&255;return t+r},f.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);D(this,e,t,r,i-1,-i)}var a=r-1,o=1,s=0;for(this[t+a]=255&e;--a>=0&&(o*=256);)e<0&&0===s&&0!==this[t+a+1]&&(s=1),this[t+a]=(e/o>>0)-s&255;return t+r},f.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,1,127,-128),f.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},f.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,2,32767,-32768),f.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):L(this,e,t,!0),t+2},f.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,2,32767,-32768),f.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):L(this,e,t,!1),t+2},f.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,4,2147483647,-2147483648),f.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):F(this,e,t,!0),t+4},f.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||D(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),f.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):F(this,e,t,!1),t+4},f.prototype.writeFloatLE=function(e,t,r){return B(this,e,t,!0,r)},f.prototype.writeFloatBE=function(e,t,r){return B(this,e,t,!1,r)},f.prototype.writeDoubleLE=function(e,t,r){return M(this,e,t,!0,r)},f.prototype.writeDoubleBE=function(e,t,r){return M(this,e,t,!1,r)},f.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,a=n-r;if(this===e&&r<t&&t<n)for(i=a-1;i>=0;--i)e[i+t]=this[i+r];else if(a<1e3||!f.TYPED_ARRAY_SUPPORT)for(i=0;i<a;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+a),t);return a},f.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!f.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var a;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var o=f.isBuffer(e)?e:z(new f(e,n).toString()),s=o.length;for(a=0;a<r-t;++a)this[a+t]=o[a%s]}return this};var N=/[^+\/0-9A-Za-z-_]/g;function j(e){return e<16?"0"+e.toString(16):e.toString(16)}function z(e,t){var r;t=t||1/0;for(var n=e.length,i=null,a=[],o=0;o<n;++o){if((r=e.charCodeAt(o))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(o+1===n){(t-=3)>-1&&a.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&a.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&a.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;a.push(r)}else if(r<2048){if((t-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function Z(e){return n.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(N,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function C(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}}).call(this,r(0))},function(e,t,r){"use strict";var n=r(10),i=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};e.exports=h;var a=r(6);a.inherits=r(5);var o=r(35),s=r(18);a.inherits(h,o);for(var f=i(s.prototype),l=0;l<f.length;l++){var u=f[l];h.prototype[u]||(h.prototype[u]=s.prototype[u])}function h(e){if(!(this instanceof h))return new h(e);o.call(this,e),s.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",d)}function d(){this.allowHalfOpen||this._writableState.ended||n.nextTick(c,this)}function c(e){e.end()}Object.defineProperty(h.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}),h.prototype._destroy=function(e,t){this.push(null),this.end(),n.nextTick(t,e)}},function(e,t){var r,n,i=e.exports={};function a(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function s(e){if(r===setTimeout)return setTimeout(e,0);if((r===a||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:a}catch(e){r=a}try{n="function"==typeof clearTimeout?clearTimeout:o}catch(e){n=o}}();var f,l=[],u=!1,h=-1;function d(){u&&f&&(u=!1,f.length?l=f.concat(l):h=-1,l.length&&c())}function c(){if(!u){var e=s(d);u=!0;for(var t=l.length;t;){for(f=l,l=[];++h<t;)f&&f[h].run();h=-1,t=l.length}f=null,u=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===o||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function p(e,t){this.fun=e,this.array=t}function g(){}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];l.push(new p(e,t)),1!==l.length||u||s(c)},p.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=g,i.addListener=g,i.once=g,i.off=g,i.removeListener=g,i.removeAllListeners=g,i.emit=g,i.prependListener=g,i.prependOnceListener=g,i.listeners=function(e){return[]},i.binding=function(e){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(e){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(void 0===e)throw"dicomParser.readTag: missing required parameter 'byteStream'";var t=256*e.readUint16()*256,r=e.readUint16();return"x"+("00000000"+(t+r).toString(16)).substr(-8)}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},function(e,t,r){(function(e){function r(e){return Object.prototype.toString.call(e)}t.isArray=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===r(e)},t.isBoolean=function(e){return"boolean"==typeof e},t.isNull=function(e){return null===e},t.isNullOrUndefined=function(e){return null==e},t.isNumber=function(e){return"number"==typeof e},t.isString=function(e){return"string"==typeof e},t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=function(e){return void 0===e},t.isRegExp=function(e){return"[object RegExp]"===r(e)},t.isObject=function(e){return"object"==typeof e&&null!==e},t.isDate=function(e){return"[object Date]"===r(e)},t.isError=function(e){return"[object Error]"===r(e)||e instanceof Error},t.isFunction=function(e){return"function"==typeof e},t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=e.isBuffer}).call(this,r(1).Buffer)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=r(14);function a(e,t){return void 0!==e.parser?e.parser:t}var o=function(){function e(t,r,n){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.byteArrayParser=t,this.byteArray=r,this.elements=n}return n(e,[{key:"uint16",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readUint16(this.byteArray,r.dataOffset+2*t)}},{key:"int16",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readInt16(this.byteArray,r.dataOffset+2*t)}},{key:"uint32",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readUint32(this.byteArray,r.dataOffset+4*t)}},{key:"int32",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readInt32(this.byteArray,r.dataOffset+4*t)}},{key:"float",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readFloat(this.byteArray,r.dataOffset+4*t)}},{key:"double",value:function(e,t){var r=this.elements[e];if(t=void 0!==t?t:0,r&&0!==r.length)return a(r,this.byteArrayParser).readDouble(this.byteArray,r.dataOffset+8*t)}},{key:"numStringValues",value:function(e){var t=this.elements[e];if(t&&t.length>0){var r=(0,i.readFixedString)(this.byteArray,t.dataOffset,t.length).match(/\\/g);return null===r?1:r.length+1}}},{key:"string",value:function(e,t){var r=this.elements[e];if(r&&r.length>0){var n=(0,i.readFixedString)(this.byteArray,r.dataOffset,r.length);return t>=0?n.split("\\")[t].trim():n.trim()}}},{key:"text",value:function(e,t){var r=this.elements[e];if(r&&r.length>0){var n=(0,i.readFixedString)(this.byteArray,r.dataOffset,r.length);return t>=0?n.split("\\")[t].replace(/ +$/,""):n.replace(/ +$/,"")}}},{key:"floatString",value:function(e,t){var r=this.elements[e];if(r&&r.length>0){t=void 0!==t?t:0;var n=this.string(e,t);if(void 0!==n)return parseFloat(n)}}},{key:"intString",value:function(e,t){var r=this.elements[e];if(r&&r.length>0){t=void 0!==t?t:0;var n=this.string(e,t);if(void 0!==n)return parseInt(n)}}},{key:"attributeTag",value:function(e){var t=this.elements[e];if(t&&4===t.length){var r=a(t,this.byteArrayParser).readUint16,n=this.byteArray,i=t.dataOffset;return"x"+("00000000"+(256*r(n,i)*256+r(n,i+2)).toString(16)).substr(-8)}}}]),e}();t.default=o},function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;function i(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)i(r,n)&&(e[n]=r[n])}}return e},t.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var a={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var a=0;a<n;a++)e[i+a]=t[r+a]},flattenChunks:function(e){var t,r,n,i,a,o;for(n=0,t=0,r=e.length;t<r;t++)n+=e[t].length;for(o=new Uint8Array(n),i=0,t=0,r=e.length;t<r;t++)a=e[t],o.set(a,i),i+=a.length;return o}},o={arraySet:function(e,t,r,n,i){for(var a=0;a<n;a++)e[i+a]=t[r+a]},flattenChunks:function(e){return[].concat.apply([],e)}};t.setTyped=function(e){e?(t.Buf8=Uint8Array,t.Buf16=Uint16Array,t.Buf32=Int32Array,t.assign(t,a)):(t.Buf8=Array,t.Buf16=Array,t.Buf32=Array,t.assign(t,o))},t.setTyped(n)},function(e,t,r){var n=r(1),i=n.Buffer;function a(e,t){for(var r in e)t[r]=e[r]}function o(e,t,r){return i(e,t,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?e.exports=n:(a(n,t),t.Buffer=o),a(i,o),o.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,r)},o.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=i(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},o.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},o.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}},function(e,t,r){"use strict";(function(t){!t.version||0===t.version.indexOf("v0.")||0===t.version.indexOf("v1.")&&0!==t.version.indexOf("v1.8.")?e.exports={nextTick:function(e,r,n,i){if("function"!=typeof e)throw new TypeError('"callback" argument must be a function');var a,o,s=arguments.length;switch(s){case 0:case 1:return t.nextTick(e);case 2:return t.nextTick(function(){e.call(null,r)});case 3:return t.nextTick(function(){e.call(null,r,n)});case 4:return t.nextTick(function(){e.call(null,r,n,i)});default:for(a=new Array(s-1),o=0;o<a.length;)a[o++]=arguments[o];return t.nextTick(function(){e.apply(null,a)})}}}:e.exports=t}).call(this,r(3))},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t,r,n){if(void 0!==e&&t instanceof e)return t.slice(r,r+n);if(t instanceof Uint8Array)return new Uint8Array(t.buffer,t.byteOffset+r,n);throw"dicomParser.from: unknown type for byteArray"}}).call(this,r(1).Buffer)},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});var n,i=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),a=r(11),o=(n=a)&&n.__esModule?n:{default:n},s=r(14);var f=function(){function t(r,n,i){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),void 0===r)throw"dicomParser.ByteStream: missing required parameter 'byteArrayParser'";if(void 0===n)throw"dicomParser.ByteStream: missing required parameter 'byteArray'";if(n instanceof Uint8Array==!1&&n instanceof e==!1)throw"dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer";if(i<0)throw"dicomParser.ByteStream: parameter 'position' cannot be less than 0";if(i>=n.length)throw"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";this.byteArrayParser=r,this.byteArray=n,this.position=i||0,this.warnings=[]}return i(t,[{key:"seek",value:function(e){if(this.position+e<0)throw"dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";this.position+=e}},{key:"readByteStream",value:function(e){if(this.position+e>this.byteArray.length)throw"dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread";var r=(0,o.default)(this.byteArray,this.position,e);return this.position+=e,new t(this.byteArrayParser,r)}},{key:"readUint16",value:function(){var e=this.byteArrayParser.readUint16(this.byteArray,this.position);return this.position+=2,e}},{key:"readUint32",value:function(){var e=this.byteArrayParser.readUint32(this.byteArray,this.position);return this.position+=4,e}},{key:"readFixedString",value:function(e){var t=(0,s.readFixedString)(this.byteArray,this.position,e);return this.position+=e,t}}]),t}();t.default=f}).call(this,r(1).Buffer)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(void 0===e)throw"dicomParser.readSequenceItem: missing required parameter 'byteStream'";var t={tag:(0,a.default)(e),length:e.readUint32(),dataOffset:e.position};if("xfffee000"!==t.tag)throw"dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset "+e.position;return t};var n,i=r(4),a=(n=i)&&n.__esModule?n:{default:n}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.readFixedString=function(e,t,r){if(r<0)throw"dicomParser.readFixedString - length cannot be less than 0";if(t+r>e.length)throw"dicomParser.readFixedString: attempt to read past end of buffer";for(var n,i="",a=0;a<r;a++){if(0===(n=e[t+a]))return t+=r,i;i+=String.fromCharCode(n)}return i}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";var f={tag:(0,o.default)(e),vr:e.readFixedString(2)};2===l(f.vr)?(f.length=e.readUint16(),f.dataOffset=e.position):(e.seek(2),f.length=e.readUint32(),f.dataOffset=e.position);4294967295===f.length&&(f.hadUndefinedLength=!0);if(f.tag===r)return f;if("SQ"===f.vr)return(0,s.default)(e,f,t),f;if(4294967295===f.length)return"x7fe00010"===f.tag?((0,n.default)(e,f,t),f):"UN"===f.vr?((0,i.default)(e,f),f):((0,a.default)(e,f),f);return e.seek(f.length),f};var n=f(r(42)),i=f(r(41)),a=f(r(24)),o=f(r(4)),s=f(r(40));function f(e){return e&&e.__esModule?e:{default:e}}var l=function(e){return"OB"===e||"OW"===e||"SQ"===e||"OF"===e||"UT"===e||"UN"===e?4:2}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseDicomDataSetExplicit=function(e,t,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(r=void 0===r?t.byteArray.length:r,void 0===t)throw"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";if(r<t.position||r>t.byteArray.length)throw"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxP osition'";var a=e.elements;for(;t.position<r;){var o=(0,n.default)(t,e.warnings,i.untilTag);if(a[o.tag]=o,o.tag===i.untilTag)return}if(t.position>r)throw"dicomParser:parseDicomDataSetExplicit: buffer overrun"},t.parseDicomDataSetImplicit=function(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(r=void 0===r?e.byteArray.length:r,void 0===t)throw"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";if(r<t.position||r>t.byteArray.length)throw"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";var a=e.elements;for(;t.position<r;){var o=(0,i.default)(t,n.untilTag,n.vrCallback);if(a[o.tag]=o,o.tag===n.untilTag)return}};var n=a(r(15)),i=a(r(23));function a(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r,s,l){if(s=s||1,l=l||t.fragments,void 0===e)throw"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";if(void 0===t)throw"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";if(void 0===r)throw"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";if(void 0===s)throw"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";if("x7fe00010"!==t.tag)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010";if(!0!==t.encapsulatedPixelData)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(!0!==t.hadUndefinedLength)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.basicOffsetTable)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.fragments)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(t.fragments.length<=0)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(r<0)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";if(r>=t.fragments.length)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";if(s<1)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";if(r+s>t.fragments.length)throw"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";var u=new i.default(e.byteArrayParser,e.byteArray,t.dataOffset),h=(0,a.default)(u);if("xfffee000"!==h.tag)throw"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";u.seek(h.length);var d=u.position;if(1===s)return(0,o.default)(u.byteArray,d+l[r].offset+8,l[r].length);for(var c=f(l,r,s),p=(0,n.default)(u.byteArray,c),g=0,m=r;m<r+s;m++)for(var _=d+l[m].offset+8,b=0;b<l[m].length;b++)p[g++]=u.byteArray[_++];return p};var n=s(r(22)),i=s(r(12)),a=s(r(13)),o=s(r(11));function s(e){return e&&e.__esModule?e:{default:e}}var f=function(e,t,r){for(var n=0,i=t;i<t+r;i++)n+=e[i].length;return n}},function(e,t,r){"use strict";(function(t,n,i){var a=r(10);function o(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,r){var n=e.entry;e.entry=null;for(;n;){var i=n.callback;t.pendingcb--,i(r),n=n.next}t.corkedRequestsFree?t.corkedRequestsFree.next=e:t.corkedRequestsFree=e}(t,e)}}e.exports=b;var s,f=!t.browser&&["v0.10","v0.9."].indexOf(t.version.slice(0,5))>-1?n:a.nextTick;b.WritableState=_;var l=r(6);l.inherits=r(5);var u={deprecate:r(61)},h=r(34),d=r(9).Buffer,c=i.Uint8Array||function(){};var p,g=r(33);function m(){}function _(e,t){s=s||r(2),e=e||{};var n=t instanceof s;this.objectMode=!!e.objectMode,n&&(this.objectMode=this.objectMode||!!e.writableObjectMode);var i=e.highWaterMark,l=e.writableHighWaterMark,u=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(l||0===l)?l:u,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var h=!1===e.decodeStrings;this.decodeStrings=!h,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var r=e._writableState,n=r.sync,i=r.writecb;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(r),t)!function(e,t,r,n,i){--t.pendingcb,r?(a.nextTick(i,n),a.nextTick(k,e,t),e._writableState.errorEmitted=!0,e.emit("error",n)):(i(n),e._writableState.errorEmitted=!0,e.emit("error",n),k(e,t))}(e,r,n,t,i);else{var o=E(r);o||r.corked||r.bufferProcessing||!r.bufferedRequest||w(e,r),n?f(v,e,r,o,i):v(e,r,o,i)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new o(this)}function b(e){if(s=s||r(2),!(p.call(b,this)||this instanceof s))return new b(e);this._writableState=new _(e,this),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),h.call(this)}function y(e,t,r,n,i,a,o){t.writelen=n,t.writecb=o,t.writing=!0,t.sync=!0,r?e._writev(i,t.onwrite):e._write(i,a,t.onwrite),t.sync=!1}function v(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,n(),k(e,t)}function w(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,i=new Array(n),a=t.corkedRequestsFree;a.entry=r;for(var s=0,f=!0;r;)i[s]=r,r.isBuf||(f=!1),r=r.next,s+=1;i.allBuffers=f,y(e,t,!0,t.length,i,"",a.finish),t.pendingcb++,t.lastBufferedRequest=null,a.next?(t.corkedRequestsFree=a.next,a.next=null):t.corkedRequestsFree=new o(t),t.bufferedRequestCount=0}else{for(;r;){var l=r.chunk,u=r.encoding,h=r.callback;if(y(e,t,!1,t.objectMode?1:l.length,l,u,h),r=r.next,t.bufferedRequestCount--,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequest=r,t.bufferProcessing=!1}function E(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function x(e,t){e._final(function(r){t.pendingcb--,r&&e.emit("error",r),t.prefinished=!0,e.emit("prefinish"),k(e,t)})}function k(e,t){var r=E(t);return r&&(!function(e,t){t.prefinished||t.finalCalled||("function"==typeof e._final?(t.pendingcb++,t.finalCalled=!0,a.nextTick(x,e,t)):(t.prefinished=!0,e.emit("prefinish")))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"))),r}l.inherits(b,h),_.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(_.prototype,"buffer",{get:u.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(p=Function.prototype[Symbol.hasInstance],Object.defineProperty(b,Symbol.hasInstance,{value:function(e){return!!p.call(this,e)||this===b&&(e&&e._writableState instanceof _)}})):p=function(e){return e instanceof this},b.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},b.prototype.write=function(e,t,r){var n,i=this._writableState,o=!1,s=!i.objectMode&&(n=e,d.isBuffer(n)||n instanceof c);return s&&!d.isBuffer(e)&&(e=function(e){return d.from(e)}(e)),"function"==typeof t&&(r=t,t=null),s?t="buffer":t||(t=i.defaultEncoding),"function"!=typeof r&&(r=m),i.ended?function(e,t){var r=new Error("write after end");e.emit("error",r),a.nextTick(t,r)}(this,r):(s||function(e,t,r,n){var i=!0,o=!1;return null===r?o=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||t.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(e.emit("error",o),a.nextTick(n,o),i=!1),i}(this,i,e,r))&&(i.pendingcb++,o=function(e,t,r,n,i,a){if(!r){var o=function(e,t,r){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=d.from(t,r));return t}(t,n,i);n!==o&&(r=!0,i="buffer",n=o)}var s=t.objectMode?1:n.length;t.length+=s;var f=t.length<t.highWaterMark;f||(t.needDrain=!0);if(t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:a,next:null},l?l.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else y(e,t,!1,s,n,i,a);return f}(this,i,s,e,t,r)),o},b.prototype.cork=function(){this._writableState.corked++},b.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||w(this,e))},b.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},b.prototype._write=function(e,t,r){r(new Error("_write() is not implemented"))},b.prototype._writev=null,b.prototype.end=function(e,t,r){var n=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!==e&&void 0!==e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||function(e,t,r){t.ending=!0,k(e,t),r&&(t.finished?a.nextTick(r):e.once("finish",r));t.ended=!0,e.writable=!1}(this,n,r)},Object.defineProperty(b.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),b.prototype.destroy=g.destroy,b.prototype._undestroy=g.undestroy,b.prototype._destroy=function(e,t){this.end(),t(e)}}).call(this,r(3),r(63).setImmediate,r(0))},function(e,t,r){(t=e.exports=r(35)).Stream=t,t.Readable=t,t.Writable=r(18),t.Duplex=r(2),t.Transform=r(31),t.PassThrough=r(60)},function(e,t){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function n(e){return"function"==typeof e}function i(e){return"object"==typeof e&&null!==e}function a(e){return void 0===e}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},r.prototype.emit=function(e){var t,r,o,s,f,l;if(this._events||(this._events={}),"error"===e&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if((t=arguments[1])instanceof Error)throw t;var u=new Error('Uncaught, unspecified "error" event. ('+t+")");throw u.context=t,u}if(a(r=this._events[e]))return!1;if(n(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),r.apply(this,s)}else if(i(r))for(s=Array.prototype.slice.call(arguments,1),o=(l=r.slice()).length,f=0;f<o;f++)l[f].apply(this,s);return!0},r.prototype.addListener=function(e,t){var o;if(!n(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,n(t.listener)?t.listener:t),this._events[e]?i(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,i(this._events[e])&&!this._events[e].warned&&(o=a(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&o>0&&this._events[e].length>o&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace()),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(e,t){if(!n(t))throw TypeError("listener must be a function");var r=!1;function i(){this.removeListener(e,i),r||(r=!0,t.apply(this,arguments))}return i.listener=t,this.on(e,i),this},r.prototype.removeListener=function(e,t){var r,a,o,s;if(!n(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(o=(r=this._events[e]).length,a=-1,r===t||n(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(i(r)){for(s=o;s-- >0;)if(r[s]===t||r[s].listener&&r[s].listener===t){a=s;break}if(a<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(a,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},r.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(n(r=this._events[e]))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},r.prototype.listeners=function(e){return this._events&&this._events[e]?n(this._events[e])?[this._events[e]]:this._events[e].slice():[]},r.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(n(t))return 1;if(t)return t.length}return 0},r.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={readUint16:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readUint16: position cannot be less than 0";if(t+2>e.length)throw"littleEndianByteArrayParser.readUint16: attempt to read past end of buffer";return e[t]+256*e[t+1]},readInt16:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readInt16: position cannot be less than 0";if(t+2>e.length)throw"littleEndianByteArrayParser.readInt16: attempt to read past end of buffer";var r=e[t]+(e[t+1]<<8);return 32768&r&&(r=r-65535-1),r},readUint32:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readUint32: position cannot be less than 0";if(t+4>e.length)throw"littleEndianByteArrayParser.readUint32: attempt to read past end of buffer";return e[t]+256*e[t+1]+256*e[t+2]*256+256*e[t+3]*256*256},readInt32:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readInt32: position cannot be less than 0";if(t+4>e.length)throw"littleEndianByteArrayParser.readInt32: attempt to read past end of buffer";return e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24)},readFloat:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readFloat: position cannot be less than 0";if(t+4>e.length)throw"littleEndianByteArrayParser.readFloat: attempt to read past end of buffer";var r=new Uint8Array(4);return r[0]=e[t],r[1]=e[t+1],r[2]=e[t+2],r[3]=e[t+3],new Float32Array(r.buffer)[0]},readDouble:function(e,t){if(t<0)throw"littleEndianByteArrayParser.readDouble: position cannot be less than 0";if(t+8>e.length)throw"littleEndianByteArrayParser.readDouble: attempt to read past end of buffer";var r=new Uint8Array(8);return r[0]=e[t],r[1]=e[t+1],r[2]=e[t+2],r[3]=e[t+3],r[4]=e[t+4],r[5]=e[t+5],r[6]=e[t+6],r[7]=e[t+7],new Float64Array(r.buffer)[0]}}},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t,r){if(void 0!==e&&t instanceof e)return e.alloc(r);if(t instanceof Uint8Array)return new Uint8Array(r);throw"dicomParser.alloc: unknown type for byteArray"}}).call(this,r(1).Buffer)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";var o={tag:(0,a.default)(e),length:e.readUint32(),dataOffset:e.position};4294967295===o.length&&(o.hadUndefinedLength=!0);if(o.tag===t)return o;if(s(o,e,r))return(0,i.default)(e,o),o;if(o.hadUndefinedLength)return(0,n.default)(e,o),o;return e.seek(o.length),o};var n=o(r(24)),i=o(r(39)),a=o(r(4));function o(e){return e&&e.__esModule?e:{default:e}}var s=function(e,t,r){if(void 0!==r)return"SQ"===r(e.tag);if(t.position+4<=t.byteArray.length){var n=(0,a.default)(t);return t.seek(-4),"xfffee000"===n||"xfffee0dd"===n}return t.warnings.push("eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR"),!1}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";var r=e.byteArray.length-8;for(;e.position<=r;){var n=e.readUint16();if(65534===n){var i=e.readUint16();if(57357===i){var a=e.readUint32();return 0!==a&&e.warnings("encountered non zero length following item delimiter at position "+(e.position-4)+" while reading element of undefined length with tag "+t.tag),void(t.length=e.position-t.dataOffset)}}}t.length=e.byteArray.length-t.dataOffset,e.seek(e.byteArray.length-e.position)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n={AE:!0,AS:!0,AT:!1,CS:!0,DA:!0,DS:!0,DT:!0,FL:!1,FD:!1,IS:!0,LO:!0,LT:!0,OB:!1,OD:!1,OF:!1,OW:!1,PN:!0,SH:!0,SL:!1,SQ:!1,SS:!1,ST:!0,TM:!0,UI:!0,UL:!1,UN:void 0,UR:!0,US:!1,UT:!0};t.isStringVr=function(e){return n[e]},t.isPrivateTag=function(e){return parseInt(e[4],10)%2==1},t.parsePN=function(e){if(void 0!==e){var t=e.split("^");return{familyName:t[0],givenName:t[1],middleName:t[2],prefix:t[3],suffix:t[4]}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r,n,i){if(n=n||t.basicOffsetTable,i=i||t.fragments,void 0===e)throw"dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";if(void 0===t)throw"dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";if(void 0===r)throw"dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";if(void 0===n)throw"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";if("x7fe00010"!==t.tag)throw"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010)";if(!0!==t.encapsulatedPixelData)throw"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(!0!==t.hadUndefinedLength)throw"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";if(void 0===t.fragments)throw"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";if(0===n.length)throw"dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";if(r<0)throw"dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";if(r>=n.length)throw"dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";var f=n[r],l=o(i,f);if(void 0===l)throw"dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";var u=s(r,n,i,l);return(0,a.default)(e,t,l,u,i)};var n,i=r(17),a=(n=i)&&n.__esModule?n:{default:n};var o=function(e,t){for(var r=0;r<e.length;r++)if(e[r].offset===t)return r},s=function(e,t,r,n){if(e===t.length-1)return r.length-n;for(var i=t[e+1],a=n+1;a<r.length;a++)if(r[a].offset===i)return a-n;throw"dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table"}},function(e,t,r){"use strict";var n=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();e.exports=function(e,t,r,i){var a=n,o=i+r;e^=-1;for(var s=i;s<o;s++)e=e>>>8^a[255&(e^t[s])];return-1^e}},function(e,t,r){"use strict";e.exports=function(e,t,r,n){for(var i=65535&e|0,a=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(i=i+t[n++]|0)|0}while(--o);i%=65521,a%=65521}return i|a<<16|0}},function(e,t,r){(function(e,n){var i=/%[sdj%]/g;t.format=function(e){if(!_(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(s(arguments[r]));return t.join(" ")}r=1;for(var n=arguments,a=n.length,o=String(e).replace(i,function(e){if("%%"===e)return"%";if(r>=a)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),f=n[r];r<a;f=n[++r])g(f)||!v(f)?o+=" "+f:o+=" "+s(f);return o},t.deprecate=function(r,i){if(b(e.process))return function(){return t.deprecate(r,i).apply(this,arguments)};if(!0===n.noDeprecation)return r;var a=!1;return function(){if(!a){if(n.throwDeprecation)throw new Error(i);n.traceDeprecation?console.trace(i):console.error(i),a=!0}return r.apply(this,arguments)}};var a,o={};function s(e,r){var n={seen:[],stylize:l};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),p(r)?n.showHidden=r:r&&t._extend(n,r),b(n.showHidden)&&(n.showHidden=!1),b(n.depth)&&(n.depth=2),b(n.colors)&&(n.colors=!1),b(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=f),u(n,e,n.depth)}function f(e,t){var r=s.styles[t];return r?"["+s.colors[r][0]+"m"+e+"["+s.colors[r][1]+"m":e}function l(e,t){return e}function u(e,r,n){if(e.customInspect&&r&&x(r.inspect)&&r.inspect!==t.inspect&&(!r.constructor||r.constructor.prototype!==r)){var i=r.inspect(n,e);return _(i)||(i=u(e,i,n)),i}var a=function(e,t){if(b(t))return e.stylize("undefined","undefined");if(_(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}if(m(t))return e.stylize(""+t,"number");if(p(t))return e.stylize(""+t,"boolean");if(g(t))return e.stylize("null","null")}(e,r);if(a)return a;var o=Object.keys(r),s=function(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(r)),E(r)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return h(r);if(0===o.length){if(x(r)){var f=r.name?": "+r.name:"";return e.stylize("[Function"+f+"]","special")}if(y(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(w(r))return e.stylize(Date.prototype.toString.call(r),"date");if(E(r))return h(r)}var l,v="",k=!1,S=["{","}"];(c(r)&&(k=!0,S=["[","]"]),x(r))&&(v=" [Function"+(r.name?": "+r.name:"")+"]");return y(r)&&(v=" "+RegExp.prototype.toString.call(r)),w(r)&&(v=" "+Date.prototype.toUTCString.call(r)),E(r)&&(v=" "+h(r)),0!==o.length||k&&0!=r.length?n<0?y(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special"):(e.seen.push(r),l=k?function(e,t,r,n,i){for(var a=[],o=0,s=t.length;o<s;++o)P(t,String(o))?a.push(d(e,t,r,n,String(o),!0)):a.push("");return i.forEach(function(i){i.match(/^\d+$/)||a.push(d(e,t,r,n,i,!0))}),a}(e,r,n,s,o):o.map(function(t){return d(e,r,n,s,t,k)}),e.seen.pop(),function(e,t,r){if(e.reduce(function(e,t){return 0,t.indexOf("\n")>=0&&0,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60)return r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1];return r[0]+t+" "+e.join(", ")+" "+r[1]}(l,v,S)):S[0]+v+S[1]}function h(e){return"["+Error.prototype.toString.call(e)+"]"}function d(e,t,r,n,i,a){var o,s,f;if((f=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?s=f.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):f.set&&(s=e.stylize("[Setter]","special")),P(n,i)||(o="["+i+"]"),s||(e.seen.indexOf(f.value)<0?(s=g(r)?u(e,f.value,null):u(e,f.value,r-1)).indexOf("\n")>-1&&(s=a?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),b(o)){if(a&&i.match(/^\d+$/))return s;(o=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.substr(1,o.length-2),o=e.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=e.stylize(o,"string"))}return o+": "+s}function c(e){return Array.isArray(e)}function p(e){return"boolean"==typeof e}function g(e){return null===e}function m(e){return"number"==typeof e}function _(e){return"string"==typeof e}function b(e){return void 0===e}function y(e){return v(e)&&"[object RegExp]"===k(e)}function v(e){return"object"==typeof e&&null!==e}function w(e){return v(e)&&"[object Date]"===k(e)}function E(e){return v(e)&&("[object Error]"===k(e)||e instanceof Error)}function x(e){return"function"==typeof e}function k(e){return Object.prototype.toString.call(e)}function S(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(b(a)&&(a=n.env.NODE_DEBUG||""),e=e.toUpperCase(),!o[e])if(new RegExp("\\b"+e+"\\b","i").test(a)){var r=n.pid;o[e]=function(){var n=t.format.apply(t,arguments);console.error("%s %d: %s",e,r,n)}}else o[e]=function(){};return o[e]},t.inspect=s,s.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},s.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=c,t.isBoolean=p,t.isNull=g,t.isNullOrUndefined=function(e){return null==e},t.isNumber=m,t.isString=_,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=b,t.isRegExp=y,t.isObject=v,t.isDate=w,t.isError=E,t.isFunction=x,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=r(54);var A=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function P(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){var e,r;console.log("%s - %s",(e=new Date,r=[S(e.getHours()),S(e.getMinutes()),S(e.getSeconds())].join(":"),[e.getDate(),A[e.getMonth()],r].join(" ")),t.format.apply(t,arguments))},t.inherits=r(53),t._extend=function(e,t){if(!t||!v(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e}}).call(this,r(0),r(3))},function(e,t,r){"use strict";(function(t){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function n(e,t){if(e===t)return 0;for(var r=e.length,n=t.length,i=0,a=Math.min(r,n);i<a;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0}function i(e){return t.Buffer&&"function"==typeof t.Buffer.isBuffer?t.Buffer.isBuffer(e):!(null==e||!e._isBuffer)}var a=r(29),o=Object.prototype.hasOwnProperty,s=Array.prototype.slice,f="foo"===function(){}.name;function l(e){return Object.prototype.toString.call(e)}function u(e){return!i(e)&&("function"==typeof t.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&&(e instanceof DataView||!!(e.buffer&&e.buffer instanceof ArrayBuffer))))}var h=e.exports=_,d=/\s*function\s+([^\(\s]*)\s*/;function c(e){if(a.isFunction(e)){if(f)return e.name;var t=e.toString().match(d);return t&&t[1]}}function p(e,t){return"string"==typeof e?e.length<t?e:e.slice(0,t):e}function g(e){if(f||!a.isFunction(e))return a.inspect(e);var t=c(e);return"[Function"+(t?": "+t:"")+"]"}function m(e,t,r,n,i){throw new h.AssertionError({message:r,actual:e,expected:t,operator:n,stackStartFunction:i})}function _(e,t){e||m(e,!0,t,"==",h.ok)}function b(e,t,r,o){if(e===t)return!0;if(i(e)&&i(t))return 0===n(e,t);if(a.isDate(e)&&a.isDate(t))return e.getTime()===t.getTime();if(a.isRegExp(e)&&a.isRegExp(t))return e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase;if(null!==e&&"object"==typeof e||null!==t&&"object"==typeof t){if(u(e)&&u(t)&&l(e)===l(t)&&!(e instanceof Float32Array||e instanceof Float64Array))return 0===n(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(i(e)!==i(t))return!1;var f=(o=o||{actual:[],expected:[]}).actual.indexOf(e);return-1!==f&&f===o.expected.indexOf(t)||(o.actual.push(e),o.expected.push(t),function(e,t,r,n){if(null===e||void 0===e||null===t||void 0===t)return!1;if(a.isPrimitive(e)||a.isPrimitive(t))return e===t;if(r&&Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1;var i=y(e),o=y(t);if(i&&!o||!i&&o)return!1;if(i)return e=s.call(e),t=s.call(t),b(e,t,r);var f,l,u=E(e),h=E(t);if(u.length!==h.length)return!1;for(u.sort(),h.sort(),l=u.length-1;l>=0;l--)if(u[l]!==h[l])return!1;for(l=u.length-1;l>=0;l--)if(f=u[l],!b(e[f],t[f],r,n))return!1;return!0}(e,t,r,o))}return r?e===t:e==t}function y(e){return"[object Arguments]"==Object.prototype.toString.call(e)}function v(e,t){if(!e||!t)return!1;if("[object RegExp]"==Object.prototype.toString.call(t))return t.test(e);try{if(e instanceof t)return!0}catch(e){}return!Error.isPrototypeOf(t)&&!0===t.call({},e)}function w(e,t,r,n){var i;if("function"!=typeof t)throw new TypeError('"block" argument must be a function');"string"==typeof r&&(n=r,r=null),i=function(e){var t;try{e()}catch(e){t=e}return t}(t),n=(r&&r.name?" ("+r.name+").":".")+(n?" "+n:"."),e&&!i&&m(i,r,"Missing expected exception"+n);var o="string"==typeof n,s=!e&&a.isError(i),f=!e&&i&&!r;if((s&&o&&v(i,r)||f)&&m(i,r,"Got unwanted exception"+n),e&&i&&r&&!v(i,r)||!e&&i)throw i}h.AssertionError=function(e){var t;this.name="AssertionError",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=p(g((t=this).actual),128)+" "+t.operator+" "+p(g(t.expected),128),this.generatedMessage=!0);var r=e.stackStartFunction||m;if(Error.captureStackTrace)Error.captureStackTrace(this,r);else{var n=new Error;if(n.stack){var i=n.stack,a=c(r),o=i.indexOf("\n"+a);if(o>=0){var s=i.indexOf("\n",o+1);i=i.substring(s+1)}this.stack=i}}},a.inherits(h.AssertionError,Error),h.fail=m,h.ok=_,h.equal=function(e,t,r){e!=t&&m(e,t,r,"==",h.equal)},h.notEqual=function(e,t,r){e==t&&m(e,t,r,"!=",h.notEqual)},h.deepEqual=function(e,t,r){b(e,t,!1)||m(e,t,r,"deepEqual",h.deepEqual)},h.deepStrictEqual=function(e,t,r){b(e,t,!0)||m(e,t,r,"deepStrictEqual",h.deepStrictEqual)},h.notDeepEqual=function(e,t,r){b(e,t,!1)&&m(e,t,r,"notDeepEqual",h.notDeepEqual)},h.notDeepStrictEqual=function e(t,r,n){b(t,r,!0)&&m(t,r,n,"notDeepStrictEqual",e)},h.strictEqual=function(e,t,r){e!==t&&m(e,t,r,"===",h.strictEqual)},h.notStrictEqual=function(e,t,r){e===t&&m(e,t,r,"!==",h.notStrictEqual)},h.throws=function(e,t,r){w(!0,e,t,r)},h.doesNotThrow=function(e,t,r){w(!1,e,t,r)},h.ifError=function(e){if(e)throw e};var E=Object.keys||function(e){var t=[];for(var r in e)o.call(e,r)&&t.push(r);return t}}).call(this,r(0))},function(e,t,r){"use strict";e.exports=a;var n=r(2),i=r(6);function a(e){if(!(this instanceof a))return new a(e);n.call(this,e),this._transformState={afterTransform:function(e,t){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(!n)return this.emit("error",new Error("write callback called multiple times"));r.writechunk=null,r.writecb=null,null!=t&&this.push(t),n(e);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",o)}function o(){var e=this;"function"==typeof this._flush?this._flush(function(t,r){s(e,t,r)}):s(this,null,null)}function s(e,t,r){if(t)return e.emit("error",t);if(null!=r&&e.push(r),e._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(e._transformState.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}i.inherits=r(5),i.inherits(a,n),a.prototype.push=function(e,t){return this._transformState.needTransform=!1,n.prototype.push.call(this,e,t)},a.prototype._transform=function(e,t,r){throw new Error("_transform() is not implemented")},a.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},a.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},a.prototype._destroy=function(e,t){var r=this;n.prototype._destroy.call(this,e,function(e){t(e),r.emit("close")})}},function(e,t,r){"use strict";var n=r(9).Buffer,i=n.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function a(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(n.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=f,this.end=l,t=4;break;case"utf8":this.fillLast=s,t=4;break;case"base64":this.text=u,this.end=h,t=3;break;default:return this.write=d,void(this.end=c)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(t)}function o(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:-1}function s(e){var t=this.lastTotal-this.lastNeed,r=function(e,t,r){if(128!=(192&t[0]))return e.lastNeed=0,"�".repeat(r);if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"�".repeat(r+1);if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,"�".repeat(r+2)}}(this,e,t);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function f(e,t){if((e.length-t)%2==0){var r=e.toString("utf16le",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function l(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function u(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function h(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function d(e){return e.toString(this.encoding)}function c(e){return e&&e.length?this.write(e):""}t.StringDecoder=a,a.prototype.write=function(e){if(0===e.length)return"";var t,r;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},a.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"�".repeat(this.lastTotal-this.lastNeed):t},a.prototype.text=function(e,t){var r=function(e,t,r){var n=t.length-1;if(n<r)return 0;var i=o(t[n]);if(i>=0)return i>0&&(e.lastNeed=i-1),i;if(--n<r)return 0;if((i=o(t[n]))>=0)return i>0&&(e.lastNeed=i-2),i;if(--n<r)return 0;if((i=o(t[n]))>=0)return i>0&&(2===i?i=0:e.lastNeed=i-3),i;return 0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,n),e.toString("utf8",t,n)},a.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},function(e,t,r){"use strict";var n=r(10);function i(e,t){e.emit("error",t)}e.exports={destroy:function(e,t){var r=this,a=this._readableState&&this._readableState.destroyed,o=this._writableState&&this._writableState.destroyed;return a||o?(t?t(e):!e||this._writableState&&this._writableState.errorEmitted||n.nextTick(i,this,e),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,function(e){!t&&e?(n.nextTick(i,r,e),r._writableState&&(r._writableState.errorEmitted=!0)):t&&t(e)}),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},function(e,t,r){e.exports=r(20).EventEmitter},function(e,t,r){"use strict";(function(t,n){var i=r(10);e.exports=y;var a,o=r(38);y.ReadableState=b;r(20).EventEmitter;var s=function(e,t){return e.listeners(t).length},f=r(34),l=r(9).Buffer,u=t.Uint8Array||function(){};var h=r(6);h.inherits=r(5);var d=r(66),c=void 0;c=d&&d.debuglog?d.debuglog("stream"):function(){};var p,g=r(65),m=r(33);h.inherits(y,f);var _=["error","close","destroy","pause","resume"];function b(e,t){a=a||r(2),e=e||{};var n=t instanceof a;this.objectMode=!!e.objectMode,n&&(this.objectMode=this.objectMode||!!e.readableObjectMode);var i=e.highWaterMark,o=e.readableHighWaterMark,s=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(o||0===o)?o:s,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new g,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(p||(p=r(32).StringDecoder),this.decoder=new p(e.encoding),this.encoding=e.encoding)}function y(e){if(a=a||r(2),!(this instanceof y))return new y(e);this._readableState=new b(e,this),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),f.call(this)}function v(e,t,r,n,i){var a,o=e._readableState;null===t?(o.reading=!1,function(e,t){if(t.ended)return;if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,k(e)}(e,o)):(i||(a=function(e,t){var r;n=t,l.isBuffer(n)||n instanceof u||"string"==typeof t||void 0===t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk"));var n;return r}(o,t)),a?e.emit("error",a):o.objectMode||t&&t.length>0?("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===l.prototype||(t=function(e){return l.from(e)}(t)),n?o.endEmitted?e.emit("error",new Error("stream.unshift() after end event")):w(e,o,t,!0):o.ended?e.emit("error",new Error("stream.push() after EOF")):(o.reading=!1,o.decoder&&!r?(t=o.decoder.write(t),o.objectMode||0!==t.length?w(e,o,t,!1):A(e,o)):w(e,o,t,!1))):n||(o.reading=!1));return function(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}(o)}function w(e,t,r,n){t.flowing&&0===t.length&&!t.sync?(e.emit("data",r),e.read(0)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&k(e)),A(e,t)}Object.defineProperty(y.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),y.prototype.destroy=m.destroy,y.prototype._undestroy=m.undestroy,y.prototype._destroy=function(e,t){this.push(null),t(e)},y.prototype.push=function(e,t){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof e&&((t=t||n.defaultEncoding)!==n.encoding&&(e=l.from(e,t),t=""),r=!0),v(this,e,t,!1,r)},y.prototype.unshift=function(e){return v(this,e,null,!0,!1)},y.prototype.isPaused=function(){return!1===this._readableState.flowing},y.prototype.setEncoding=function(e){return p||(p=r(32).StringDecoder),this._readableState.decoder=new p(e),this._readableState.encoding=e,this};var E=8388608;function x(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=E?e=E:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function k(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(c("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?i.nextTick(S,e):S(e))}function S(e){c("emit readable"),e.emit("readable"),R(e)}function A(e,t){t.readingMore||(t.readingMore=!0,i.nextTick(P,e,t))}function P(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(c("maybeReadMore read 0"),e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function O(e){c("readable nexttick read 0"),e.read(0)}function T(e,t){t.reading||(c("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),R(e),t.flowing&&!t.reading&&e.read(0)}function R(e){var t=e._readableState;for(c("flow",t.flowing);t.flowing&&null!==e.read(););}function I(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):r=function(e,t,r){var n;e<t.head.data.length?(n=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):n=e===t.head.data.length?t.shift():r?function(e,t){var r=t.head,n=1,i=r.data;e-=i.length;for(;r=r.next;){var a=r.data,o=e>a.length?a.length:e;if(o===a.length?i+=a:i+=a.slice(0,e),0===(e-=o)){o===a.length?(++n,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=a.slice(o));break}++n}return t.length-=n,i}(e,t):function(e,t){var r=l.allocUnsafe(e),n=t.head,i=1;n.data.copy(r),e-=n.data.length;for(;n=n.next;){var a=n.data,o=e>a.length?a.length:e;if(a.copy(r,r.length-e,0,o),0===(e-=o)){o===a.length?(++i,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=a.slice(o));break}++i}return t.length-=i,r}(e,t);return n}(e,t.buffer,t.decoder),r);var r}function D(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,i.nextTick(L,t,e))}function L(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function F(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}y.prototype.read=function(e){c("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return c("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?D(this):k(this),null;if(0===(e=x(e,t))&&t.ended)return 0===t.length&&D(this),null;var n,i=t.needReadable;return c("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&c("length less than watermark",i=!0),t.ended||t.reading?c("reading or ended",i=!1):i&&(c("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=x(r,t))),null===(n=e>0?I(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&D(this)),null!==n&&this.emit("data",n),n},y.prototype._read=function(e){this.emit("error",new Error("_read() is not implemented"))},y.prototype.pipe=function(e,t){var r=this,a=this._readableState;switch(a.pipesCount){case 0:a.pipes=e;break;case 1:a.pipes=[a.pipes,e];break;default:a.pipes.push(e)}a.pipesCount+=1,c("pipe count=%d opts=%j",a.pipesCount,t);var f=(!t||!1!==t.end)&&e!==n.stdout&&e!==n.stderr?u:y;function l(t,n){c("onunpipe"),t===r&&n&&!1===n.hasUnpiped&&(n.hasUnpiped=!0,c("cleanup"),e.removeListener("close",_),e.removeListener("finish",b),e.removeListener("drain",h),e.removeListener("error",m),e.removeListener("unpipe",l),r.removeListener("end",u),r.removeListener("end",y),r.removeListener("data",g),d=!0,!a.awaitDrain||e._writableState&&!e._writableState.needDrain||h())}function u(){c("onend"),e.end()}a.endEmitted?i.nextTick(f):r.once("end",f),e.on("unpipe",l);var h=function(e){return function(){var t=e._readableState;c("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&s(e,"data")&&(t.flowing=!0,R(e))}}(r);e.on("drain",h);var d=!1;var p=!1;function g(t){c("ondata"),p=!1,!1!==e.write(t)||p||((1===a.pipesCount&&a.pipes===e||a.pipesCount>1&&-1!==F(a.pipes,e))&&!d&&(c("false write response, pause",r._readableState.awaitDrain),r._readableState.awaitDrain++,p=!0),r.pause())}function m(t){c("onerror",t),y(),e.removeListener("error",m),0===s(e,"error")&&e.emit("error",t)}function _(){e.removeListener("finish",b),y()}function b(){c("onfinish"),e.removeListener("close",_),y()}function y(){c("unpipe"),r.unpipe(e)}return r.on("data",g),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?o(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}(e,"error",m),e.once("close",_),e.once("finish",b),e.emit("pipe",r),a.flowing||(c("pipe resume"),r.resume()),e},y.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r),this);if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var a=0;a<i;a++)n[a].emit("unpipe",this,r);return this}var o=F(t.pipes,e);return-1===o?this:(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r),this)},y.prototype.on=function(e,t){var r=f.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&k(this):i.nextTick(O,this))}return r},y.prototype.addListener=y.prototype.on,y.prototype.resume=function(){var e=this._readableState;return e.flowing||(c("resume"),e.flowing=!0,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,i.nextTick(T,e,t))}(this,e)),this},y.prototype.pause=function(){return c("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(c("pause"),this._readableState.flowing=!1,this.emit("pause")),this},y.prototype.wrap=function(e){var t=this,r=this._readableState,n=!1;for(var i in e.on("end",function(){if(c("wrapped end"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e)}t.push(null)}),e.on("data",function(i){(c("wrapped data"),r.decoder&&(i=r.decoder.write(i)),!r.objectMode||null!==i&&void 0!==i)&&((r.objectMode||i&&i.length)&&(t.push(i)||(n=!0,e.pause())))}),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var a=0;a<_.length;a++)e.on(_[a],this.emit.bind(this,_[a]));return this._read=function(t){c("wrapped _read",t),n&&(n=!1,e.resume())},this},y._fromList=I}).call(this,r(0),r(3))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw"dicomParser.readPart10Header: missing required parameter 'byteArray'";var r=new n.default(a.default,e);return function(){!function(){if(r.seek(128),"DICM"!==r.readFixedString(4))throw"dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file."}();var e=[],t={};for(;r.position<r.byteArray.length;){var n=r.position,s=(0,o.default)(r,e);if(s.tag>"x0002ffff"){r.position=n;break}s.parser=a.default,t[s.tag]=s}var f=new i.default(r.byteArrayParser,r.byteArray,t);return f.warnings=r.warnings,f.position=r.position,f}()};var n=s(r(12)),i=s(r(7)),a=s(r(21)),o=s(r(15));function s(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={readUint16:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readUint16: position cannot be less than 0";if(t+2>e.length)throw"bigEndianByteArrayParser.readUint16: attempt to read past end of buffer";return(e[t]<<8)+e[t+1]},readInt16:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readInt16: position cannot be less than 0";if(t+2>e.length)throw"bigEndianByteArrayParser.readInt16: attempt to read past end of buffer";var r=(e[t]<<8)+e[t+1];return 32768&r&&(r=r-65535-1),r},readUint32:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readUint32: position cannot be less than 0";if(t+4>e.length)throw"bigEndianByteArrayParser.readUint32: attempt to read past end of buffer";return 256*(256*(256*e[t]+e[t+1])+e[t+2])+e[t+3]},readInt32:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readInt32: position cannot be less than 0";if(t+4>e.length)throw"bigEndianByteArrayParser.readInt32: attempt to read past end of buffer";return(e[t]<<24)+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3]},readFloat:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readFloat: position cannot be less than 0";if(t+4>e.length)throw"bigEndianByteArrayParser.readFloat: attempt to read past end of buffer";var r=new Uint8Array(4);return r[3]=e[t],r[2]=e[t+1],r[1]=e[t+2],r[0]=e[t+3],new Float32Array(r.buffer)[0]},readDouble:function(e,t){if(t<0)throw"bigEndianByteArrayParser.readDouble: position cannot be less than 0";if(t+8>e.length)throw"bigEndianByteArrayParser.readDouble: attempt to read past end of buffer";var r=new Uint8Array(8);return r[7]=e[t],r[6]=e[t+1],r[5]=e[t+2],r[4]=e[t+3],r[3]=e[t+4],r[2]=e[t+5],r[1]=e[t+6],r[0]=e[t+7],new Float64Array(r.buffer)[0]}}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";if(void 0===t)throw"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";t.items=[],4294967295===t.length?function(e,t,r){for(;e.position+4<=e.byteArray.length;){var n=(0,o.default)(e);if(e.seek(-4),"xfffee0dd"===n)return t.length=e.position-t.dataOffset,e.seek(8),t;var i=l(e,r);t.items.push(i)}e.warnings.push("eof encountered before finding sequence delimiter in sequence of undefined length"),t.length=e.byteArray.length-t.dataOffset}(e,t,r):function(e,t,r){var n=t.dataOffset+t.length;for(;e.position<n;){var i=l(e,r);t.items.push(i)}}(e,t,r)};var n=f(r(7)),i=f(r(23)),a=f(r(13)),o=f(r(4)),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(16));function f(e){return e&&e.__esModule?e:{default:e}}function l(e,t){var r=(0,a.default)(e);return 4294967295===r.length?(r.hadUndefinedLength=!0,r.dataSet=function(e,t){for(var r={};e.position<e.byteArray.length;){var a=(0,i.default)(e,void 0,t);if(r[a.tag]=a,"xfffee00d"===a.tag)return new n.default(e.byteArrayParser,e.byteArray,r)}return e.warnings.push("eof encountered before finding sequence item delimiter in sequence item of undefined length"),new n.default(e.byteArrayParser,e.byteArray,r)}(e,t),r.length=e.position-r.dataOffset):(r.dataSet=new n.default(e.byteArrayParser,e.byteArray,{}),s.parseDicomDataSetImplicit(r.dataSet,e,e.position+r.length,{vrCallback:t})),r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";if(void 0===t)throw"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";t.items=[],4294967295===t.length?function(e,t,r){for(;e.position+4<=e.byteArray.length;){var n=(0,o.default)(e);if(e.seek(-4),"xfffee0dd"===n)return t.length=e.position-t.dataOffset,e.seek(8),t;var i=l(e,r);t.items.push(i)}r.push("eof encountered before finding sequence delimitation tag while reading sequence of undefined length"),t.length=e.position-t.dataOffset}(e,t,r):function(e,t,r){var n=t.dataOffset+t.length;for(;e.position<n;){var i=l(e,r);t.items.push(i)}}(e,t,r)};var n=f(r(7)),i=f(r(15)),a=f(r(13)),o=f(r(4)),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(16));function f(e){return e&&e.__esModule?e:{default:e}}function l(e,t){var r=(0,a.default)(e);return 4294967295===r.length?(r.hadUndefinedLength=!0,r.dataSet=function(e,t){for(var r={};e.position<e.byteArray.length;){var a=(0,i.default)(e,t);if(r[a.tag]=a,"xfffee00d"===a.tag)return new n.default(e.byteArrayParser,e.byteArray,r)}return t.push("eof encountered before finding item delimiter tag while reading sequence item of undefined length"),new n.default(e.byteArrayParser,e.byteArray,r)}(e,t),r.length=e.position-r.dataOffset):(r.dataSet=new n.default(e.byteArrayParser,e.byteArray,{}),s.parseDicomDataSetExplicit(r.dataSet,e,e.position+r.length)),r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e)throw"dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";var r=e.byteArray.length-8;for(;e.position<=r;){var n=e.readUint16();if(65534===n){var i=e.readUint16();if(57565===i){var a=e.readUint32();return 0!==a&&e.warnings("encountered non zero length following item delimiter at position "+(e.position-4)+" while reading element of undefined length with tag "+t.tag),void(t.length=e.position-t.dataOffset)}}}t.length=e.byteArray.length-t.dataOffset,e.seek(e.byteArray.length-e.position)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";if(void 0===t)throw"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";if(t.encapsulatedPixelData=!0,t.basicOffsetTable=[],t.fragments=[],"xfffee000"!==(0,a.default)(e))throw"dicomParser.findEndOfEncapsulatedElement: basic offset table not found";for(var n=e.readUint32()/4,i=0;i<n;i++){var o=e.readUint32();t.basicOffsetTable.push(o)}var s=e.position;for(;e.position<e.byteArray.length;){var f=(0,a.default)(e),l=e.readUint32();if("xfffee0dd"===f)return e.seek(l),void(t.length=e.position-t.dataOffset);if("xfffee000"!==f)return r&&r.push("unexpected tag "+f+" while searching for end of pixel data element with undefined length"),l>e.byteArray.length-e.position&&(l=e.byteArray.length-e.position),t.fragments.push({offset:e.position-s-8,position:e.position,length:l}),e.seek(l),void(t.length=e.position-t.dataOffset);t.fragments.push({offset:e.position-s-8,position:e.position,length:l}),e.seek(l)}r&&r.push("pixel data element "+t.tag+" missing sequence delimiter tag xfffee0dd")};var n,i=r(4),a=(n=i)&&n.__esModule?n:{default:n}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(void 0===e||void 0===t)throw"dicomParser.explicitElementToString: missing required parameters";if(void 0===t.vr)throw"dicomParser.explicitElementToString: cannot convert implicit element to string";var r,i=t.vr,a=t.tag;function o(t,r){for(var n="",i=0;i<t;i++)0!==i&&(n+="/"),n+=r.call(e,a,i).toString();return n}if(!0===n.isStringVr(i))r=e.string(a);else{if("AT"===i){var s=e.uint32(a);if(void 0===s)return;return s<0&&(s=4294967295+s+1),"x"+s.toString(16).toUpperCase()}"US"===i?r=o(t.length/2,e.uint16):"SS"===i?r=o(t.length/2,e.int16):"UL"===i?r=o(t.length/4,e.uint32):"SL"===i?r=o(t.length/4,e.int32):"FD"===i?r=o(t.length/8,e.double):"FL"===i&&(r=o(t.length/4,e.float))}return r};var n=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(25))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){o||(o=!0,console&&console.log&&console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated"));if(void 0===e)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";if(void 0===t)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";if(void 0===r)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";if("x7fe00010"!==t.tag)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010)";if(!0!==t.encapsulatedPixelData)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(!0!==t.hadUndefinedLength)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.basicOffsetTable)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.fragments)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(r<0)throw"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";if(0!==t.basicOffsetTable.length)return(0,n.default)(e,t,r);return(0,i.default)(e,t,0,t.fragments.length)};var n=a(r(26)),i=a(r(17));function a(e){return e&&e.__esModule?e:{default:e}}var o=!1},function(e,t,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},function(e,t,r){"use strict";var n=r(8),i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],a=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],o=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],s=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(e,t,r,f,l,u,h,d){var c,p,g,m,_,b,y,v,w,E=d.bits,x=0,k=0,S=0,A=0,P=0,O=0,T=0,R=0,I=0,D=0,L=null,F=0,U=new n.Buf16(16),B=new n.Buf16(16),M=null,N=0;for(x=0;x<=15;x++)U[x]=0;for(k=0;k<f;k++)U[t[r+k]]++;for(P=E,A=15;A>=1&&0===U[A];A--);if(P>A&&(P=A),0===A)return l[u++]=20971520,l[u++]=20971520,d.bits=1,0;for(S=1;S<A&&0===U[S];S++);for(P<S&&(P=S),R=1,x=1;x<=15;x++)if(R<<=1,(R-=U[x])<0)return-1;if(R>0&&(0===e||1!==A))return-1;for(B[1]=0,x=1;x<15;x++)B[x+1]=B[x]+U[x];for(k=0;k<f;k++)0!==t[r+k]&&(h[B[t[r+k]]++]=k);if(0===e?(L=M=h,b=19):1===e?(L=i,F-=257,M=a,N-=257,b=256):(L=o,M=s,b=-1),D=0,k=0,x=S,_=u,O=P,T=0,g=-1,m=(I=1<<P)-1,1===e&&I>852||2===e&&I>592)return 1;for(;;){y=x-T,h[k]<b?(v=0,w=h[k]):h[k]>b?(v=M[N+h[k]],w=L[F+h[k]]):(v=96,w=0),c=1<<x-T,S=p=1<<O;do{l[_+(D>>T)+(p-=c)]=y<<24|v<<16|w|0}while(0!==p);for(c=1<<x-1;D&c;)c>>=1;if(0!==c?(D&=c-1,D+=c):D=0,k++,0==--U[x]){if(x===A)break;x=t[r+h[k]]}if(x>P&&(D&m)!==g){for(0===T&&(T=P),_+=S,R=1<<(O=x-T);O+T<A&&!((R-=U[O+T])<=0);)O++,R<<=1;if(I+=1<<O,1===e&&I>852||2===e&&I>592)return 1;l[g=D&m]=P<<24|O<<16|_-u|0}}return 0!==D&&(l[_+D]=x-T<<24|64<<16|0),d.bits=P,0}},function(e,t,r){"use strict";e.exports=function(e,t){var r,n,i,a,o,s,f,l,u,h,d,c,p,g,m,_,b,y,v,w,E,x,k,S,A;r=e.state,n=e.next_in,S=e.input,i=n+(e.avail_in-5),a=e.next_out,A=e.output,o=a-(t-e.avail_out),s=a+(e.avail_out-257),f=r.dmax,l=r.wsize,u=r.whave,h=r.wnext,d=r.window,c=r.hold,p=r.bits,g=r.lencode,m=r.distcode,_=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(c+=S[n++]<<p,p+=8,c+=S[n++]<<p,p+=8),y=g[c&_];t:for(;;){if(c>>>=v=y>>>24,p-=v,0===(v=y>>>16&255))A[a++]=65535&y;else{if(!(16&v)){if(0==(64&v)){y=g[(65535&y)+(c&(1<<v)-1)];continue t}if(32&v){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&y,(v&=15)&&(p<v&&(c+=S[n++]<<p,p+=8),w+=c&(1<<v)-1,c>>>=v,p-=v),p<15&&(c+=S[n++]<<p,p+=8,c+=S[n++]<<p,p+=8),y=m[c&b];r:for(;;){if(c>>>=v=y>>>24,p-=v,!(16&(v=y>>>16&255))){if(0==(64&v)){y=m[(65535&y)+(c&(1<<v)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(E=65535&y,p<(v&=15)&&(c+=S[n++]<<p,(p+=8)<v&&(c+=S[n++]<<p,p+=8)),(E+=c&(1<<v)-1)>f){e.msg="invalid distance too far back",r.mode=30;break e}if(c>>>=v,p-=v,E>(v=a-o)){if((v=E-v)>u&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(x=0,k=d,0===h){if(x+=l-v,v<w){w-=v;do{A[a++]=d[x++]}while(--v);x=a-E,k=A}}else if(h<v){if(x+=l+h-v,(v-=h)<w){w-=v;do{A[a++]=d[x++]}while(--v);if(x=0,h<w){w-=v=h;do{A[a++]=d[x++]}while(--v);x=a-E,k=A}}}else if(x+=h-v,v<w){w-=v;do{A[a++]=d[x++]}while(--v);x=a-E,k=A}for(;w>2;)A[a++]=k[x++],A[a++]=k[x++],A[a++]=k[x++],w-=3;w&&(A[a++]=k[x++],w>1&&(A[a++]=k[x++]))}else{x=a-E;do{A[a++]=A[x++],A[a++]=A[x++],A[a++]=A[x++],w-=3}while(w>2);w&&(A[a++]=A[x++],w>1&&(A[a++]=A[x++]))}break}}break}}while(n<i&&a<s);n-=w=p>>3,c&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=a,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=a<s?s-a+257:257-(a-s),r.hold=c,r.bits=p}},function(e,t,r){"use strict";var n=r(8),i=r(28),a=r(27),o=r(47),s=r(46),f=0,l=1,u=2,h=4,d=5,c=6,p=0,g=1,m=2,_=-2,b=-3,y=-4,v=-5,w=8,E=1,x=2,k=3,S=4,A=5,P=6,O=7,T=8,R=9,I=10,D=11,L=12,F=13,U=14,B=15,M=16,N=17,j=18,z=19,Z=20,C=21,q=22,Y=23,W=24,H=25,G=26,V=27,K=28,J=29,X=30,$=31,Q=32,ee=852,te=592,re=15;function ne(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function ie(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=E,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new n.Buf32(ee),t.distcode=t.distdyn=new n.Buf32(te),t.sane=1,t.back=-1,p):_}function ae(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,ie(e)):_}function oe(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?_:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,ae(e))):_}function se(e,t){var r,i;return e?(i=new function(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new n.Buf16(320),this.work=new n.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},e.state=i,i.window=null,(r=oe(e,t))!==p&&(e.state=null),r):_}var fe,le,ue=!0;function he(e){if(ue){var t;for(fe=new n.Buf32(512),le=new n.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(s(l,e.lens,0,288,fe,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;s(u,e.lens,0,32,le,0,e.work,{bits:5}),ue=!1}e.lencode=fe,e.lenbits=9,e.distcode=le,e.distbits=5}function de(e,t,r,i){var a,o=e.state;return null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new n.Buf8(o.wsize)),i>=o.wsize?(n.arraySet(o.window,t,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((a=o.wsize-o.wnext)>i&&(a=i),n.arraySet(o.window,t,r-i,a,o.wnext),(i-=a)?(n.arraySet(o.window,t,r-i,i,0),o.wnext=i,o.whave=o.wsize):(o.wnext+=a,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=a))),0}t.inflateReset=ae,t.inflateReset2=oe,t.inflateResetKeep=ie,t.inflateInit=function(e){return se(e,re)},t.inflateInit2=se,t.inflate=function(e,t){var r,ee,te,re,ie,ae,oe,se,fe,le,ue,ce,pe,ge,me,_e,be,ye,ve,we,Ee,xe,ke,Se,Ae=0,Pe=new n.Buf8(4),Oe=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return _;(r=e.state).mode===L&&(r.mode=F),ie=e.next_out,te=e.output,oe=e.avail_out,re=e.next_in,ee=e.input,ae=e.avail_in,se=r.hold,fe=r.bits,le=ae,ue=oe,xe=p;e:for(;;)switch(r.mode){case E:if(0===r.wrap){r.mode=F;break}for(;fe<16;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(2&r.wrap&&35615===se){r.check=0,Pe[0]=255&se,Pe[1]=se>>>8&255,r.check=a(r.check,Pe,2,0),se=0,fe=0,r.mode=x;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&se)<<8)+(se>>8))%31){e.msg="incorrect header check",r.mode=X;break}if((15&se)!==w){e.msg="unknown compression method",r.mode=X;break}if(fe-=4,Ee=8+(15&(se>>>=4)),0===r.wbits)r.wbits=Ee;else if(Ee>r.wbits){e.msg="invalid window size",r.mode=X;break}r.dmax=1<<Ee,e.adler=r.check=1,r.mode=512&se?I:L,se=0,fe=0;break;case x:for(;fe<16;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(r.flags=se,(255&r.flags)!==w){e.msg="unknown compression method",r.mode=X;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=X;break}r.head&&(r.head.text=se>>8&1),512&r.flags&&(Pe[0]=255&se,Pe[1]=se>>>8&255,r.check=a(r.check,Pe,2,0)),se=0,fe=0,r.mode=k;case k:for(;fe<32;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.head&&(r.head.time=se),512&r.flags&&(Pe[0]=255&se,Pe[1]=se>>>8&255,Pe[2]=se>>>16&255,Pe[3]=se>>>24&255,r.check=a(r.check,Pe,4,0)),se=0,fe=0,r.mode=S;case S:for(;fe<16;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.head&&(r.head.xflags=255&se,r.head.os=se>>8),512&r.flags&&(Pe[0]=255&se,Pe[1]=se>>>8&255,r.check=a(r.check,Pe,2,0)),se=0,fe=0,r.mode=A;case A:if(1024&r.flags){for(;fe<16;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.length=se,r.head&&(r.head.extra_len=se),512&r.flags&&(Pe[0]=255&se,Pe[1]=se>>>8&255,r.check=a(r.check,Pe,2,0)),se=0,fe=0}else r.head&&(r.head.extra=null);r.mode=P;case P:if(1024&r.flags&&((ce=r.length)>ae&&(ce=ae),ce&&(r.head&&(Ee=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),n.arraySet(r.head.extra,ee,re,ce,Ee)),512&r.flags&&(r.check=a(r.check,ee,ce,re)),ae-=ce,re+=ce,r.length-=ce),r.length))break e;r.length=0,r.mode=O;case O:if(2048&r.flags){if(0===ae)break e;ce=0;do{Ee=ee[re+ce++],r.head&&Ee&&r.length<65536&&(r.head.name+=String.fromCharCode(Ee))}while(Ee&&ce<ae);if(512&r.flags&&(r.check=a(r.check,ee,ce,re)),ae-=ce,re+=ce,Ee)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=T;case T:if(4096&r.flags){if(0===ae)break e;ce=0;do{Ee=ee[re+ce++],r.head&&Ee&&r.length<65536&&(r.head.comment+=String.fromCharCode(Ee))}while(Ee&&ce<ae);if(512&r.flags&&(r.check=a(r.check,ee,ce,re)),ae-=ce,re+=ce,Ee)break e}else r.head&&(r.head.comment=null);r.mode=R;case R:if(512&r.flags){for(;fe<16;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(se!==(65535&r.check)){e.msg="header crc mismatch",r.mode=X;break}se=0,fe=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=L;break;case I:for(;fe<32;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}e.adler=r.check=ne(se),se=0,fe=0,r.mode=D;case D:if(0===r.havedict)return e.next_out=ie,e.avail_out=oe,e.next_in=re,e.avail_in=ae,r.hold=se,r.bits=fe,m;e.adler=r.check=1,r.mode=L;case L:if(t===d||t===c)break e;case F:if(r.last){se>>>=7&fe,fe-=7&fe,r.mode=V;break}for(;fe<3;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}switch(r.last=1&se,fe-=1,3&(se>>>=1)){case 0:r.mode=U;break;case 1:if(he(r),r.mode=Z,t===c){se>>>=2,fe-=2;break e}break;case 2:r.mode=N;break;case 3:e.msg="invalid block type",r.mode=X}se>>>=2,fe-=2;break;case U:for(se>>>=7&fe,fe-=7&fe;fe<32;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if((65535&se)!=(se>>>16^65535)){e.msg="invalid stored block lengths",r.mode=X;break}if(r.length=65535&se,se=0,fe=0,r.mode=B,t===c)break e;case B:r.mode=M;case M:if(ce=r.length){if(ce>ae&&(ce=ae),ce>oe&&(ce=oe),0===ce)break e;n.arraySet(te,ee,re,ce,ie),ae-=ce,re+=ce,oe-=ce,ie+=ce,r.length-=ce;break}r.mode=L;break;case N:for(;fe<14;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(r.nlen=257+(31&se),se>>>=5,fe-=5,r.ndist=1+(31&se),se>>>=5,fe-=5,r.ncode=4+(15&se),se>>>=4,fe-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=X;break}r.have=0,r.mode=j;case j:for(;r.have<r.ncode;){for(;fe<3;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.lens[Oe[r.have++]]=7&se,se>>>=3,fe-=3}for(;r.have<19;)r.lens[Oe[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,ke={bits:r.lenbits},xe=s(f,r.lens,0,19,r.lencode,0,r.work,ke),r.lenbits=ke.bits,xe){e.msg="invalid code lengths set",r.mode=X;break}r.have=0,r.mode=z;case z:for(;r.have<r.nlen+r.ndist;){for(;_e=(Ae=r.lencode[se&(1<<r.lenbits)-1])>>>16&255,be=65535&Ae,!((me=Ae>>>24)<=fe);){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(be<16)se>>>=me,fe-=me,r.lens[r.have++]=be;else{if(16===be){for(Se=me+2;fe<Se;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(se>>>=me,fe-=me,0===r.have){e.msg="invalid bit length repeat",r.mode=X;break}Ee=r.lens[r.have-1],ce=3+(3&se),se>>>=2,fe-=2}else if(17===be){for(Se=me+3;fe<Se;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}fe-=me,Ee=0,ce=3+(7&(se>>>=me)),se>>>=3,fe-=3}else{for(Se=me+7;fe<Se;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}fe-=me,Ee=0,ce=11+(127&(se>>>=me)),se>>>=7,fe-=7}if(r.have+ce>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=X;break}for(;ce--;)r.lens[r.have++]=Ee}}if(r.mode===X)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=X;break}if(r.lenbits=9,ke={bits:r.lenbits},xe=s(l,r.lens,0,r.nlen,r.lencode,0,r.work,ke),r.lenbits=ke.bits,xe){e.msg="invalid literal/lengths set",r.mode=X;break}if(r.distbits=6,r.distcode=r.distdyn,ke={bits:r.distbits},xe=s(u,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,ke),r.distbits=ke.bits,xe){e.msg="invalid distances set",r.mode=X;break}if(r.mode=Z,t===c)break e;case Z:r.mode=C;case C:if(ae>=6&&oe>=258){e.next_out=ie,e.avail_out=oe,e.next_in=re,e.avail_in=ae,r.hold=se,r.bits=fe,o(e,ue),ie=e.next_out,te=e.output,oe=e.avail_out,re=e.next_in,ee=e.input,ae=e.avail_in,se=r.hold,fe=r.bits,r.mode===L&&(r.back=-1);break}for(r.back=0;_e=(Ae=r.lencode[se&(1<<r.lenbits)-1])>>>16&255,be=65535&Ae,!((me=Ae>>>24)<=fe);){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(_e&&0==(240&_e)){for(ye=me,ve=_e,we=be;_e=(Ae=r.lencode[we+((se&(1<<ye+ve)-1)>>ye)])>>>16&255,be=65535&Ae,!(ye+(me=Ae>>>24)<=fe);){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}se>>>=ye,fe-=ye,r.back+=ye}if(se>>>=me,fe-=me,r.back+=me,r.length=be,0===_e){r.mode=G;break}if(32&_e){r.back=-1,r.mode=L;break}if(64&_e){e.msg="invalid literal/length code",r.mode=X;break}r.extra=15&_e,r.mode=q;case q:if(r.extra){for(Se=r.extra;fe<Se;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.length+=se&(1<<r.extra)-1,se>>>=r.extra,fe-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=Y;case Y:for(;_e=(Ae=r.distcode[se&(1<<r.distbits)-1])>>>16&255,be=65535&Ae,!((me=Ae>>>24)<=fe);){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(0==(240&_e)){for(ye=me,ve=_e,we=be;_e=(Ae=r.distcode[we+((se&(1<<ye+ve)-1)>>ye)])>>>16&255,be=65535&Ae,!(ye+(me=Ae>>>24)<=fe);){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}se>>>=ye,fe-=ye,r.back+=ye}if(se>>>=me,fe-=me,r.back+=me,64&_e){e.msg="invalid distance code",r.mode=X;break}r.offset=be,r.extra=15&_e,r.mode=W;case W:if(r.extra){for(Se=r.extra;fe<Se;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}r.offset+=se&(1<<r.extra)-1,se>>>=r.extra,fe-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=X;break}r.mode=H;case H:if(0===oe)break e;if(ce=ue-oe,r.offset>ce){if((ce=r.offset-ce)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=X;break}ce>r.wnext?(ce-=r.wnext,pe=r.wsize-ce):pe=r.wnext-ce,ce>r.length&&(ce=r.length),ge=r.window}else ge=te,pe=ie-r.offset,ce=r.length;ce>oe&&(ce=oe),oe-=ce,r.length-=ce;do{te[ie++]=ge[pe++]}while(--ce);0===r.length&&(r.mode=C);break;case G:if(0===oe)break e;te[ie++]=r.length,oe--,r.mode=C;break;case V:if(r.wrap){for(;fe<32;){if(0===ae)break e;ae--,se|=ee[re++]<<fe,fe+=8}if(ue-=oe,e.total_out+=ue,r.total+=ue,ue&&(e.adler=r.check=r.flags?a(r.check,te,ue,ie-ue):i(r.check,te,ue,ie-ue)),ue=oe,(r.flags?se:ne(se))!==r.check){e.msg="incorrect data check",r.mode=X;break}se=0,fe=0}r.mode=K;case K:if(r.wrap&&r.flags){for(;fe<32;){if(0===ae)break e;ae--,se+=ee[re++]<<fe,fe+=8}if(se!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=X;break}se=0,fe=0}r.mode=J;case J:xe=g;break e;case X:xe=b;break e;case $:return y;case Q:default:return _}return e.next_out=ie,e.avail_out=oe,e.next_in=re,e.avail_in=ae,r.hold=se,r.bits=fe,(r.wsize||ue!==e.avail_out&&r.mode<X&&(r.mode<V||t!==h))&&de(e,e.output,e.next_out,ue-e.avail_out)?(r.mode=$,y):(le-=e.avail_in,ue-=e.avail_out,e.total_in+=le,e.total_out+=ue,r.total+=ue,r.wrap&&ue&&(e.adler=r.check=r.flags?a(r.check,te,ue,e.next_out-ue):i(r.check,te,ue,e.next_out-ue)),e.data_type=r.bits+(r.last?64:0)+(r.mode===L?128:0)+(r.mode===Z||r.mode===B?256:0),(0===le&&0===ue||t===h)&&xe===p&&(xe=v),xe)},t.inflateEnd=function(e){if(!e||!e.state)return _;var t=e.state;return t.window&&(t.window=null),e.state=null,p},t.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?_:(r.head=t,t.done=!1,p):_},t.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&r.mode!==D?_:r.mode===D&&i(1,t,n,0)!==r.check?b:de(e,t,n,n)?(r.mode=$,y):(r.havedict=1,p):_},t.inflateInfo="pako inflate (from Nodeca project)"},function(e,t,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},function(e,t,r){"use strict";var n=r(8),i=4,a=0,o=1,s=2;function f(e){for(var t=e.length;--t>=0;)e[t]=0}var l=0,u=1,h=2,d=29,c=256,p=c+1+d,g=30,m=19,_=2*p+1,b=15,y=16,v=7,w=256,E=16,x=17,k=18,S=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],A=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],P=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],O=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],T=new Array(2*(p+2));f(T);var R=new Array(2*g);f(R);var I=new Array(512);f(I);var D=new Array(256);f(D);var L=new Array(d);f(L);var F,U,B,M=new Array(g);function N(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function j(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function z(e){return e<256?I[e]:I[256+(e>>>7)]}function Z(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function C(e,t,r){e.bi_valid>y-r?(e.bi_buf|=t<<e.bi_valid&65535,Z(e,e.bi_buf),e.bi_buf=t>>y-e.bi_valid,e.bi_valid+=r-y):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function q(e,t,r){C(e,r[2*t],r[2*t+1])}function Y(e,t){var r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1}function W(e,t,r){var n,i,a=new Array(b+1),o=0;for(n=1;n<=b;n++)a[n]=o=o+r[n-1]<<1;for(i=0;i<=t;i++){var s=e[2*i+1];0!==s&&(e[2*i]=Y(a[s]++,s))}}function H(e){var t;for(t=0;t<p;t++)e.dyn_ltree[2*t]=0;for(t=0;t<g;t++)e.dyn_dtree[2*t]=0;for(t=0;t<m;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*w]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function G(e){e.bi_valid>8?Z(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function V(e,t,r,n){var i=2*t,a=2*r;return e[i]<e[a]||e[i]===e[a]&&n[t]<=n[r]}function K(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&V(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!V(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function J(e,t,r){var n,i,a,o,s=0;if(0!==e.last_lit)do{n=e.pending_buf[e.d_buf+2*s]<<8|e.pending_buf[e.d_buf+2*s+1],i=e.pending_buf[e.l_buf+s],s++,0===n?q(e,i,t):(q(e,(a=D[i])+c+1,t),0!==(o=S[a])&&C(e,i-=L[a],o),q(e,a=z(--n),r),0!==(o=A[a])&&C(e,n-=M[a],o))}while(s<e.last_lit);q(e,w,t)}function X(e,t){var r,n,i,a=t.dyn_tree,o=t.stat_desc.static_tree,s=t.stat_desc.has_stree,f=t.stat_desc.elems,l=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<f;r++)0!==a[2*r]?(e.heap[++e.heap_len]=l=r,e.depth[r]=0):a[2*r+1]=0;for(;e.heap_len<2;)a[2*(i=e.heap[++e.heap_len]=l<2?++l:0)]=1,e.depth[i]=0,e.opt_len--,s&&(e.static_len-=o[2*i+1]);for(t.max_code=l,r=e.heap_len>>1;r>=1;r--)K(e,a,r);i=f;do{r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],K(e,a,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,a[2*i]=a[2*r]+a[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,a[2*r+1]=a[2*n+1]=i,e.heap[1]=i++,K(e,a,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,a,o,s,f=t.dyn_tree,l=t.max_code,u=t.stat_desc.static_tree,h=t.stat_desc.has_stree,d=t.stat_desc.extra_bits,c=t.stat_desc.extra_base,p=t.stat_desc.max_length,g=0;for(a=0;a<=b;a++)e.bl_count[a]=0;for(f[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)(a=f[2*f[2*(n=e.heap[r])+1]+1]+1)>p&&(a=p,g++),f[2*n+1]=a,n>l||(e.bl_count[a]++,o=0,n>=c&&(o=d[n-c]),s=f[2*n],e.opt_len+=s*(a+o),h&&(e.static_len+=s*(u[2*n+1]+o)));if(0!==g){do{for(a=p-1;0===e.bl_count[a];)a--;e.bl_count[a]--,e.bl_count[a+1]+=2,e.bl_count[p]--,g-=2}while(g>0);for(a=p;0!==a;a--)for(n=e.bl_count[a];0!==n;)(i=e.heap[--r])>l||(f[2*i+1]!==a&&(e.opt_len+=(a-f[2*i+1])*f[2*i],f[2*i+1]=a),n--)}}(e,t),W(a,l,e.bl_count)}function $(e,t,r){var n,i,a=-1,o=t[1],s=0,f=7,l=4;for(0===o&&(f=138,l=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=o,o=t[2*(n+1)+1],++s<f&&i===o||(s<l?e.bl_tree[2*i]+=s:0!==i?(i!==a&&e.bl_tree[2*i]++,e.bl_tree[2*E]++):s<=10?e.bl_tree[2*x]++:e.bl_tree[2*k]++,s=0,a=i,0===o?(f=138,l=3):i===o?(f=6,l=3):(f=7,l=4))}function Q(e,t,r){var n,i,a=-1,o=t[1],s=0,f=7,l=4;for(0===o&&(f=138,l=3),n=0;n<=r;n++)if(i=o,o=t[2*(n+1)+1],!(++s<f&&i===o)){if(s<l)do{q(e,i,e.bl_tree)}while(0!=--s);else 0!==i?(i!==a&&(q(e,i,e.bl_tree),s--),q(e,E,e.bl_tree),C(e,s-3,2)):s<=10?(q(e,x,e.bl_tree),C(e,s-3,3)):(q(e,k,e.bl_tree),C(e,s-11,7));s=0,a=i,0===o?(f=138,l=3):i===o?(f=6,l=3):(f=7,l=4)}}f(M);var ee=!1;function te(e,t,r,i){C(e,(l<<1)+(i?1:0),3),function(e,t,r,i){G(e),i&&(Z(e,r),Z(e,~r)),n.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}t._tr_init=function(e){ee||(function(){var e,t,r,n,i,a=new Array(b+1);for(r=0,n=0;n<d-1;n++)for(L[n]=r,e=0;e<1<<S[n];e++)D[r++]=n;for(D[r-1]=n,i=0,n=0;n<16;n++)for(M[n]=i,e=0;e<1<<A[n];e++)I[i++]=n;for(i>>=7;n<g;n++)for(M[n]=i<<7,e=0;e<1<<A[n]-7;e++)I[256+i++]=n;for(t=0;t<=b;t++)a[t]=0;for(e=0;e<=143;)T[2*e+1]=8,e++,a[8]++;for(;e<=255;)T[2*e+1]=9,e++,a[9]++;for(;e<=279;)T[2*e+1]=7,e++,a[7]++;for(;e<=287;)T[2*e+1]=8,e++,a[8]++;for(W(T,p+1,a),e=0;e<g;e++)R[2*e+1]=5,R[2*e]=Y(e,5);F=new N(T,S,c+1,p,b),U=new N(R,A,0,g,b),B=new N(new Array(0),P,0,m,v)}(),ee=!0),e.l_desc=new j(e.dyn_ltree,F),e.d_desc=new j(e.dyn_dtree,U),e.bl_desc=new j(e.bl_tree,B),e.bi_buf=0,e.bi_valid=0,H(e)},t._tr_stored_block=te,t._tr_flush_block=function(e,t,r,n){var f,l,d=0;e.level>0?(e.strm.data_type===s&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return a;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return o;for(t=32;t<c;t++)if(0!==e.dyn_ltree[2*t])return o;return a}(e)),X(e,e.l_desc),X(e,e.d_desc),d=function(e){var t;for($(e,e.dyn_ltree,e.l_desc.max_code),$(e,e.dyn_dtree,e.d_desc.max_code),X(e,e.bl_desc),t=m-1;t>=3&&0===e.bl_tree[2*O[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),f=e.opt_len+3+7>>>3,(l=e.static_len+3+7>>>3)<=f&&(f=l)):f=l=r+5,r+4<=f&&-1!==t?te(e,t,r,n):e.strategy===i||l===f?(C(e,(u<<1)+(n?1:0),3),J(e,T,R)):(C(e,(h<<1)+(n?1:0),3),function(e,t,r,n){var i;for(C(e,t-257,5),C(e,r-1,5),C(e,n-4,4),i=0;i<n;i++)C(e,e.bl_tree[2*O[i]+1],3);Q(e,e.dyn_ltree,t-1),Q(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,d+1),J(e,e.dyn_ltree,e.dyn_dtree)),H(e),n&&G(e)},t._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(D[r]+c+1)]++,e.dyn_dtree[2*z(t)]++),e.last_lit===e.lit_bufsize-1},t._tr_align=function(e){C(e,u<<1,3),q(e,w,T),function(e){16===e.bi_valid?(Z(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},function(e,t,r){"use strict";var n,i=r(8),a=r(50),o=r(28),s=r(27),f=r(49),l=0,u=1,h=3,d=4,c=5,p=0,g=1,m=-2,_=-3,b=-5,y=-1,v=1,w=2,E=3,x=4,k=0,S=2,A=8,P=9,O=15,T=8,R=286,I=30,D=19,L=2*R+1,F=15,U=3,B=258,M=B+U+1,N=32,j=42,z=69,Z=73,C=91,q=103,Y=113,W=666,H=1,G=2,V=3,K=4,J=3;function X(e,t){return e.msg=f[t],t}function $(e){return(e<<1)-(e>4?9:0)}function Q(e){for(var t=e.length;--t>=0;)e[t]=0}function ee(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(i.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function te(e,t){a._tr_flush_block(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,ee(e.strm)}function re(e,t){e.pending_buf[e.pending++]=t}function ne(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function ie(e,t){var r,n,i=e.max_chain_length,a=e.strstart,o=e.prev_length,s=e.nice_match,f=e.strstart>e.w_size-M?e.strstart-(e.w_size-M):0,l=e.window,u=e.w_mask,h=e.prev,d=e.strstart+B,c=l[a+o-1],p=l[a+o];e.prev_length>=e.good_match&&(i>>=2),s>e.lookahead&&(s=e.lookahead);do{if(l[(r=t)+o]===p&&l[r+o-1]===c&&l[r]===l[a]&&l[++r]===l[a+1]){a+=2,r++;do{}while(l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&a<d);if(n=B-(d-a),a=d-B,n>o){if(e.match_start=t,o=n,n>=s)break;c=l[a+o-1],p=l[a+o]}}}while((t=h[t&u])>f&&0!=--i);return o<=e.lookahead?o:e.lookahead}function ae(e){var t,r,n,a,f,l,u,h,d,c,p=e.w_size;do{if(a=e.window_size-e.lookahead-e.strstart,e.strstart>=p+(p-M)){i.arraySet(e.window,e.window,p,p,0),e.match_start-=p,e.strstart-=p,e.block_start-=p,t=r=e.hash_size;do{n=e.head[--t],e.head[t]=n>=p?n-p:0}while(--r);t=r=p;do{n=e.prev[--t],e.prev[t]=n>=p?n-p:0}while(--r);a+=p}if(0===e.strm.avail_in)break;if(l=e.strm,u=e.window,h=e.strstart+e.lookahead,d=a,c=void 0,(c=l.avail_in)>d&&(c=d),r=0===c?0:(l.avail_in-=c,i.arraySet(u,l.input,l.next_in,c,h),1===l.state.wrap?l.adler=o(l.adler,u,c,h):2===l.state.wrap&&(l.adler=s(l.adler,u,c,h)),l.next_in+=c,l.total_in+=c,c),e.lookahead+=r,e.lookahead+e.insert>=U)for(f=e.strstart-e.insert,e.ins_h=e.window[f],e.ins_h=(e.ins_h<<e.hash_shift^e.window[f+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[f+U-1])&e.hash_mask,e.prev[f&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=f,f++,e.insert--,!(e.lookahead+e.insert<U)););}while(e.lookahead<M&&0!==e.strm.avail_in)}function oe(e,t){for(var r,n;;){if(e.lookahead<M){if(ae(e),e.lookahead<M&&t===l)return H;if(0===e.lookahead)break}if(r=0,e.lookahead>=U&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+U-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-M&&(e.match_length=ie(e,r)),e.match_length>=U)if(n=a._tr_tally(e,e.strstart-e.match_start,e.match_length-U),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=U){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+U-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=a._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(te(e,!1),0===e.strm.avail_out))return H}return e.insert=e.strstart<U-1?e.strstart:U-1,t===d?(te(e,!0),0===e.strm.avail_out?V:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?H:G}function se(e,t){for(var r,n,i;;){if(e.lookahead<M){if(ae(e),e.lookahead<M&&t===l)return H;if(0===e.lookahead)break}if(r=0,e.lookahead>=U&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+U-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=U-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-M&&(e.match_length=ie(e,r),e.match_length<=5&&(e.strategy===v||e.match_length===U&&e.strstart-e.match_start>4096)&&(e.match_length=U-1)),e.prev_length>=U&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-U,n=a._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-U),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+U-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=U-1,e.strstart++,n&&(te(e,!1),0===e.strm.avail_out))return H}else if(e.match_available){if((n=a._tr_tally(e,0,e.window[e.strstart-1]))&&te(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return H}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=a._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<U-1?e.strstart:U-1,t===d?(te(e,!0),0===e.strm.avail_out?V:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?H:G}function fe(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function le(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=S,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?j:Y,e.adler=2===t.wrap?0:1,t.last_flush=l,a._tr_init(t),p):X(e,m)}function ue(e){var t,r=le(e);return r===p&&((t=e.state).window_size=2*t.w_size,Q(t.head),t.max_lazy_match=n[t.level].max_lazy,t.good_match=n[t.level].good_length,t.nice_match=n[t.level].nice_length,t.max_chain_length=n[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=U-1,t.match_available=0,t.ins_h=0),r}function he(e,t,r,n,a,o){if(!e)return m;var s=1;if(t===y&&(t=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),a<1||a>P||r!==A||n<8||n>15||t<0||t>9||o<0||o>x)return X(e,m);8===n&&(n=9);var f=new function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=A,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new i.Buf16(2*L),this.dyn_dtree=new i.Buf16(2*(2*I+1)),this.bl_tree=new i.Buf16(2*(2*D+1)),Q(this.dyn_ltree),Q(this.dyn_dtree),Q(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new i.Buf16(F+1),this.heap=new i.Buf16(2*R+1),Q(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new i.Buf16(2*R+1),Q(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0};return e.state=f,f.strm=e,f.wrap=s,f.gzhead=null,f.w_bits=n,f.w_size=1<<f.w_bits,f.w_mask=f.w_size-1,f.hash_bits=a+7,f.hash_size=1<<f.hash_bits,f.hash_mask=f.hash_size-1,f.hash_shift=~~((f.hash_bits+U-1)/U),f.window=new i.Buf8(2*f.w_size),f.head=new i.Buf16(f.hash_size),f.prev=new i.Buf16(f.w_size),f.lit_bufsize=1<<a+6,f.pending_buf_size=4*f.lit_bufsize,f.pending_buf=new i.Buf8(f.pending_buf_size),f.d_buf=1*f.lit_bufsize,f.l_buf=3*f.lit_bufsize,f.level=t,f.strategy=o,f.method=r,ue(e)}n=[new fe(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(ae(e),0===e.lookahead&&t===l)return H;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,te(e,!1),0===e.strm.avail_out))return H;if(e.strstart-e.block_start>=e.w_size-M&&(te(e,!1),0===e.strm.avail_out))return H}return e.insert=0,t===d?(te(e,!0),0===e.strm.avail_out?V:K):(e.strstart>e.block_start&&(te(e,!1),e.strm.avail_out),H)}),new fe(4,4,8,4,oe),new fe(4,5,16,8,oe),new fe(4,6,32,32,oe),new fe(4,4,16,16,se),new fe(8,16,32,32,se),new fe(8,16,128,128,se),new fe(8,32,128,256,se),new fe(32,128,258,1024,se),new fe(32,258,258,4096,se)],t.deflateInit=function(e,t){return he(e,t,A,O,T,k)},t.deflateInit2=he,t.deflateReset=ue,t.deflateResetKeep=le,t.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?m:(e.state.gzhead=t,p):m},t.deflate=function(e,t){var r,i,o,f;if(!e||!e.state||t>c||t<0)return e?X(e,m):m;if(i=e.state,!e.output||!e.input&&0!==e.avail_in||i.status===W&&t!==d)return X(e,0===e.avail_out?b:m);if(i.strm=e,r=i.last_flush,i.last_flush=t,i.status===j)if(2===i.wrap)e.adler=0,re(i,31),re(i,139),re(i,8),i.gzhead?(re(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),re(i,255&i.gzhead.time),re(i,i.gzhead.time>>8&255),re(i,i.gzhead.time>>16&255),re(i,i.gzhead.time>>24&255),re(i,9===i.level?2:i.strategy>=w||i.level<2?4:0),re(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(re(i,255&i.gzhead.extra.length),re(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(e.adler=s(e.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=z):(re(i,0),re(i,0),re(i,0),re(i,0),re(i,0),re(i,9===i.level?2:i.strategy>=w||i.level<2?4:0),re(i,J),i.status=Y);else{var _=A+(i.w_bits-8<<4)<<8;_|=(i.strategy>=w||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(_|=N),_+=31-_%31,i.status=Y,ne(i,_),0!==i.strstart&&(ne(i,e.adler>>>16),ne(i,65535&e.adler)),e.adler=1}if(i.status===z)if(i.gzhead.extra){for(o=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),ee(e),o=i.pending,i.pending!==i.pending_buf_size));)re(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=Z)}else i.status=Z;if(i.status===Z)if(i.gzhead.name){o=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),ee(e),o=i.pending,i.pending===i.pending_buf_size)){f=1;break}f=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,re(i,f)}while(0!==f);i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),0===f&&(i.gzindex=0,i.status=C)}else i.status=C;if(i.status===C)if(i.gzhead.comment){o=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),ee(e),o=i.pending,i.pending===i.pending_buf_size)){f=1;break}f=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,re(i,f)}while(0!==f);i.gzhead.hcrc&&i.pending>o&&(e.adler=s(e.adler,i.pending_buf,i.pending-o,o)),0===f&&(i.status=q)}else i.status=q;if(i.status===q&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&ee(e),i.pending+2<=i.pending_buf_size&&(re(i,255&e.adler),re(i,e.adler>>8&255),e.adler=0,i.status=Y)):i.status=Y),0!==i.pending){if(ee(e),0===e.avail_out)return i.last_flush=-1,p}else if(0===e.avail_in&&$(t)<=$(r)&&t!==d)return X(e,b);if(i.status===W&&0!==e.avail_in)return X(e,b);if(0!==e.avail_in||0!==i.lookahead||t!==l&&i.status!==W){var y=i.strategy===w?function(e,t){for(var r;;){if(0===e.lookahead&&(ae(e),0===e.lookahead)){if(t===l)return H;break}if(e.match_length=0,r=a._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(te(e,!1),0===e.strm.avail_out))return H}return e.insert=0,t===d?(te(e,!0),0===e.strm.avail_out?V:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?H:G}(i,t):i.strategy===E?function(e,t){for(var r,n,i,o,s=e.window;;){if(e.lookahead<=B){if(ae(e),e.lookahead<=B&&t===l)return H;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=U&&e.strstart>0&&(n=s[i=e.strstart-1])===s[++i]&&n===s[++i]&&n===s[++i]){o=e.strstart+B;do{}while(n===s[++i]&&n===s[++i]&&n===s[++i]&&n===s[++i]&&n===s[++i]&&n===s[++i]&&n===s[++i]&&n===s[++i]&&i<o);e.match_length=B-(o-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=U?(r=a._tr_tally(e,1,e.match_length-U),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=a._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(te(e,!1),0===e.strm.avail_out))return H}return e.insert=0,t===d?(te(e,!0),0===e.strm.avail_out?V:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?H:G}(i,t):n[i.level].func(i,t);if(y!==V&&y!==K||(i.status=W),y===H||y===V)return 0===e.avail_out&&(i.last_flush=-1),p;if(y===G&&(t===u?a._tr_align(i):t!==c&&(a._tr_stored_block(i,0,0,!1),t===h&&(Q(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),ee(e),0===e.avail_out))return i.last_flush=-1,p}return t!==d?p:i.wrap<=0?g:(2===i.wrap?(re(i,255&e.adler),re(i,e.adler>>8&255),re(i,e.adler>>16&255),re(i,e.adler>>24&255),re(i,255&e.total_in),re(i,e.total_in>>8&255),re(i,e.total_in>>16&255),re(i,e.total_in>>24&255)):(ne(i,e.adler>>>16),ne(i,65535&e.adler)),ee(e),i.wrap>0&&(i.wrap=-i.wrap),0!==i.pending?p:g)},t.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==j&&t!==z&&t!==Z&&t!==C&&t!==q&&t!==Y&&t!==W?X(e,m):(e.state=null,t===Y?X(e,_):p):m},t.deflateSetDictionary=function(e,t){var r,n,a,s,f,l,u,h,d=t.length;if(!e||!e.state)return m;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==j||r.lookahead)return m;for(1===s&&(e.adler=o(e.adler,t,d,0)),r.wrap=0,d>=r.w_size&&(0===s&&(Q(r.head),r.strstart=0,r.block_start=0,r.insert=0),h=new i.Buf8(r.w_size),i.arraySet(h,t,d-r.w_size,r.w_size,0),t=h,d=r.w_size),f=e.avail_in,l=e.next_in,u=e.input,e.avail_in=d,e.next_in=0,e.input=t,ae(r);r.lookahead>=U;){n=r.strstart,a=r.lookahead-(U-1);do{r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+U-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++}while(--a);r.strstart=n,r.lookahead=U-1,ae(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=U-1,r.match_available=0,e.next_in=l,e.input=u,e.avail_in=f,r.wrap=s,p},t.deflateInfo="pako deflate (from Nodeca project)"},function(e,t,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},function(e,t){e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},function(e,t,r){"use strict";(function(e,n){var i=r(30),a=r(52),o=r(51),s=r(48),f=r(45);for(var l in f)t[l]=f[l];t.NONE=0,t.DEFLATE=1,t.INFLATE=2,t.GZIP=3,t.GUNZIP=4,t.DEFLATERAW=5,t.INFLATERAW=6,t.UNZIP=7;function u(e){if("number"!=typeof e||e<t.DEFLATE||e>t.UNZIP)throw new TypeError("Bad argument");this.dictionary=null,this.err=0,this.flush=0,this.init_done=!1,this.level=0,this.memLevel=0,this.mode=e,this.strategy=0,this.windowBits=0,this.write_in_progress=!1,this.pending_close=!1,this.gzip_id_bytes_read=0}u.prototype.close=function(){this.write_in_progress?this.pending_close=!0:(this.pending_close=!1,i(this.init_done,"close before init"),i(this.mode<=t.UNZIP),this.mode===t.DEFLATE||this.mode===t.GZIP||this.mode===t.DEFLATERAW?o.deflateEnd(this.strm):this.mode!==t.INFLATE&&this.mode!==t.GUNZIP&&this.mode!==t.INFLATERAW&&this.mode!==t.UNZIP||s.inflateEnd(this.strm),this.mode=t.NONE,this.dictionary=null)},u.prototype.write=function(e,t,r,n,i,a,o){return this._write(!0,e,t,r,n,i,a,o)},u.prototype.writeSync=function(e,t,r,n,i,a,o){return this._write(!1,e,t,r,n,i,a,o)},u.prototype._write=function(r,a,o,s,f,l,u,h){if(i.equal(arguments.length,8),i(this.init_done,"write before init"),i(this.mode!==t.NONE,"already finalized"),i.equal(!1,this.write_in_progress,"write already in progress"),i.equal(!1,this.pending_close,"close is pending"),this.write_in_progress=!0,i.equal(!1,void 0===a,"must provide flush value"),this.write_in_progress=!0,a!==t.Z_NO_FLUSH&&a!==t.Z_PARTIAL_FLUSH&&a!==t.Z_SYNC_FLUSH&&a!==t.Z_FULL_FLUSH&&a!==t.Z_FINISH&&a!==t.Z_BLOCK)throw new Error("Invalid flush value");if(null==o&&(o=e.alloc(0),f=0,s=0),this.strm.avail_in=f,this.strm.input=o,this.strm.next_in=s,this.strm.avail_out=h,this.strm.output=l,this.strm.next_out=u,this.flush=a,!r)return this._process(),this._checkError()?this._afterSync():void 0;var d=this;return n.nextTick(function(){d._process(),d._after()}),this},u.prototype._afterSync=function(){var e=this.strm.avail_out,t=this.strm.avail_in;return this.write_in_progress=!1,[t,e]},u.prototype._process=function(){var e=null;switch(this.mode){case t.DEFLATE:case t.GZIP:case t.DEFLATERAW:this.err=o.deflate(this.strm,this.flush);break;case t.UNZIP:switch(this.strm.avail_in>0&&(e=this.strm.next_in),this.gzip_id_bytes_read){case 0:if(null===e)break;if(31!==this.strm.input[e]){this.mode=t.INFLATE;break}if(this.gzip_id_bytes_read=1,e++,1===this.strm.avail_in)break;case 1:if(null===e)break;139===this.strm.input[e]?(this.gzip_id_bytes_read=2,this.mode=t.GUNZIP):this.mode=t.INFLATE;break;default:throw new Error("invalid number of gzip magic number bytes read")}case t.INFLATE:case t.GUNZIP:case t.INFLATERAW:for(this.err=s.inflate(this.strm,this.flush),this.err===t.Z_NEED_DICT&&this.dictionary&&(this.err=s.inflateSetDictionary(this.strm,this.dictionary),this.err===t.Z_OK?this.err=s.inflate(this.strm,this.flush):this.err===t.Z_DATA_ERROR&&(this.err=t.Z_NEED_DICT));this.strm.avail_in>0&&this.mode===t.GUNZIP&&this.err===t.Z_STREAM_END&&0!==this.strm.next_in[0];)this.reset(),this.err=s.inflate(this.strm,this.flush);break;default:throw new Error("Unknown mode "+this.mode)}},u.prototype._checkError=function(){switch(this.err){case t.Z_OK:case t.Z_BUF_ERROR:if(0!==this.strm.avail_out&&this.flush===t.Z_FINISH)return this._error("unexpected end of file"),!1;break;case t.Z_STREAM_END:break;case t.Z_NEED_DICT:return null==this.dictionary?this._error("Missing dictionary"):this._error("Bad dictionary"),!1;default:return this._error("Zlib error"),!1}return!0},u.prototype._after=function(){if(this._checkError()){var e=this.strm.avail_out,t=this.strm.avail_in;this.write_in_progress=!1,this.callback(t,e),this.pending_close&&this.close()}},u.prototype._error=function(e){this.strm.msg&&(e=this.strm.msg),this.onerror(e,this.err),this.write_in_progress=!1,this.pending_close&&this.close()},u.prototype.init=function(e,r,n,a,o){i(4===arguments.length||5===arguments.length,"init(windowBits, level, memLevel, strategy, [dictionary])"),i(e>=8&&e<=15,"invalid windowBits"),i(r>=-1&&r<=9,"invalid compression level"),i(n>=1&&n<=9,"invalid memlevel"),i(a===t.Z_FILTERED||a===t.Z_HUFFMAN_ONLY||a===t.Z_RLE||a===t.Z_FIXED||a===t.Z_DEFAULT_STRATEGY,"invalid strategy"),this._init(r,e,n,a,o),this._setDictionary()},u.prototype.params=function(){throw new Error("deflateParams Not supported")},u.prototype.reset=function(){this._reset(),this._setDictionary()},u.prototype._init=function(e,r,n,i,f){switch(this.level=e,this.windowBits=r,this.memLevel=n,this.strategy=i,this.flush=t.Z_NO_FLUSH,this.err=t.Z_OK,this.mode!==t.GZIP&&this.mode!==t.GUNZIP||(this.windowBits+=16),this.mode===t.UNZIP&&(this.windowBits+=32),this.mode!==t.DEFLATERAW&&this.mode!==t.INFLATERAW||(this.windowBits=-1*this.windowBits),this.strm=new a,this.mode){case t.DEFLATE:case t.GZIP:case t.DEFLATERAW:this.err=o.deflateInit2(this.strm,this.level,t.Z_DEFLATED,this.windowBits,this.memLevel,this.strategy);break;case t.INFLATE:case t.GUNZIP:case t.INFLATERAW:case t.UNZIP:this.err=s.inflateInit2(this.strm,this.windowBits);break;default:throw new Error("Unknown mode "+this.mode)}this.err!==t.Z_OK&&this._error("Init error"),this.dictionary=f,this.write_in_progress=!1,this.init_done=!0},u.prototype._setDictionary=function(){if(null!=this.dictionary){switch(this.err=t.Z_OK,this.mode){case t.DEFLATE:case t.DEFLATERAW:this.err=o.deflateSetDictionary(this.strm,this.dictionary)}this.err!==t.Z_OK&&this._error("Failed to set dictionary")}},u.prototype._reset=function(){switch(this.err=t.Z_OK,this.mode){case t.DEFLATE:case t.DEFLATERAW:case t.GZIP:this.err=o.deflateReset(this.strm);break;case t.INFLATE:case t.INFLATERAW:case t.GUNZIP:this.err=s.inflateReset(this.strm)}this.err!==t.Z_OK&&this._error("Failed to reset stream")},t.Zlib=u}).call(this,r(1).Buffer,r(3))},function(e,t,r){e.exports=r(19).PassThrough},function(e,t,r){e.exports=r(19).Transform},function(e,t,r){e.exports=r(2)},function(e,t,r){e.exports=r(18)},function(e,t,r){"use strict";e.exports=a;var n=r(31),i=r(6);function a(e){if(!(this instanceof a))return new a(e);n.call(this,e)}i.inherits=r(5),i.inherits(a,n),a.prototype._transform=function(e,t,r){r(null,e)}},function(e,t,r){(function(t){function r(e){try{if(!t.localStorage)return!1}catch(e){return!1}var r=t.localStorage[e];return null!=r&&"true"===String(r).toLowerCase()}e.exports=function(e,t){if(r("noDeprecation"))return e;var n=!1;return function(){if(!n){if(r("throwDeprecation"))throw new Error(t);r("traceDeprecation")?console.trace(t):console.warn(t),n=!0}return e.apply(this,arguments)}}}).call(this,r(0))},function(e,t,r){(function(e,t){!function(e,r){"use strict";if(!e.setImmediate){var n,i,a,o,s,f=1,l={},u=!1,h=e.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(e);d=d&&d.setTimeout?d:e,"[object process]"==={}.toString.call(e.process)?n=function(e){t.nextTick(function(){p(e)})}:!function(){if(e.postMessage&&!e.importScripts){var t=!0,r=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=r,t}}()?e.MessageChannel?((a=new MessageChannel).port1.onmessage=function(e){p(e.data)},n=function(e){a.port2.postMessage(e)}):h&&"onreadystatechange"in h.createElement("script")?(i=h.documentElement,n=function(e){var t=h.createElement("script");t.onreadystatechange=function(){p(e),t.onreadystatechange=null,i.removeChild(t),t=null},i.appendChild(t)}):n=function(e){setTimeout(p,0,e)}:(o="setImmediate$"+Math.random()+"$",s=function(t){t.source===e&&"string"==typeof t.data&&0===t.data.indexOf(o)&&p(+t.data.slice(o.length))},e.addEventListener?e.addEventListener("message",s,!1):e.attachEvent("onmessage",s),n=function(t){e.postMessage(o+t,"*")}),d.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var i={callback:e,args:t};return l[f]=i,n(f),f++},d.clearImmediate=c}function c(e){delete l[e]}function p(e){if(u)setTimeout(p,0,e);else{var t=l[e];if(t){u=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(r,n)}}(t)}finally{c(e),u=!1}}}}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,r(0),r(3))},function(e,t,r){(function(e){var n=Function.prototype.apply;function i(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new i(n.call(setTimeout,window,arguments),clearTimeout)},t.setInterval=function(){return new i(n.call(setInterval,window,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},i.prototype.unref=i.prototype.ref=function(){},i.prototype.close=function(){this._clearFn.call(window,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout(function(){e._onTimeout&&e._onTimeout()},t))},r(62),t.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==e&&e.clearImmediate||this&&this.clearImmediate}).call(this,r(0))},function(e,t){},function(e,t,r){"use strict";var n=r(9).Buffer,i=r(64);e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}return e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},e.prototype.clear=function(){this.head=this.tail=null,this.length=0},e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r},e.prototype.concat=function(e){if(0===this.length)return n.alloc(0);if(1===this.length)return this.head.data;for(var t,r,i,a=n.allocUnsafe(e>>>0),o=this.head,s=0;o;)t=o.data,r=a,i=s,t.copy(r,i),s+=o.data.length,o=o.next;return a},e}(),i&&i.inspect&&i.inspect.custom&&(e.exports.prototype[i.inspect.custom]=function(){var e=i.inspect({length:this.length});return this.constructor.name+" "+e})},function(e,t){},function(e,t,r){e.exports=i;var n=r(20).EventEmitter;function i(){n.call(this)}r(5)(i,n),i.Readable=r(19),i.Writable=r(59),i.Duplex=r(58),i.Transform=r(57),i.PassThrough=r(56),i.Stream=i,i.prototype.pipe=function(e,t){var r=this;function i(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause()}function a(){r.readable&&r.resume&&r.resume()}r.on("data",i),e.on("drain",a),e._isStdio||t&&!1===t.end||(r.on("end",s),r.on("close",f));var o=!1;function s(){o||(o=!0,e.end())}function f(){o||(o=!0,"function"==typeof e.destroy&&e.destroy())}function l(e){if(u(),0===n.listenerCount(this,"error"))throw e}function u(){r.removeListener("data",i),e.removeListener("drain",a),r.removeListener("end",s),r.removeListener("close",f),r.removeListener("error",l),e.removeListener("error",l),r.removeListener("end",u),r.removeListener("close",u),e.removeListener("close",u)}return r.on("error",l),e.on("error",l),r.on("end",u),r.on("close",u),e.on("close",u),e.emit("pipe",r),e}},function(e,t,r){"use strict";(function(e){var n=r(1).Buffer,i=r(67).Transform,a=r(55),o=r(29),s=r(30).ok,f=r(1).kMaxLength,l="Cannot create final Buffer. It would be larger than 0x"+f.toString(16)+" bytes";a.Z_MIN_WINDOWBITS=8,a.Z_MAX_WINDOWBITS=15,a.Z_DEFAULT_WINDOWBITS=15,a.Z_MIN_CHUNK=64,a.Z_MAX_CHUNK=1/0,a.Z_DEFAULT_CHUNK=16384,a.Z_MIN_MEMLEVEL=1,a.Z_MAX_MEMLEVEL=9,a.Z_DEFAULT_MEMLEVEL=8,a.Z_MIN_LEVEL=-1,a.Z_MAX_LEVEL=9,a.Z_DEFAULT_LEVEL=a.Z_DEFAULT_COMPRESSION;for(var u=Object.keys(a),h=0;h<u.length;h++){var d=u[h];d.match(/^Z/)&&Object.defineProperty(t,d,{enumerable:!0,value:a[d],writable:!1})}for(var c={Z_OK:a.Z_OK,Z_STREAM_END:a.Z_STREAM_END,Z_NEED_DICT:a.Z_NEED_DICT,Z_ERRNO:a.Z_ERRNO,Z_STREAM_ERROR:a.Z_STREAM_ERROR,Z_DATA_ERROR:a.Z_DATA_ERROR,Z_MEM_ERROR:a.Z_MEM_ERROR,Z_BUF_ERROR:a.Z_BUF_ERROR,Z_VERSION_ERROR:a.Z_VERSION_ERROR},p=Object.keys(c),g=0;g<p.length;g++){var m=p[g];c[c[m]]=m}function _(e,t,r){var i=[],a=0;function o(){for(var t;null!==(t=e.read());)i.push(t),a+=t.length;e.once("readable",o)}function s(){var t,o=null;a>=f?o=new RangeError(l):t=n.concat(i,a),i=[],e.close(),r(o,t)}e.on("error",function(t){e.removeListener("end",s),e.removeListener("readable",o),r(t)}),e.on("end",s),e.end(t),o()}function b(e,t){if("string"==typeof t&&(t=n.from(t)),!n.isBuffer(t))throw new TypeError("Not a string or buffer");var r=e._finishFlushFlag;return e._processChunk(t,r)}function y(e){if(!(this instanceof y))return new y(e);P.call(this,e,a.DEFLATE)}function v(e){if(!(this instanceof v))return new v(e);P.call(this,e,a.INFLATE)}function w(e){if(!(this instanceof w))return new w(e);P.call(this,e,a.GZIP)}function E(e){if(!(this instanceof E))return new E(e);P.call(this,e,a.GUNZIP)}function x(e){if(!(this instanceof x))return new x(e);P.call(this,e,a.DEFLATERAW)}function k(e){if(!(this instanceof k))return new k(e);P.call(this,e,a.INFLATERAW)}function S(e){if(!(this instanceof S))return new S(e);P.call(this,e,a.UNZIP)}function A(e){return e===a.Z_NO_FLUSH||e===a.Z_PARTIAL_FLUSH||e===a.Z_SYNC_FLUSH||e===a.Z_FULL_FLUSH||e===a.Z_FINISH||e===a.Z_BLOCK}function P(e,r){var o=this;if(this._opts=e=e||{},this._chunkSize=e.chunkSize||t.Z_DEFAULT_CHUNK,i.call(this,e),e.flush&&!A(e.flush))throw new Error("Invalid flush flag: "+e.flush);if(e.finishFlush&&!A(e.finishFlush))throw new Error("Invalid flush flag: "+e.finishFlush);if(this._flushFlag=e.flush||a.Z_NO_FLUSH,this._finishFlushFlag=void 0!==e.finishFlush?e.finishFlush:a.Z_FINISH,e.chunkSize&&(e.chunkSize<t.Z_MIN_CHUNK||e.chunkSize>t.Z_MAX_CHUNK))throw new Error("Invalid chunk size: "+e.chunkSize);if(e.windowBits&&(e.windowBits<t.Z_MIN_WINDOWBITS||e.windowBits>t.Z_MAX_WINDOWBITS))throw new Error("Invalid windowBits: "+e.windowBits);if(e.level&&(e.level<t.Z_MIN_LEVEL||e.level>t.Z_MAX_LEVEL))throw new Error("Invalid compression level: "+e.level);if(e.memLevel&&(e.memLevel<t.Z_MIN_MEMLEVEL||e.memLevel>t.Z_MAX_MEMLEVEL))throw new Error("Invalid memLevel: "+e.memLevel);if(e.strategy&&e.strategy!=t.Z_FILTERED&&e.strategy!=t.Z_HUFFMAN_ONLY&&e.strategy!=t.Z_RLE&&e.strategy!=t.Z_FIXED&&e.strategy!=t.Z_DEFAULT_STRATEGY)throw new Error("Invalid strategy: "+e.strategy);if(e.dictionary&&!n.isBuffer(e.dictionary))throw new Error("Invalid dictionary: it should be a Buffer instance");this._handle=new a.Zlib(r);var s=this;this._hadError=!1,this._handle.onerror=function(e,r){O(s),s._hadError=!0;var n=new Error(e);n.errno=r,n.code=t.codes[r],s.emit("error",n)};var f=t.Z_DEFAULT_COMPRESSION;"number"==typeof e.level&&(f=e.level);var l=t.Z_DEFAULT_STRATEGY;"number"==typeof e.strategy&&(l=e.strategy),this._handle.init(e.windowBits||t.Z_DEFAULT_WINDOWBITS,f,e.memLevel||t.Z_DEFAULT_MEMLEVEL,l,e.dictionary),this._buffer=n.allocUnsafe(this._chunkSize),this._offset=0,this._level=f,this._strategy=l,this.once("end",this.close),Object.defineProperty(this,"_closed",{get:function(){return!o._handle},configurable:!0,enumerable:!0})}function O(t,r){r&&e.nextTick(r),t._handle&&(t._handle.close(),t._handle=null)}function T(e){e.emit("close")}Object.defineProperty(t,"codes",{enumerable:!0,value:Object.freeze(c),writable:!1}),t.Deflate=y,t.Inflate=v,t.Gzip=w,t.Gunzip=E,t.DeflateRaw=x,t.InflateRaw=k,t.Unzip=S,t.createDeflate=function(e){return new y(e)},t.createInflate=function(e){return new v(e)},t.createDeflateRaw=function(e){return new x(e)},t.createInflateRaw=function(e){return new k(e)},t.createGzip=function(e){return new w(e)},t.createGunzip=function(e){return new E(e)},t.createUnzip=function(e){return new S(e)},t.deflate=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new y(t),e,r)},t.deflateSync=function(e,t){return b(new y(t),e)},t.gzip=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new w(t),e,r)},t.gzipSync=function(e,t){return b(new w(t),e)},t.deflateRaw=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new x(t),e,r)},t.deflateRawSync=function(e,t){return b(new x(t),e)},t.unzip=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new S(t),e,r)},t.unzipSync=function(e,t){return b(new S(t),e)},t.inflate=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new v(t),e,r)},t.inflateSync=function(e,t){return b(new v(t),e)},t.gunzip=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new E(t),e,r)},t.gunzipSync=function(e,t){return b(new E(t),e)},t.inflateRaw=function(e,t,r){return"function"==typeof t&&(r=t,t={}),_(new k(t),e,r)},t.inflateRawSync=function(e,t){return b(new k(t),e)},o.inherits(P,i),P.prototype.params=function(r,n,i){if(r<t.Z_MIN_LEVEL||r>t.Z_MAX_LEVEL)throw new RangeError("Invalid compression level: "+r);if(n!=t.Z_FILTERED&&n!=t.Z_HUFFMAN_ONLY&&n!=t.Z_RLE&&n!=t.Z_FIXED&&n!=t.Z_DEFAULT_STRATEGY)throw new TypeError("Invalid strategy: "+n);if(this._level!==r||this._strategy!==n){var o=this;this.flush(a.Z_SYNC_FLUSH,function(){s(o._handle,"zlib binding closed"),o._handle.params(r,n),o._hadError||(o._level=r,o._strategy=n,i&&i())})}else e.nextTick(i)},P.prototype.reset=function(){return s(this._handle,"zlib binding closed"),this._handle.reset()},P.prototype._flush=function(e){this._transform(n.alloc(0),"",e)},P.prototype.flush=function(t,r){var i=this,o=this._writableState;("function"==typeof t||void 0===t&&!r)&&(r=t,t=a.Z_FULL_FLUSH),o.ended?r&&e.nextTick(r):o.ending?r&&this.once("end",r):o.needDrain?r&&this.once("drain",function(){return i.flush(t,r)}):(this._flushFlag=t,this.write(n.alloc(0),"",r))},P.prototype.close=function(t){O(this,t),e.nextTick(T,this)},P.prototype._transform=function(e,t,r){var i,o=this._writableState,s=(o.ending||o.ended)&&(!e||o.length===e.length);return null===e||n.isBuffer(e)?this._handle?(s?i=this._finishFlushFlag:(i=this._flushFlag,e.length>=o.length&&(this._flushFlag=this._opts.flush||a.Z_NO_FLUSH)),void this._processChunk(e,i,r)):r(new Error("zlib binding closed")):r(new Error("invalid input"))},P.prototype._processChunk=function(e,t,r){var i=e&&e.length,a=this._chunkSize-this._offset,o=0,u=this,h="function"==typeof r;if(!h){var d,c=[],p=0;this.on("error",function(e){d=e}),s(this._handle,"zlib binding closed");do{var g=this._handle.writeSync(t,e,o,i,this._buffer,this._offset,a)}while(!this._hadError&&b(g[0],g[1]));if(this._hadError)throw d;if(p>=f)throw O(this),new RangeError(l);var m=n.concat(c,p);return O(this),m}s(this._handle,"zlib binding closed");var _=this._handle.write(t,e,o,i,this._buffer,this._offset,a);function b(f,l){if(this&&(this.buffer=null,this.callback=null),!u._hadError){var d=a-l;if(s(d>=0,"have should not go down"),d>0){var g=u._buffer.slice(u._offset,u._offset+d);u._offset+=d,h?u.push(g):(c.push(g),p+=g.length)}if((0===l||u._offset>=u._chunkSize)&&(a=u._chunkSize,u._offset=0,u._buffer=n.allocUnsafe(u._chunkSize)),0===l){if(o+=i-f,i=f,!h)return!0;var m=u._handle.write(t,e,o,i,u._buffer,u._offset,u._chunkSize);return m.callback=b,void(m.buffer=e)}if(!h)return!1;r()}}_.buffer=e,_.callback=b},o.inherits(y,P),o.inherits(v,P),o.inherits(w,P),o.inherits(E,P),o.inherits(x,P),o.inherits(k,P),o.inherits(S,P)}).call(this,r(3))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t,d){if(void 0===t)throw"dicomParser.parseDicom: missing required parameter 'byteArray'";function c(f){var c=function(e){if(void 0===e.elements.x00020010)throw"dicomParser.parseDicom: missing required meta header attribute 0002,0010";var r=e.elements.x00020010;return u.readFixedString(t,r.dataOffset,r.length)}(f),p=function(e){if("1.2.840.10008.1.2"===e)return!1;return!0}(c),g=function(o,f){if("1.2.840.10008.1.2.1.99"===o){if(d&&d.inflater){var u=d.inflater(t,f);return new a.default(s.default,u,0)}if(void 0!==e&&this.module!==e){var h=r(68),c=(0,l.default)(t,f,t.length-f),p=h.inflateRawSync(c),g=(0,n.default)(t,p.length+f);return t.copy(g,0,0,f),p.copy(g,f),new a.default(s.default,g,0)}if("undefined"!=typeof pako){var m=t.slice(f),_=pako.inflateRaw(m),b=(0,n.default)(t,_.length+f);return b.set(t.slice(0,f),0),b.set(_,f),new a.default(s.default,b,0)}throw"dicomParser.parseDicom: no inflater available to handle deflate transfer syntax"}if("1.2.840.10008.1.2.2"===o)return new a.default(i.default,t,f);return new a.default(s.default,t,f)}(c,f.position),m=new o.default(g.byteArrayParser,g.byteArray,{});m.warnings=g.warnings;try{p?h.parseDicomDataSetExplicit(m,g,g.byteArray.length,d):h.parseDicomDataSetImplicit(m,g,g.byteArray.length,d)}catch(e){var _={exception:e,dataSet:m};throw _}return m}return p=(0,f.default)(t,d),g=c(p),function(e,t){for(var r in e.elements)e.elements.hasOwnProperty(r)&&(t.elements[r]=e.elements[r]);return void 0!==e.warnings&&(t.warnings=e.warnings.concat(t.warnings)),t}(p,g);var p,g};var n=c(r(22)),i=c(r(37)),a=c(r(12)),o=c(r(7)),s=c(r(21)),f=c(r(36)),l=c(r(11)),u=d(r(14)),h=d(r(16));function d(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function c(e){return e&&e.__esModule?e:{default:e}}}).call(this,r(69)(e))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default="1.8.1"},function(e,t){t.read=function(e,t,r,n,i){var a,o,s=8*i-n-1,f=(1<<s)-1,l=f>>1,u=-7,h=r?i-1:0,d=r?-1:1,c=e[t+h];for(h+=d,a=c&(1<<-u)-1,c>>=-u,u+=s;u>0;a=256*a+e[t+h],h+=d,u-=8);for(o=a&(1<<-u)-1,a>>=-u,u+=n;u>0;o=256*o+e[t+h],h+=d,u-=8);if(0===a)a=1-l;else{if(a===f)return o?NaN:1/0*(c?-1:1);o+=Math.pow(2,n),a-=l}return(c?-1:1)*o*Math.pow(2,a-n)},t.write=function(e,t,r,n,i,a){var o,s,f,l=8*a-i-1,u=(1<<l)-1,h=u>>1,d=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,c=n?0:a-1,p=n?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,o=u):(o=Math.floor(Math.log(t)/Math.LN2),t*(f=Math.pow(2,-o))<1&&(o--,f*=2),(t+=o+h>=1?d/f:d*Math.pow(2,1-h))*f>=2&&(o++,f/=2),o+h>=u?(s=0,o=u):o+h>=1?(s=(t*f-1)*Math.pow(2,i),o+=h):(s=t*Math.pow(2,h-1)*Math.pow(2,i),o=0));i>=8;e[r+c]=255&s,c+=p,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;e[r+c]=255&o,c+=p,o/=256,l-=8);e[r+c-p]|=128*g}},function(e,t,r){"use strict";t.byteLength=function(e){return 3*e.length/4-l(e)},t.toByteArray=function(e){var t,r,n,o,s,f=e.length;o=l(e),s=new a(3*f/4-o),r=o>0?f-4:f;var u=0;for(t=0;t<r;t+=4)n=i[e.charCodeAt(t)]<<18|i[e.charCodeAt(t+1)]<<12|i[e.charCodeAt(t+2)]<<6|i[e.charCodeAt(t+3)],s[u++]=n>>16&255,s[u++]=n>>8&255,s[u++]=255&n;2===o?(n=i[e.charCodeAt(t)]<<2|i[e.charCodeAt(t+1)]>>4,s[u++]=255&n):1===o&&(n=i[e.charCodeAt(t)]<<10|i[e.charCodeAt(t+1)]<<4|i[e.charCodeAt(t+2)]>>2,s[u++]=n>>8&255,s[u++]=255&n);return s},t.fromByteArray=function(e){for(var t,r=e.length,i=r%3,a="",o=[],s=0,f=r-i;s<f;s+=16383)o.push(u(e,s,s+16383>f?f:s+16383));1===i?(t=e[r-1],a+=n[t>>2],a+=n[t<<4&63],a+="=="):2===i&&(t=(e[r-2]<<8)+e[r-1],a+=n[t>>10],a+=n[t>>4&63],a+=n[t<<2&63],a+="=");return o.push(a),o.join("")};for(var n=[],i=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,f=o.length;s<f;++s)n[s]=o[s],i[o.charCodeAt(s)]=s;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function u(e,t,r){for(var i,a,o=[],s=t;s<r;s+=3)i=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),o.push(n[(a=i)>>18&63]+n[a>>12&63]+n[a>>6&63]+n[63&a]);return o.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,t,r){"use strict";function n(e,t){return 255===e.byteArray[t]&&217===e.byteArray[t+1]}function i(e,t,r){var i=t.fragments[r];return!(!n(e,i.position+i.length-2)&&!n(e,i.position+i.length-3))}function a(e,t,r){for(var n=r;n<t.fragments.length;n++)if(i(e,t,n))return n}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(void 0===e)throw"dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet";if(void 0===t)throw"dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement";if("x7fe00010"!==t.tag)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";if(!0!==t.encapsulatedPixelData)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(!0!==t.hadUndefinedLength)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.basicOffsetTable)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(void 0===t.fragments)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(t.fragments.length<=0)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";if(r&&r.length<=0)throw"dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";r=r||t.fragments;var n=[],i=0;for(;;){n.push(t.fragments[i].offset);var o=a(e,t,i);if(void 0===o||o===t.fragments.length-1)return n;i=o+1}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r){if(void 0===t)throw"dicomParser.explicitDataSetToJS: missing required parameter dataSet";r=r||{omitPrivateAttibutes:!0,maxElementLength:128};var n={};for(var i in t.elements){var s=t.elements[i];if(!0!==r.omitPrivateAttibutes||!o.isPrivateTag(i))if(s.items){for(var f=[],l=0;l<s.items.length;l++)f.push(e(s.items[l].dataSet,r));n[i]=f}else{var u;u=void 0,s.length<r.maxElementLength&&(u=(0,a.default)(t,s)),n[i]=void 0!==u?u:{dataOffset:s.dataOffset,length:s.length}}}return n};var n,i=r(43),a=(n=i)&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(25))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e&&8===e.length){var r=parseInt(e.substring(0,4),10),n=parseInt(e.substring(4,6),10),i=parseInt(e.substring(6,8),10);if(t&&!0!==function(e,t,r){if(isNaN(r))return!1;return t>0&&t<=12&&e>0&&e<=function(e,t){switch(e){case 2:return t%4==0&&t%100||t%400==0?29:28;case 9:case 4:case 6:case 11:return 30;default:return 31}}(t,r)}(i,n,r))throw"invalid DA '"+e+"'";return{year:r,month:n,day:i}}if(t)throw"invalid DA '"+e+"'";return}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e.length>=2){var r=parseInt(e.substring(0,2),10),n=e.length>=4?parseInt(e.substring(2,4),10):void 0,i=e.length>=6?parseInt(e.substring(4,6),10):void 0,a=e.length>=8?parseInt(e.substring(7,13),10):void 0;if(t&&(isNaN(r)||void 0!==n&&isNaN(n)||void 0!==i&&isNaN(i)||void 0!==a&&isNaN(a)||r<0||r>23||n&&(n<0||n>59)||i&&(i<0||i>59)||a&&(a<0||a>999999)))throw"invalid TM '"+e+"'";return{hours:r,minutes:n,seconds:i,fractionalSeconds:a}}if(t)throw"invalid TM '"+e+"'";return}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(25);Object.keys(n).forEach(function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})});var i=r(77);Object.defineProperty(t,"parseTM",{enumerable:!0,get:function(){return l(i).default}});var a=r(76);Object.defineProperty(t,"parseDA",{enumerable:!0,get:function(){return l(a).default}});var o=r(43);Object.defineProperty(t,"explicitElementToString",{enumerable:!0,get:function(){return l(o).default}});var s=r(75);Object.defineProperty(t,"explicitDataSetToJS",{enumerable:!0,get:function(){return l(s).default}});var f=r(74);function l(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"createJPEGBasicOffsetTable",{enumerable:!0,get:function(){return l(f).default}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(78);Object.keys(n).forEach(function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}})});var i=r(16);Object.keys(i).forEach(function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})});var a=r(14);Object.keys(a).forEach(function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}})});var o=r(22);Object.defineProperty(t,"alloc",{enumerable:!0,get:function(){return P(o).default}});var s=r(71);Object.defineProperty(t,"version",{enumerable:!0,get:function(){return P(s).default}});var f=r(37);Object.defineProperty(t,"bigEndianByteArrayParser",{enumerable:!0,get:function(){return P(f).default}});var l=r(12);Object.defineProperty(t,"ByteStream",{enumerable:!0,get:function(){return P(l).default}});var u=r(11);Object.defineProperty(t,"sharedCopy",{enumerable:!0,get:function(){return P(u).default}});var h=r(7);Object.defineProperty(t,"DataSet",{enumerable:!0,get:function(){return P(h).default}});var d=r(41);Object.defineProperty(t,"findAndSetUNElementLength",{enumerable:!0,get:function(){return P(d).default}});var c=r(42);Object.defineProperty(t,"findEndOfEncapsulatedElement",{enumerable:!0,get:function(){return P(c).default}});var p=r(24);Object.defineProperty(t,"findItemDelimitationItemAndSetElementLength",{enumerable:!0,get:function(){return P(p).default}});var g=r(21);Object.defineProperty(t,"littleEndianByteArrayParser",{enumerable:!0,get:function(){return P(g).default}});var m=r(70);Object.defineProperty(t,"parseDicom",{enumerable:!0,get:function(){return P(m).default}});var _=r(15);Object.defineProperty(t,"readDicomElementExplicit",{enumerable:!0,get:function(){return P(_).default}});var b=r(23);Object.defineProperty(t,"readDicomElementImplicit",{enumerable:!0,get:function(){return P(b).default}});var y=r(26);Object.defineProperty(t,"readEncapsulatedImageFrame",{enumerable:!0,get:function(){return P(y).default}});var v=r(44);Object.defineProperty(t,"readEncapsulatedPixelData",{enumerable:!0,get:function(){return P(v).default}});var w=r(17);Object.defineProperty(t,"readEncapsulatedPixelDataFromFragments",{enumerable:!0,get:function(){return P(w).default}});var E=r(36);Object.defineProperty(t,"readPart10Header",{enumerable:!0,get:function(){return P(E).default}});var x=r(40);Object.defineProperty(t,"readSequenceItemsExplicit",{enumerable:!0,get:function(){return P(x).default}});var k=r(39);Object.defineProperty(t,"readSequenceItemsImplicit",{enumerable:!0,get:function(){return P(k).default}});var S=r(13);Object.defineProperty(t,"readSequenceItem",{enumerable:!0,get:function(){return P(S).default}});var A=r(4);function P(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"readTag",{enumerable:!0,get:function(){return P(A).default}})}])});
//# sourceMappingURL=dicomParser.min.js.map
},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],8:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],9:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],11:[function(require,module,exports){
(function (process,global){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var getArguments = _interopDefault(require('argsarray'));
var nextTick = _interopDefault(require('immediate'));
var events = require('events');
var inherits = _interopDefault(require('inherits'));
var Md5 = _interopDefault(require('spark-md5'));
var uuidV4 = _interopDefault(require('uuid'));
var vuvuzela = _interopDefault(require('vuvuzela'));

function isBinaryObject(object) {
  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
    (typeof Blob !== 'undefined' && object instanceof Blob);
}

function cloneArrayBuffer(buff) {
  if (typeof buff.slice === 'function') {
    return buff.slice(0);
  }
  // IE10-11 slice() polyfill
  var target = new ArrayBuffer(buff.byteLength);
  var targetArray = new Uint8Array(target);
  var sourceArray = new Uint8Array(buff);
  targetArray.set(sourceArray);
  return target;
}

function cloneBinaryObject(object) {
  if (object instanceof ArrayBuffer) {
    return cloneArrayBuffer(object);
  }
  var size = object.size;
  var type = object.type;
  // Blob
  if (typeof object.slice === 'function') {
    return object.slice(0, size, type);
  }
  // PhantomJS slice() replacement
  return object.webkitSlice(0, size, type);
}

// most of this is borrowed from lodash.isPlainObject:
// https://github.com/fis-components/lodash.isplainobject/
// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(value) {
  var proto = Object.getPrototypeOf(value);
  /* istanbul ignore if */
  if (proto === null) { // not sure when this happens, but I guess it can
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

function clone(object) {
  var newObject;
  var i;
  var len;

  if (!object || typeof object !== 'object') {
    return object;
  }

  if (Array.isArray(object)) {
    newObject = [];
    for (i = 0, len = object.length; i < len; i++) {
      newObject[i] = clone(object[i]);
    }
    return newObject;
  }

  // special case: to avoid inconsistencies between IndexedDB
  // and other backends, we automatically stringify Dates
  if (object instanceof Date) {
    return object.toISOString();
  }

  if (isBinaryObject(object)) {
    return cloneBinaryObject(object);
  }

  if (!isPlainObject(object)) {
    return object; // don't clone objects like Workers
  }

  newObject = {};
  for (i in object) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(object, i)) {
      var value = clone(object[i]);
      if (typeof value !== 'undefined') {
        newObject[i] = value;
      }
    }
  }
  return newObject;
}

function once(fun) {
  var called = false;
  return getArguments(function (args) {
    /* istanbul ignore if */
    if (called) {
      // this is a smoke test and should never actually happen
      throw new Error('once called more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
}

function toPromise(func) {
  //create the function we will be returning
  return getArguments(function (args) {
    // Clone arguments
    args = clone(args);
    var self = this;
    // if the last argument is a function, assume its a callback
    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    var promise = new Promise(function (fulfill, reject) {
      var resp;
      try {
        var callback = once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    return promise;
  });
}

function logApiCall(self, name, args) {
  /* istanbul ignore if */
  if (self.constructor.listeners('debug').length) {
    var logArgs = ['api', self.name, name];
    for (var i = 0; i < args.length - 1; i++) {
      logArgs.push(args[i]);
    }
    self.constructor.emit('debug', logArgs);

    // override the callback itself to log the response
    var origCallback = args[args.length - 1];
    args[args.length - 1] = function (err, res) {
      var responseArgs = ['api', self.name, name];
      responseArgs = responseArgs.concat(
        err ? ['error', err] : ['success', res]
      );
      self.constructor.emit('debug', responseArgs);
      origCallback(err, res);
    };
  }
}

function adapterFun(name, callback) {
  return toPromise(getArguments(function (args) {
    if (this._closed) {
      return Promise.reject(new Error('database is closed'));
    }
    if (this._destroyed) {
      return Promise.reject(new Error('database is destroyed'));
    }
    var self = this;
    logApiCall(self, name, args);
    if (!this.taskqueue.isReady) {
      return new Promise(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
}

function mangle(key) {
  return '$' + key;
}
function unmangle(key) {
  return key.substring(1);
}
function Map$1() {
  this._store = {};
}
Map$1.prototype.get = function (key) {
  var mangled = mangle(key);
  return this._store[mangled];
};
Map$1.prototype.set = function (key, value) {
  var mangled = mangle(key);
  this._store[mangled] = value;
  return true;
};
Map$1.prototype.has = function (key) {
  var mangled = mangle(key);
  return mangled in this._store;
};
Map$1.prototype.delete = function (key) {
  var mangled = mangle(key);
  var res = mangled in this._store;
  delete this._store[mangled];
  return res;
};
Map$1.prototype.forEach = function (cb) {
  var keys = Object.keys(this._store);
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var value = this._store[key];
    key = unmangle(key);
    cb(value, key);
  }
};
Object.defineProperty(Map$1.prototype, 'size', {
  get: function () {
    return Object.keys(this._store).length;
  }
});

function Set$1(array) {
  this._store = new Map$1();

  // init with an array
  if (array && Array.isArray(array)) {
    for (var i = 0, len = array.length; i < len; i++) {
      this.add(array[i]);
    }
  }
}
Set$1.prototype.add = function (key) {
  return this._store.set(key, true);
};
Set$1.prototype.has = function (key) {
  return this._store.has(key);
};
Set$1.prototype.forEach = function (cb) {
  this._store.forEach(function (value, key) {
    cb(key);
  });
};
Object.defineProperty(Set$1.prototype, 'size', {
  get: function () {
    return this._store.size;
  }
});

/* global Map,Set,Symbol */
// Based on https://kangax.github.io/compat-table/es6/ we can sniff out
// incomplete Map/Set implementations which would otherwise cause our tests to fail.
// Notably they fail in IE11 and iOS 8.4, which this prevents.
function supportsMapAndSet() {
  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
    return false;
  }
  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return prop && 'get' in prop && Map[Symbol.species] === Map;
}

// based on https://github.com/montagejs/collections

var ExportedSet;
var ExportedMap;

{
  if (supportsMapAndSet()) { // prefer built-in Map/Set
    ExportedSet = Set;
    ExportedMap = Map;
  } else { // fall back to our polyfill
    ExportedSet = Set$1;
    ExportedMap = Map$1;
  }
}

// like underscore/lodash _.pick()
function pick(obj, arr) {
  var res = {};
  for (var i = 0, len = arr.length; i < len; i++) {
    var prop = arr[i];
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  }
  return res;
}

// Most browsers throttle concurrent requests at 6, so it's silly
// to shim _bulk_get by trying to launch potentially hundreds of requests
// and then letting the majority time out. We can handle this ourselves.
var MAX_NUM_CONCURRENT_REQUESTS = 6;

function identityFunction(x) {
  return x;
}

function formatResultForOpenRevsGet(result) {
  return [{
    ok: result
  }];
}

// shim for P/CouchDB adapters that don't directly implement _bulk_get
function bulkGet(db, opts, callback) {
  var requests = opts.docs;

  // consolidate into one request per doc if possible
  var requestsById = new ExportedMap();
  requests.forEach(function (request) {
    if (requestsById.has(request.id)) {
      requestsById.get(request.id).push(request);
    } else {
      requestsById.set(request.id, [request]);
    }
  });

  var numDocs = requestsById.size;
  var numDone = 0;
  var perDocResults = new Array(numDocs);

  function collapseResultsAndFinish() {
    var results = [];
    perDocResults.forEach(function (res) {
      res.docs.forEach(function (info) {
        results.push({
          id: res.id,
          docs: [info]
        });
      });
    });
    callback(null, {results: results});
  }

  function checkDone() {
    if (++numDone === numDocs) {
      collapseResultsAndFinish();
    }
  }

  function gotResult(docIndex, id, docs) {
    perDocResults[docIndex] = {id: id, docs: docs};
    checkDone();
  }

  var allRequests = [];
  requestsById.forEach(function (value, key) {
    allRequests.push(key);
  });

  var i = 0;

  function nextBatch() {

    if (i >= allRequests.length) {
      return;
    }

    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
    var batch = allRequests.slice(i, upTo);
    processBatch(batch, i);
    i += batch.length;
  }

  function processBatch(batch, offset) {
    batch.forEach(function (docId, j) {
      var docIdx = offset + j;
      var docRequests = requestsById.get(docId);

      // just use the first request as the "template"
      // TODO: The _bulk_get API allows for more subtle use cases than this,
      // but for now it is unlikely that there will be a mix of different
      // "atts_since" or "attachments" in the same request, since it's just
      // replicate.js that is using this for the moment.
      // Also, atts_since is aspirational, since we don't support it yet.
      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
      docOpts.open_revs = docRequests.map(function (request) {
        // rev is optional, open_revs disallowed
        return request.rev;
      });

      // remove falsey / undefined revisions
      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

      var formatResult = identityFunction;

      if (docOpts.open_revs.length === 0) {
        delete docOpts.open_revs;

        // when fetching only the "winning" leaf,
        // transform the result so it looks like an open_revs
        // request
        formatResult = formatResultForOpenRevsGet;
      }

      // globally-supplied options
      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
        if (param in opts) {
          docOpts[param] = opts[param];
        }
      });
      db.get(docId, docOpts, function (err, res) {
        var result;
        /* istanbul ignore if */
        if (err) {
          result = [{error: err}];
        } else {
          result = formatResult(res);
        }
        gotResult(docIdx, docId, result);
        nextBatch();
      });
    });
  }

  nextBatch();

}

var hasLocal;

try {
  localStorage.setItem('_pouch_check_localstorage', 1);
  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
} catch (e) {
  hasLocal = false;
}

function hasLocalStorage() {
  return hasLocal;
}

// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We

inherits(Changes, events.EventEmitter);

/* istanbul ignore next */
function attachBrowserEvents(self) {
  if (hasLocalStorage()) {
    addEventListener("storage", function (e) {
      self.emit(e.key);
    });
  }
}

function Changes() {
  events.EventEmitter.call(this);
  this._listeners = {};

  attachBrowserEvents(this);
}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  /* istanbul ignore if */
  if (this._listeners[id]) {
    return;
  }
  var self = this;
  var inprogress = false;
  function eventFunction() {
    /* istanbul ignore if */
    if (!self._listeners[id]) {
      return;
    }
    if (inprogress) {
      inprogress = 'waiting';
      return;
    }
    inprogress = true;
    var changesOpts = pick(opts, [
      'style', 'include_docs', 'attachments', 'conflicts', 'filter',
      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'
    ]);

    /* istanbul ignore next */
    function onError() {
      inprogress = false;
    }

    db.changes(changesOpts).on('change', function (c) {
      if (c.seq > opts.since && !opts.cancelled) {
        opts.since = c.seq;
        opts.onChange(c);
      }
    }).on('complete', function () {
      if (inprogress === 'waiting') {
        nextTick(eventFunction);
      }
      inprogress = false;
    }).on('error', onError);
  }
  this._listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  /* istanbul ignore if */
  if (!(id in this._listeners)) {
    return;
  }
  events.EventEmitter.prototype.removeListener.call(this, dbName,
    this._listeners[id]);
  delete this._listeners[id];
};


/* istanbul ignore next */
Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (hasLocalStorage()) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

function guardedConsole(method) {
  /* istanbul ignore else */
  if (typeof console !== 'undefined' && typeof console[method] === 'function') {
    var args = Array.prototype.slice.call(arguments, 1);
    console[method].apply(console, args);
  }
}

function randomNumber(min, max) {
  var maxTimeout = 600000; // Hard-coded default of 10 minutes
  min = parseInt(min, 10) || 0;
  max = parseInt(max, 10);
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
  if (max > maxTimeout) {
    min = maxTimeout >> 1; // divide by two
    max = maxTimeout;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
function explainError(status, str) {
  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
}

var assign;
{
  if (typeof Object.assign === 'function') {
    assign = Object.assign;
  } else {
    // lite Object.assign polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    assign = function (target) {
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }
}

var $inject_Object_assign = assign;

inherits(PouchError, Error);

function PouchError(status, error, reason) {
  Error.call(this, reason);
  this.status = status;
  this.name = error;
  this.message = reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    for (var p in error) {
      if (typeof error[p] !== 'function') {
        this[p] = error[p];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

function tryFilter(filter, doc, req) {
  try {
    return !filter(doc, req);
  } catch (err) {
    var msg = 'Filter function threw: ' + err.toString();
    return createError(BAD_REQUEST, msg);
  }
}

function filterChange(opts) {
  var req = {};
  var hasFilter = opts.filter && typeof opts.filter === 'function';
  req.query = opts.query_params;

  return function filter(change) {
    if (!change.doc) {
      // CSG sends events on the changes feed that don't have documents,
      // this hack makes a whole lot of existing code robust.
      change.doc = {};
    }

    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

    if (typeof filterReturn === 'object') {
      return filterReturn;
    }

    if (filterReturn) {
      return false;
    }

    if (!opts.include_docs) {
      delete change.doc;
    } else if (!opts.attachments) {
      for (var att in change.doc._attachments) {
        /* istanbul ignore else */
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
}

function flatten(arrs) {
  var res = [];
  for (var i = 0, len = arrs.length; i < len; i++) {
    res = res.concat(arrs[i]);
  }
  return res;
}

// shim for Function.prototype.name,

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
function invalidIdError(id) {
  var err;
  if (!id) {
    err = createError(MISSING_ID);
  } else if (typeof id !== 'string') {
    err = createError(INVALID_ID);
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = createError(RESERVED_ID);
  }
  if (err) {
    throw err;
  }
}

// Checks if a PouchDB object is "remote" or not. This is

function isRemote(db) {
  if (typeof db._remote === 'boolean') {
    return db._remote;
  }
  /* istanbul ignore next */
  if (typeof db.type === 'function') {
    guardedConsole('warn',
      'db.type() is deprecated and will be removed in ' +
      'a future version of PouchDB');
    return db.type() === 'http';
  }
  /* istanbul ignore next */
  return false;
}

function listenerCount(ee, type) {
  return 'listenerCount' in ee ? ee.listenerCount(type) :
                                 events.EventEmitter.listenerCount(ee, type);
}

function parseDesignDocFunctionName(s) {
  if (!s) {
    return null;
  }
  var parts = s.split('/');
  if (parts.length === 2) {
    return parts;
  }
  if (parts.length === 1) {
    return [s, s];
  }
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var normalized = parseDesignDocFunctionName(s);
  return normalized ? normalized.join('/') : null;
}

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var qName ="queryKey";
var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
/* eslint maxlen: 0, no-useless-escape: 0 */
var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

function parseUri(str) {
  var m = parser.exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = keys[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[qName] = {};
  uri[keys[12]].replace(qParser, function ($0, $1, $2) {
    if ($1) {
      uri[qName][$1] = $2;
    }
  });

  return uri;
}

// Based on https://github.com/alexdavid/scope-eval v0.0.3
// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
// This is basically just a wrapper around new Function()

function scopeEval(source, scope) {
  var keys = [];
  var values = [];
  for (var key in scope) {
    if (scope.hasOwnProperty(key)) {
      keys.push(key);
      values.push(scope[key]);
    }
  }
  keys.push(source);
  return Function.apply(null, keys).apply(null, values);
}

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    db.get(docId, function (err, doc) {
      if (err) {
        /* istanbul ignore next */
        if (err.status !== 404) {
          return reject(err);
        }
        doc = {};
      }

      // the user might change the _rev, so save it for posterity
      var docRev = doc._rev;
      var newDoc = diffFun(doc);

      if (!newDoc) {
        // if the diffFun returns falsy, we short-circuit as
        // an optimization
        return fulfill({updated: false, rev: docRev});
      }

      // users aren't allowed to modify these values,
      // so reset them here
      newDoc._id = docId;
      newDoc._rev = docRev;
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc).then(function (res) {
    return {
      updated: true,
      rev: res.rev
    };
  }, function (err) {
    /* istanbul ignore next */
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc._id, diffFun);
  });
}

var thisAtob = function (str) {
  return atob(str);
};

var thisBtoa = function (str) {
  return btoa(str);
};

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
function createBlob(parts, properties) {
  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                  WebKitBlobBuilder;
    var builder = new Builder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function binaryStringToArrayBuffer(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
}

function binStringToBluffer(binString, type) {
  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
}

function b64ToBluffer(b64, type) {
  return binStringToBluffer(thisAtob(b64), type);
}

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
function arrayBufferToBinaryString(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
}

// shim for browsers that don't support it
function readAsBinaryString(blob, callback) {
  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
}

function blobToBinaryString(blobOrBuffer, callback) {
  readAsBinaryString(blobOrBuffer, function (bin) {
    callback(bin);
  });
}

function blobToBase64(blobOrBuffer, callback) {
  blobToBinaryString(blobOrBuffer, function (base64) {
    callback(thisBtoa(base64));
  });
}

// simplified API. universal browser support is assumed
function readAsArrayBuffer(blob, callback) {
  var reader = new FileReader();
  reader.onloadend = function (e) {
    var result = e.target.result || new ArrayBuffer(0);
    callback(result);
  };
  reader.readAsArrayBuffer(blob);
}

// this is not used in the browser

var setImmediateShim = global.setImmediate || global.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function rawToBase64(raw) {
  return thisBtoa(raw);
}

function sliceBlob(blob, start, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start, end);
  }
  return blob.slice(start, end);
}

function appendBlob(buffer, blob, start, end, callback) {
  if (start > 0 || end < blob.size) {
    // only slice blob if we really need to
    blob = sliceBlob(blob, start, end);
  }
  readAsArrayBuffer(blob, function (arrayBuffer) {
    buffer.append(arrayBuffer);
    callback();
  });
}

function appendString(buffer, string, start, end, callback) {
  if (start > 0 || end < string.length) {
    // only create a substring if we really need to
    string = string.substring(start, end);
  }
  buffer.appendBinary(string);
  callback();
}

function binaryMd5(data, callback) {
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.size;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();

  var append = inputIsString ? appendString : appendBlob;

  function next() {
    setImmediateShim(loadNextChunk);
  }

  function done() {
    var raw = buffer.end(true);
    var base64 = rawToBase64(raw);
    callback(base64);
    buffer.destroy();
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end, next);
    } else {
      append(buffer, data, start, end, done);
    }
  }
  loadNextChunk();
}

function stringMd5(string) {
  return Md5.hash(string);
}

function rev$$1(doc, deterministic_revs) {
  var clonedDoc = clone(doc);
  if (!deterministic_revs) {
    return uuidV4.v4().replace(/-/g, '').toLowerCase();
  }

  delete clonedDoc._rev_tree;
  return stringMd5(JSON.stringify(clonedDoc));
}

var uuid = uuidV4.v4;

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var winningDeleted;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var deleted = !!tree[1].deleted;
    var id = tree[0];
    // sort by deleted, then pos, then id
    if (!winningId || (winningDeleted !== deleted ? winningDeleted :
        winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
      winningDeleted = deleted;
    }
  }

  return winningPos + '-' + winningId;
}

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
function traverseRevTree(revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
}

function sortByPos(a, b) {
  return a.pos - b.pos;
}

function collectLeaves(revs) {
  var leaves = [];
  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(sortByPos).reverse();
  for (var i = 0, len = leaves.length; i < len; i++) {
    delete leaves[i].pos;
  }
  return leaves;
}

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
function collectConflicts(metadata) {
  var win = winningRev(metadata);
  var leaves = collectLeaves(metadata.rev_tree);
  var conflicts = [];
  for (var i = 0, len = leaves.length; i < len; i++) {
    var leaf = leaves[i];
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  }
  return conflicts;
}

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
function compactTree(metadata) {
  var revs = [];
  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                               revHash, ctx, opts) {
    if (opts.status === 'available' && !isLeaf) {
      revs.push(pos + '-' + revHash);
      opts.status = 'missing';
    }
  });
  return revs;
}

// build up a list of all the paths to the leafs in this revision tree
function rootToLeaf(revs) {
  var paths = [];
  var toVisit = revs.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      paths.push({pos: (pos + 1 - history.length), ids: history});
    }
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], history: history});
    }
  }
  return paths.reverse();
}

// for a better overview of what this is doing, read:

function sortByPos$1(a, b) {
  return a.pos - b.pos;
}

// classic binary search
function binarySearch(arr, item, comparator) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1;
    if (comparator(arr[mid], item) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}

// assuming the arr is sorted, insert the item in the proper place
function insertSorted(arr, item, comparator) {
  var idx = binarySearch(arr, item, comparator);
  arr.splice(idx, 0, item);
}

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
function pathToTree(path, numStemmed) {
  var root;
  var leaf;
  for (var i = numStemmed, len = path.length; i < len; i++) {
    var node = path[i];
    var currentLeaf = [node.id, node.opts, []];
    if (leaf) {
      leaf[2].push(currentLeaf);
      leaf = currentLeaf;
    } else {
      root = leaf = currentLeaf;
    }
  }
  return root;
}

// compare the IDs of two trees
function compareTree(a, b) {
  return a[0] < b[0] ? -1 : 1;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
        tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        insertSorted(tree1[2], tree2[2][i], compareTree);
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  for (var i = 0, len = tree.length; i < len; i++) {
    var branch = tree[i];
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        var elements = item.ids[2];
        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
          trees.push({
            ids: elements[j],
            diff: item.diff - 1,
            parent: item.ids,
            parentIdx: j
          });
        }
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  }

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(sortByPos$1);

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths
  var paths = rootToLeaf(tree);
  var stemmedRevs;

  var result;
  for (var i = 0, len = paths.length; i < len; i++) {
    // Then for each path, we cut off the start of the path based on the
    // `depth` to stem to, and generate a new set of flat trees
    var path = paths[i];
    var stemmed = path.ids;
    var node;
    if (stemmed.length > depth) {
      // only do the stemming work if we actually need to stem
      if (!stemmedRevs) {
        stemmedRevs = {}; // avoid allocating this object unnecessarily
      }
      var numStemmed = stemmed.length - depth;
      node = {
        pos: path.pos + numStemmed,
        ids: pathToTree(stemmed, numStemmed)
      };

      for (var s = 0; s < numStemmed; s++) {
        var rev = (path.pos + s) + '-' + stemmed[s].id;
        stemmedRevs[rev] = true;
      }
    } else { // no need to actually stem
      node = {
        pos: path.pos,
        ids: pathToTree(stemmed, 0)
      };
    }

    // Then we remerge all those flat trees together, ensuring that we dont
    // connect trees that would go beyond the depth limit
    if (result) {
      result = doMerge(result, node, true).tree;
    } else {
      result = [node];
    }
  }

  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
  if (stemmedRevs) {
    traverseRevTree(result, function (isLeaf, pos, revHash) {
      // some revisions may have been removed in a branch but not in another
      delete stemmedRevs[pos + '-' + revHash];
    });
  }

  return {
    tree: result,
    revs: stemmedRevs ? Object.keys(stemmedRevs) : []
  };
}

function merge(tree, path, depth) {
  var newTree = doMerge(tree, path);
  var stemmed = stem(newTree.tree, depth);
  return {
    tree: stemmed.tree,
    stemmedRevs: stemmed.revs,
    conflicts: newTree.conflicts
  };
}

// return true if a rev exists in the rev tree, false otherwise
function revExists(revs, rev) {
  var toVisit = revs.slice();
  var splitRev = rev.split('-');
  var targetPos = parseInt(splitRev[0], 10);
  var targetId = splitRev[1];

  var node;
  while ((node = toVisit.pop())) {
    if (node.pos === targetPos && node.ids[0] === targetId) {
      return true;
    }
    var branches = node.ids[2];
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: node.pos + 1, ids: branches[i]});
    }
  }
  return false;
}

function getTrees(node) {
  return node.ids;
}

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
function isDeleted(metadata, rev) {
  if (!rev) {
    rev = winningRev(metadata);
  }
  var id = rev.substring(rev.indexOf('-') + 1);
  var toVisit = metadata.rev_tree.map(getTrees);

  var tree;
  while ((tree = toVisit.pop())) {
    if (tree[0] === id) {
      return !!tree[1].deleted;
    }
    toVisit = toVisit.concat(tree[2]);
  }
}

function isLocalId(id) {
  return (/^_local/).test(id);
}

// returns the current leaf node for a given revision
function latest(rev, metadata) {
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, pos: pos, opts: opts});

    if (isLeaf) {
      for (var i = 0, len = history.length; i < len; i++) {
        var historyNode = history[i];
        var historyRev = historyNode.pos + '-' + historyNode.id;

        if (historyRev === rev) {
          // return the rev of this leaf
          return pos + '-' + id;
        }
      }
    }

    for (var j = 0, l = branches.length; j < l; j++) {
      toVisit.push({pos: pos + 1, ids: branches[j], history: history});
    }
  }

  /* istanbul ignore next */
  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
}

inherits(Changes$1, events.EventEmitter);

function tryCatchInChangeListener(self, change, pending, lastSeq) {
  // isolate try/catches to avoid V8 deoptimizations
  try {
    self.emit('change', change, pending, lastSeq);
  } catch (e) {
    guardedConsole('error', 'Error in .on("change", function):', e);
  }
}

function Changes$1(db, opts, callback) {
  events.EventEmitter.call(this);
  var self = this;
  this.db = db;
  opts = opts ? clone(opts) : {};
  var complete = opts.complete = once(function (err, resp) {
    if (err) {
      if (listenerCount(self, 'error') > 0) {
        self.emit('error', err);
      }
    } else {
      self.emit('complete', resp);
    }
    self.removeAllListeners();
    db.removeListener('destroyed', onDestroy);
  });
  if (callback) {
    self.on('complete', function (resp) {
      callback(null, resp);
    });
    self.on('error', callback);
  }
  function onDestroy() {
    self.cancel();
  }
  db.once('destroyed', onDestroy);

  opts.onChange = function (change, pending, lastSeq) {
    /* istanbul ignore if */
    if (self.isCancelled) {
      return;
    }
    tryCatchInChangeListener(self, change, pending, lastSeq);
  };

  var promise = new Promise(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });
  self.once('cancel', function () {
    db.removeListener('destroyed', onDestroy);
    opts.complete(null, {status: 'cancelled'});
  });
  this.then = promise.then.bind(promise);
  this['catch'] = promise['catch'].bind(promise);
  this.then(function (result) {
    complete(null, result);
  }, complete);



  if (!db.taskqueue.isReady) {
    db.taskqueue.addTask(function (failed) {
      if (failed) {
        opts.complete(failed);
      } else if (self.isCancelled) {
        self.emit('cancel');
      } else {
        self.validateChanges(opts);
      }
    });
  } else {
    self.validateChanges(opts);
  }
}
Changes$1.prototype.cancel = function () {
  this.isCancelled = true;
  if (this.db.taskqueue.isReady) {
    this.emit('cancel');
  }
};
function processChange(doc, metadata, opts) {
  var changeList = [{rev: doc._rev}];
  if (opts.style === 'all_docs') {
    changeList = collectLeaves(metadata.rev_tree)
    .map(function (x) { return {rev: x.rev}; });
  }
  var change = {
    id: metadata.id,
    changes: changeList,
    doc: doc
  };

  if (isDeleted(metadata, doc._rev)) {
    change.deleted = true;
  }
  if (opts.conflicts) {
    change.doc._conflicts = collectConflicts(metadata);
    if (!change.doc._conflicts.length) {
      delete change.doc._conflicts;
    }
  }
  return change;
}

Changes$1.prototype.validateChanges = function (opts) {
  var callback = opts.complete;
  var self = this;

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.validate(opts, function (err) {
      if (err) {
        return callback(err);
      }
      self.doChanges(opts);
    });
  } else {
    self.doChanges(opts);
  }
};

Changes$1.prototype.doChanges = function (opts) {
  var self = this;
  var callback = opts.complete;

  opts = clone(opts);
  if ('live' in opts && !('continuous' in opts)) {
    opts.continuous = opts.live;
  }
  opts.processChange = processChange;

  if (opts.since === 'latest') {
    opts.since = 'now';
  }
  if (!opts.since) {
    opts.since = 0;
  }
  if (opts.since === 'now') {
    this.db.info().then(function (info) {
      /* istanbul ignore if */
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      opts.since = info.update_seq;
      self.doChanges(opts);
    }, callback);
    return;
  }

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.normalize(opts);
    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {
      return PouchDB._changesFilterPlugin.filter(this, opts);
    }
  } else {
    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
      if (key in opts) {
        guardedConsole('warn',
          'The "' + key + '" option was passed in to changes/replicate, ' +
          'but pouchdb-changes-filter plugin is not installed, so it ' +
          'was ignored. Please install the plugin to enable filtering.'
        );
      }
    });
  }

  if (!('descending' in opts)) {
    opts.descending = false;
  }

  // 0 and 1 should return 1 document
  opts.limit = opts.limit === 0 ? 1 : opts.limit;
  opts.complete = callback;
  var newPromise = this.db._changes(opts);
  /* istanbul ignore else */
  if (newPromise && typeof newPromise.cancel === 'function') {
    var cancel = self.cancel;
    self.cancel = getArguments(function (args) {
      newPromise.cancel();
      cancel.apply(this, args);
    });
  }
};

/*
 * A generic pouch adapter
 */

function compare(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
function yankError(callback, docId) {
  return function (err, results) {
    if (err || (results[0] && results[0].error)) {
      err = err || results[0];
      err.docId = docId;
      callback(err);
    } else {
      callback(null, results.length ? results[0]  : results);
    }
  };
}

// clean docs given to us by the user
function cleanDocs(docs) {
  for (var i = 0; i < docs.length; i++) {
    var doc = docs[i];
    if (doc._deleted) {
      delete doc._attachments; // ignore atts for deleted docs
    } else if (doc._attachments) {
      // filter out extraneous keys from _attachments
      var atts = Object.keys(doc._attachments);
      for (var j = 0; j < atts.length; j++) {
        var att = atts[j];
        doc._attachments[att] = pick(doc._attachments[att],
          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
      }
    }
  }
}

// compare two docs, first by _id then by _rev
function compareByIdThenRev(a, b) {
  var idCompare = compare(a._id, b._id);
  if (idCompare !== 0) {
    return idCompare;
  }
  var aStart = a._revisions ? a._revisions.start : 0;
  var bStart = b._revisions ? b._revisions.start : 0;
  return compare(aStart, bStart);
}

// for every node in a revision tree computes its distance from the closest
// leaf
function computeHeight(revs) {
  var height = {};
  var edges = [];
  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
    var rev = pos + "-" + id;
    if (isLeaf) {
      height[rev] = 0;
    }
    if (prnt !== undefined) {
      edges.push({from: prnt, to: rev});
    }
    return rev;
  });

  edges.reverse();
  edges.forEach(function (edge) {
    if (height[edge.from] === undefined) {
      height[edge.from] = 1 + height[edge.to];
    } else {
      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
    }
  });
  return height;
}

function allDocsKeysParse(opts) {
  var keys =  ('limit' in opts) ?
    opts.keys.slice(opts.skip, opts.limit + opts.skip) :
    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
  opts.keys = keys;
  opts.skip = 0;
  delete opts.limit;
  if (opts.descending) {
    keys.reverse();
    opts.descending = false;
  }
}

// all compaction is done in a queue, to avoid attaching
// too many listeners at once
function doNextCompaction(self) {
  var task = self._compactionQueue[0];
  var opts = task.opts;
  var callback = task.callback;
  self.get('_local/compaction').catch(function () {
    return false;
  }).then(function (doc) {
    if (doc && doc.last_seq) {
      opts.last_seq = doc.last_seq;
    }
    self._compact(opts, function (err, res) {
      /* istanbul ignore if */
      if (err) {
        callback(err);
      } else {
        callback(null, res);
      }
      nextTick(function () {
        self._compactionQueue.shift();
        if (self._compactionQueue.length) {
          doNextCompaction(self);
        }
      });
    });
  });
}

function attachmentNameError(name) {
  if (name.charAt(0) === '_') {
    return name + ' is not a valid attachment name, attachment ' +
      'names cannot start with \'_\'';
  }
  return false;
}

inherits(AbstractPouchDB, events.EventEmitter);

function AbstractPouchDB() {
  events.EventEmitter.call(this);

  // re-bind prototyped methods
  for (var p in AbstractPouchDB.prototype) {
    if (typeof this[p] === 'function') {
      this[p] = this[p].bind(this);
    }
  }
}

AbstractPouchDB.prototype.post =
  adapterFun('post', function (doc, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return callback(createError(NOT_AN_OBJECT));
  }
  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));
});

AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return cb(createError(NOT_AN_OBJECT));
  }
  invalidIdError(doc._id);
  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
    if (doc._deleted) {
      return this._removeLocal(doc, cb);
    } else {
      return this._putLocal(doc, cb);
    }
  }
  var self = this;
  if (opts.force && doc._rev) {
    transformForceOptionToNewEditsOption();
    putDoc(function (err) {
      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};
      cb(err, result);
    });
  } else {
    putDoc(cb);
  }

  function transformForceOptionToNewEditsOption() {
    var parts = doc._rev.split('-');
    var oldRevId = parts[1];
    var oldRevNum = parseInt(parts[0], 10);

    var newRevNum = oldRevNum + 1;
    var newRevId = rev$$1();

    doc._revisions = {
      start: newRevNum,
      ids: [newRevId, oldRevId]
    };
    doc._rev = newRevNum + '-' + newRevId;
    opts.new_edits = false;
  }
  function putDoc(next) {
    if (typeof self._put === 'function' && opts.new_edits !== false) {
      self._put(doc, opts, next);
    } else {
      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));
    }
  }
});

AbstractPouchDB.prototype.putAttachment =
  adapterFun('putAttachment', function (docId, attachmentId, rev,
                                              blob, type) {
  var api = this;
  if (typeof type === 'function') {
    type = blob;
    blob = rev;
    rev = null;
  }
  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
  /* istanbul ignore if */
  if (typeof type === 'undefined') {
    type = blob;
    blob = rev;
    rev = null;
  }
  if (!type) {
    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
  }

  function createAttachment(doc) {
    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
    doc._attachments = doc._attachments || {};
    doc._attachments[attachmentId] = {
      content_type: type,
      data: blob,
      revpos: ++prevrevpos
    };
    return api.put(doc);
  }

  return api.get(docId).then(function (doc) {
    if (doc._rev !== rev) {
      throw createError(REV_CONFLICT);
    }

    return createAttachment(doc);
  }, function (err) {
     // create new doc
    /* istanbul ignore else */
    if (err.reason === MISSING_DOC.message) {
      return createAttachment({_id: docId});
    } else {
      throw err;
    }
  });
});

AbstractPouchDB.prototype.removeAttachment =
  adapterFun('removeAttachment', function (docId, attachmentId, rev,
                                                 callback) {
  var self = this;
  self.get(docId, function (err, obj) {
    /* istanbul ignore if */
    if (err) {
      callback(err);
      return;
    }
    if (obj._rev !== rev) {
      callback(createError(REV_CONFLICT));
      return;
    }
    /* istanbul ignore if */
    if (!obj._attachments) {
      return callback();
    }
    delete obj._attachments[attachmentId];
    if (Object.keys(obj._attachments).length === 0) {
      delete obj._attachments;
    }
    self.put(obj, callback);
  });
});

AbstractPouchDB.prototype.remove =
  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
  var doc;
  if (typeof optsOrRev === 'string') {
    // id, rev, opts, callback style
    doc = {
      _id: docOrId,
      _rev: optsOrRev
    };
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
  } else {
    // doc, opts, callback style
    doc = docOrId;
    if (typeof optsOrRev === 'function') {
      callback = optsOrRev;
      opts = {};
    } else {
      callback = opts;
      opts = optsOrRev;
    }
  }
  opts = opts || {};
  opts.was_delete = true;
  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
  newDoc._deleted = true;
  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
    return this._removeLocal(doc, callback);
  }
  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));
});

AbstractPouchDB.prototype.revsDiff =
  adapterFun('revsDiff', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  var ids = Object.keys(req);

  if (!ids.length) {
    return callback(null, {});
  }

  var count = 0;
  var missing = new ExportedMap();

  function addToMissing(id, revId) {
    if (!missing.has(id)) {
      missing.set(id, {missing: []});
    }
    missing.get(id).missing.push(revId);
  }

  function processDoc(id, rev_tree) {
    // Is this fast enough? Maybe we should switch to a set simulated by a map
    var missingForId = req[id].slice(0);
    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
      opts) {
        var rev = pos + '-' + revHash;
        var idx = missingForId.indexOf(rev);
        if (idx === -1) {
          return;
        }

        missingForId.splice(idx, 1);
        /* istanbul ignore if */
        if (opts.status !== 'available') {
          addToMissing(id, rev);
        }
      });

    // Traversing the tree is synchronous, so now `missingForId` contains
    // revisions that were not found in the tree
    missingForId.forEach(function (rev) {
      addToMissing(id, rev);
    });
  }

  ids.map(function (id) {
    this._getRevisionTree(id, function (err, rev_tree) {
      if (err && err.status === 404 && err.message === 'missing') {
        missing.set(id, {missing: req[id]});
      } else if (err) {
        /* istanbul ignore next */
        return callback(err);
      } else {
        processDoc(id, rev_tree);
      }

      if (++count === ids.length) {
        // convert LazyMap to object
        var missingObj = {};
        missing.forEach(function (value, key) {
          missingObj[key] = value;
        });
        return callback(null, missingObj);
      }
    });
  }, this);
});

// _bulk_get API for faster replication, as described in
// https://github.com/apache/couchdb-chttpd/pull/33
// At the "abstract" level, it will just run multiple get()s in
// parallel, because this isn't much of a performance cost
// for local databases (except the cost of multiple transactions, which is
// small). The http adapter overrides this in order
// to do a more efficient single HTTP request.
AbstractPouchDB.prototype.bulkGet =
  adapterFun('bulkGet', function (opts, callback) {
  bulkGet(this, opts, callback);
});

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
AbstractPouchDB.prototype.compactDocument =
  adapterFun('compactDocument', function (docId, maxHeight, callback) {
  var self = this;
  this._getRevisionTree(docId, function (err, revTree) {
    /* istanbul ignore if */
    if (err) {
      return callback(err);
    }
    var height = computeHeight(revTree);
    var candidates = [];
    var revs = [];
    Object.keys(height).forEach(function (rev) {
      if (height[rev] > maxHeight) {
        candidates.push(rev);
      }
    });

    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
      var rev = pos + '-' + revHash;
      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {
        revs.push(rev);
      }
    });
    self._doCompaction(docId, revs, callback);
  });
});

// compact the whole database using single document
// compaction
AbstractPouchDB.prototype.compact =
  adapterFun('compact', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  opts = opts || {};

  self._compactionQueue = self._compactionQueue || [];
  self._compactionQueue.push({opts: opts, callback: callback});
  if (self._compactionQueue.length === 1) {
    doNextCompaction(self);
  }
});
AbstractPouchDB.prototype._compact = function (opts, callback) {
  var self = this;
  var changesOpts = {
    return_docs: false,
    last_seq: opts.last_seq || 0
  };
  var promises = [];

  function onChange(row) {
    promises.push(self.compactDocument(row.id, 0));
  }
  function onComplete(resp) {
    var lastSeq = resp.last_seq;
    Promise.all(promises).then(function () {
      return upsert(self, '_local/compaction', function deltaFunc(doc) {
        if (!doc.last_seq || doc.last_seq < lastSeq) {
          doc.last_seq = lastSeq;
          return doc;
        }
        return false; // somebody else got here first, don't update
      });
    }).then(function () {
      callback(null, {ok: true});
    }).catch(callback);
  }
  self.changes(changesOpts)
    .on('change', onChange)
    .on('complete', onComplete)
    .on('error', callback);
};

/* Begin api wrappers. Specific functionality to storage belongs in the
   _[method] */
AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof id !== 'string') {
    return cb(createError(INVALID_ID));
  }
  if (isLocalId(id) && typeof this._getLocal === 'function') {
    return this._getLocal(id, cb);
  }
  var leaves = [], self = this;

  function finishOpenRevs() {
    var result = [];
    var count = leaves.length;
    /* istanbul ignore if */
    if (!count) {
      return cb(null, result);
    }

    // order with open_revs is unspecified
    leaves.forEach(function (leaf) {
      self.get(id, {
        rev: leaf,
        revs: opts.revs,
        latest: opts.latest,
        attachments: opts.attachments,
        binary: opts.binary
      }, function (err, doc) {
        if (!err) {
          // using latest=true can produce duplicates
          var existing;
          for (var i = 0, l = result.length; i < l; i++) {
            if (result[i].ok && result[i].ok._rev === doc._rev) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            result.push({ok: doc});
          }
        } else {
          result.push({missing: leaf});
        }
        count--;
        if (!count) {
          cb(null, result);
        }
      });
    });
  }

  if (opts.open_revs) {
    if (opts.open_revs === "all") {
      this._getRevisionTree(id, function (err, rev_tree) {
        /* istanbul ignore if */
        if (err) {
          return cb(err);
        }
        leaves = collectLeaves(rev_tree).map(function (leaf) {
          return leaf.rev;
        });
        finishOpenRevs();
      });
    } else {
      if (Array.isArray(opts.open_revs)) {
        leaves = opts.open_revs;
        for (var i = 0; i < leaves.length; i++) {
          var l = leaves[i];
          // looks like it's the only thing couchdb checks
          if (!(typeof (l) === "string" && /^\d+-/.test(l))) {
            return cb(createError(INVALID_REV));
          }
        }
        finishOpenRevs();
      } else {
        return cb(createError(UNKNOWN_ERROR, 'function_clause'));
      }
    }
    return; // open_revs does not like other options
  }

  return this._get(id, opts, function (err, result) {
    if (err) {
      err.docId = id;
      return cb(err);
    }

    var doc = result.doc;
    var metadata = result.metadata;
    var ctx = result.ctx;

    if (opts.conflicts) {
      var conflicts = collectConflicts(metadata);
      if (conflicts.length) {
        doc._conflicts = conflicts;
      }
    }

    if (isDeleted(metadata, doc._rev)) {
      doc._deleted = true;
    }

    if (opts.revs || opts.revs_info) {
      var splittedRev = doc._rev.split('-');
      var revNo       = parseInt(splittedRev[0], 10);
      var revHash     = splittedRev[1];

      var paths = rootToLeaf(metadata.rev_tree);
      var path = null;

      for (var i = 0; i < paths.length; i++) {
        var currentPath = paths[i];
        var hashIndex = currentPath.ids.map(function (x) { return x.id; })
          .indexOf(revHash);
        var hashFoundAtRevPos = hashIndex === (revNo - 1);

        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {
          path = currentPath;
        }
      }

      var indexOfRev = path.ids.map(function (x) { return x.id; })
        .indexOf(doc._rev.split('-')[1]) + 1;
      var howMany = path.ids.length - indexOfRev;
      path.ids.splice(indexOfRev, howMany);
      path.ids.reverse();

      if (opts.revs) {
        doc._revisions = {
          start: (path.pos + path.ids.length) - 1,
          ids: path.ids.map(function (rev) {
            return rev.id;
          })
        };
      }
      if (opts.revs_info) {
        var pos =  path.pos + path.ids.length;
        doc._revs_info = path.ids.map(function (rev) {
          pos--;
          return {
            rev: pos + '-' + rev.id,
            status: rev.opts.status
          };
        });
      }
    }

    if (opts.attachments && doc._attachments) {
      var attachments = doc._attachments;
      var count = Object.keys(attachments).length;
      if (count === 0) {
        return cb(null, doc);
      }
      Object.keys(attachments).forEach(function (key) {
        this._getAttachment(doc._id, key, attachments[key], {
          // Previously the revision handling was done in adapter.js
          // getAttachment, however since idb-next doesnt we need to
          // pass the rev through
          rev: doc._rev,
          binary: opts.binary,
          ctx: ctx
        }, function (err, data) {
          var att = doc._attachments[key];
          att.data = data;
          delete att.stub;
          delete att.length;
          if (!--count) {
            cb(null, doc);
          }
        });
      }, self);
    } else {
      if (doc._attachments) {
        for (var key in doc._attachments) {
          /* istanbul ignore else */
          if (doc._attachments.hasOwnProperty(key)) {
            doc._attachments[key].stub = true;
          }
        }
      }
      cb(null, doc);
    }
  });
});

// TODO: I dont like this, it forces an extra read for every
// attachment read and enforces a confusing api between
// adapter.js and the adapter implementation
AbstractPouchDB.prototype.getAttachment =
  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
  var self = this;
  if (opts instanceof Function) {
    callback = opts;
    opts = {};
  }
  this._get(docId, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (res.doc._attachments && res.doc._attachments[attachmentId]) {
      opts.ctx = res.ctx;
      opts.binary = true;
      self._getAttachment(docId, attachmentId,
                          res.doc._attachments[attachmentId], opts, callback);
    } else {
      return callback(createError(MISSING_DOC));
    }
  });
});

AbstractPouchDB.prototype.allDocs =
  adapterFun('allDocs', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
  if (opts.start_key) {
    opts.startkey = opts.start_key;
  }
  if (opts.end_key) {
    opts.endkey = opts.end_key;
  }
  if ('keys' in opts) {
    if (!Array.isArray(opts.keys)) {
      return callback(new TypeError('options.keys must be an array'));
    }
    var incompatibleOpt =
      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
      return incompatibleOpt in opts;
    })[0];
    if (incompatibleOpt) {
      callback(createError(QUERY_PARSE_ERROR,
        'Query parameter `' + incompatibleOpt +
        '` is not compatible with multi-get'
      ));
      return;
    }
    if (!isRemote(this)) {
      allDocsKeysParse(opts);
      if (opts.keys.length === 0) {
        return this._allDocs({limit: 0}, callback);
      }
    }
  }

  return this._allDocs(opts, callback);
});

AbstractPouchDB.prototype.changes = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  // By default set return_docs to false if the caller has opts.live = true,
  // this will prevent us from collecting the set of changes indefinitely
  // resulting in growing memory
  opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;

  return new Changes$1(this, opts, callback);
};

AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
  this._closed = true;
  this.emit('closed');
  return this._close(callback);
});

AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
  var self = this;
  this._info(function (err, info) {
    if (err) {
      return callback(err);
    }
    // assume we know better than the adapter, unless it informs us
    info.db_name = info.db_name || self.name;
    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
    info.adapter = self.adapter;
    callback(null, info);
  });
});

AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
  return this._id(callback);
});

/* istanbul ignore next */
AbstractPouchDB.prototype.type = function () {
  return (typeof this._type === 'function') ? this._type() : this.adapter;
};

AbstractPouchDB.prototype.bulkDocs =
  adapterFun('bulkDocs', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  if (Array.isArray(req)) {
    req = {
      docs: req
    };
  }

  if (!req || !req.docs || !Array.isArray(req.docs)) {
    return callback(createError(MISSING_BULK_DOCS));
  }

  for (var i = 0; i < req.docs.length; ++i) {
    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
      return callback(createError(NOT_AN_OBJECT));
    }
  }

  var attachmentError;
  req.docs.forEach(function (doc) {
    if (doc._attachments) {
      Object.keys(doc._attachments).forEach(function (name) {
        attachmentError = attachmentError || attachmentNameError(name);
        if (!doc._attachments[name].content_type) {
          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
        }
      });
    }
  });

  if (attachmentError) {
    return callback(createError(BAD_REQUEST, attachmentError));
  }

  if (!('new_edits' in opts)) {
    if ('new_edits' in req) {
      opts.new_edits = req.new_edits;
    } else {
      opts.new_edits = true;
    }
  }

  var adapter = this;
  if (!opts.new_edits && !isRemote(adapter)) {
    // ensure revisions of the same doc are sorted, so that
    // the local adapter processes them correctly (#2935)
    req.docs.sort(compareByIdThenRev);
  }

  cleanDocs(req.docs);

  // in the case of conflicts, we want to return the _ids to the user
  // however, the underlying adapter may destroy the docs array, so
  // create a copy here
  var ids = req.docs.map(function (doc) {
    return doc._id;
  });

  return this._bulkDocs(req, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (!opts.new_edits) {
      // this is what couch does when new_edits is false
      res = res.filter(function (x) {
        return x.error;
      });
    }
    // add ids for error/conflict responses (not required for CouchDB)
    if (!isRemote(adapter)) {
      for (var i = 0, l = res.length; i < l; i++) {
        res[i].id = res[i].id || ids[i];
      }
    }

    callback(null, res);
  });
});

AbstractPouchDB.prototype.registerDependentDatabase =
  adapterFun('registerDependentDatabase', function (dependentDb,
                                                          callback) {
  var depDB = new this.constructor(dependentDb, this.__opts);

  function diffFun(doc) {
    doc.dependentDbs = doc.dependentDbs || {};
    if (doc.dependentDbs[dependentDb]) {
      return false; // no update required
    }
    doc.dependentDbs[dependentDb] = true;
    return doc;
  }
  upsert(this, '_local/_pouch_dependentDbs', diffFun)
    .then(function () {
      callback(null, {db: depDB});
    }).catch(callback);
});

AbstractPouchDB.prototype.destroy =
  adapterFun('destroy', function (opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

  function destroyDb() {
    // call destroy method of the particular adaptor
    self._destroy(opts, function (err, resp) {
      if (err) {
        return callback(err);
      }
      self._destroyed = true;
      self.emit('destroyed');
      callback(null, resp || { 'ok': true });
    });
  }

  if (isRemote(self)) {
    // no need to check for dependent DBs if it's a remote DB
    return destroyDb();
  }

  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
    if (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        return callback(err);
      } else { // no dependencies
        return destroyDb();
      }
    }
    var dependentDbs = localDoc.dependentDbs;
    var PouchDB = self.constructor;
    var deletedMap = Object.keys(dependentDbs).map(function (name) {
      // use_prefix is only false in the browser
      /* istanbul ignore next */
      var trueName = usePrefix ?
        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
      return new PouchDB(trueName, self.__opts).destroy();
    });
    Promise.all(deletedMap).then(destroyDb, callback);
  });
});

function TaskQueue() {
  this.isReady = false;
  this.failed = false;
  this.queue = [];
}

TaskQueue.prototype.execute = function () {
  var fun;
  if (this.failed) {
    while ((fun = this.queue.shift())) {
      fun(this.failed);
    }
  } else {
    while ((fun = this.queue.shift())) {
      fun();
    }
  }
};

TaskQueue.prototype.fail = function (err) {
  this.failed = err;
  this.execute();
};

TaskQueue.prototype.ready = function (db) {
  this.isReady = true;
  this.db = db;
  this.execute();
};

TaskQueue.prototype.addTask = function (fun) {
  this.queue.push(fun);
  if (this.failed) {
    this.execute();
  }
};

function parseAdapter(name, opts) {
  var match = name.match(/([a-z-]*):\/\/(.*)/);
  if (match) {
    // the http adapter expects the fully qualified name
    return {
      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
      adapter: match[1]
    };
  }

  var adapters = PouchDB.adapters;
  var preferredAdapters = PouchDB.preferredAdapters;
  var prefix = PouchDB.prefix;
  var adapterName = opts.adapter;

  if (!adapterName) { // automatically determine adapter
    for (var i = 0; i < preferredAdapters.length; ++i) {
      adapterName = preferredAdapters[i];
      // check for browsers that have been upgraded from websql-only to websql+idb
      /* istanbul ignore if */
      if (adapterName === 'idb' && 'websql' in adapters &&
          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
        // log it, because this can be confusing during development
        guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' +
          ' avoid data loss, because it was already opened with WebSQL.');
        continue; // keep using websql to avoid user data loss
      }
      break;
    }
  }

  var adapter = adapters[adapterName];

  // if adapter is invalid, then an error will be thrown later
  var usePrefix = (adapter && 'use_prefix' in adapter) ?
    adapter.use_prefix : true;

  return {
    name: usePrefix ? (prefix + name) : name,
    adapter: adapterName
  };
}

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
function prepareForDestruction(self) {

  function onDestroyed(from_constructor) {
    self.removeListener('closed', onClosed);
    if (!from_constructor) {
      self.constructor.emit('destroyed', self.name);
    }
  }

  function onClosed() {
    self.removeListener('destroyed', onDestroyed);
    self.constructor.emit('unref', self);
  }

  self.once('destroyed', onDestroyed);
  self.once('closed', onClosed);
  self.constructor.emit('ref', self);
}

inherits(PouchDB, AbstractPouchDB);
function PouchDB(name, opts) {
  // In Node our test suite only tests this for PouchAlt unfortunately
  /* istanbul ignore if */
  if (!(this instanceof PouchDB)) {
    return new PouchDB(name, opts);
  }

  var self = this;
  opts = opts || {};

  if (name && typeof name === 'object') {
    opts = name;
    name = opts.name;
    delete opts.name;
  }

  if (opts.deterministic_revs === undefined) {
    opts.deterministic_revs = true;
  }

  this.__opts = opts = clone(opts);

  self.auto_compaction = opts.auto_compaction;
  self.prefix = PouchDB.prefix;

  if (typeof name !== 'string') {
    throw new Error('Missing/invalid DB name');
  }

  var prefixedName = (opts.prefix || '') + name;
  var backend = parseAdapter(prefixedName, opts);

  opts.name = backend.name;
  opts.adapter = opts.adapter || backend.adapter;

  self.name = name;
  self._adapter = opts.adapter;
  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

  if (!PouchDB.adapters[opts.adapter] ||
      !PouchDB.adapters[opts.adapter].valid()) {
    throw new Error('Invalid Adapter: ' + opts.adapter);
  }

  AbstractPouchDB.call(self);
  self.taskqueue = new TaskQueue();

  self.adapter = opts.adapter;

  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {
    if (err) {
      return self.taskqueue.fail(err);
    }
    prepareForDestruction(self);

    self.emit('created', self);
    PouchDB.emit('created', self.name);
    self.taskqueue.ready(self);
  });

}

// AbortController was introduced quite a while after fetch and
// isnt required for PouchDB to function so polyfill if needed
var a = (typeof AbortController !== 'undefined')
    ? AbortController
    : function () { return {abort: function () {}}; };

var f$1 = fetch;
var h = Headers;

PouchDB.adapters = {};
PouchDB.preferredAdapters = [];

PouchDB.prefix = '_pouch_';

var eventEmitter = new events.EventEmitter();

function setUpEventEmitter(Pouch) {
  Object.keys(events.EventEmitter.prototype).forEach(function (key) {
    if (typeof events.EventEmitter.prototype[key] === 'function') {
      Pouch[key] = eventEmitter[key].bind(eventEmitter);
    }
  });

  // these are created in constructor.js, and allow us to notify each DB with
  // the same name that it was destroyed, via the constructor object
  var destructListeners = Pouch._destructionListeners = new ExportedMap();

  Pouch.on('ref', function onConstructorRef(db) {
    if (!destructListeners.has(db.name)) {
      destructListeners.set(db.name, []);
    }
    destructListeners.get(db.name).push(db);
  });

  Pouch.on('unref', function onConstructorUnref(db) {
    if (!destructListeners.has(db.name)) {
      return;
    }
    var dbList = destructListeners.get(db.name);
    var pos = dbList.indexOf(db);
    if (pos < 0) {
      /* istanbul ignore next */
      return;
    }
    dbList.splice(pos, 1);
    if (dbList.length > 1) {
      /* istanbul ignore next */
      destructListeners.set(db.name, dbList);
    } else {
      destructListeners.delete(db.name);
    }
  });

  Pouch.on('destroyed', function onConstructorDestroyed(name) {
    if (!destructListeners.has(name)) {
      return;
    }
    var dbList = destructListeners.get(name);
    destructListeners.delete(name);
    dbList.forEach(function (db) {
      db.emit('destroyed',true);
    });
  });
}

setUpEventEmitter(PouchDB);

PouchDB.adapter = function (id, obj, addToPreferredAdapters) {
  /* istanbul ignore else */
  if (obj.valid()) {
    PouchDB.adapters[id] = obj;
    if (addToPreferredAdapters) {
      PouchDB.preferredAdapters.push(id);
    }
  }
};

PouchDB.plugin = function (obj) {
  if (typeof obj === 'function') { // function style for plugins
    obj(PouchDB);
  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
    throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
  } else {
    Object.keys(obj).forEach(function (id) { // object style for plugins
      PouchDB.prototype[id] = obj[id];
    });
  }
  if (this.__defaults) {
    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);
  }
  return PouchDB;
};

PouchDB.defaults = function (defaultOpts) {
  function PouchAlt(name, opts) {
    if (!(this instanceof PouchAlt)) {
      return new PouchAlt(name, opts);
    }

    opts = opts || {};

    if (name && typeof name === 'object') {
      opts = name;
      name = opts.name;
      delete opts.name;
    }

    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
    PouchDB.call(this, name, opts);
  }

  inherits(PouchAlt, PouchDB);

  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
  Object.keys(PouchDB).forEach(function (key) {
    if (!(key in PouchAlt)) {
      PouchAlt[key] = PouchDB[key];
    }
  });

  // make default options transitive
  // https://github.com/pouchdb/pouchdb/issues/5922
  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);

  return PouchAlt;
};

PouchDB.fetch = function (url, opts) {
  return f$1(url, opts);
};

// managed automatically by set-version.js
var version = "7.0.0";

// this would just be "return doc[field]", but fields
// can be "deep" due to dot notation
function getFieldFromDoc(doc, parsedField) {
  var value = doc;
  for (var i = 0, len = parsedField.length; i < len; i++) {
    var key = parsedField[i];
    value = value[key];
    if (!value) {
      break;
    }
  }
  return value;
}

function compare$1(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Converts a string in dot notation to an array of its components, with backslash escaping
function parseField(fieldName) {
  // fields may be deep (e.g. "foo.bar.baz"), so parse
  var fields = [];
  var current = '';
  for (var i = 0, len = fieldName.length; i < len; i++) {
    var ch = fieldName[i];
    if (ch === '.') {
      if (i > 0 && fieldName[i - 1] === '\\') { // escaped delimiter
        current = current.substring(0, current.length - 1) + '.';
      } else { // not escaped, so delimiter
        fields.push(current);
        current = '';
      }
    } else { // normal character
      current += ch;
    }
  }
  fields.push(current);
  return fields;
}

var combinationFields = ['$or', '$nor', '$not'];
function isCombinationalField(field) {
  return combinationFields.indexOf(field) > -1;
}

function getKey(obj) {
  return Object.keys(obj)[0];
}

function getValue(obj) {
  return obj[getKey(obj)];
}


// flatten an array of selectors joined by an $and operator
function mergeAndedSelectors(selectors) {

  // sort to ensure that e.g. if the user specified
  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
  // just {$gt: 'b'}
  var res = {};

  selectors.forEach(function (selector) {
    Object.keys(selector).forEach(function (field) {
      var matcher = selector[field];
      if (typeof matcher !== 'object') {
        matcher = {$eq: matcher};
      }

      if (isCombinationalField(field)) {
        if (matcher instanceof Array) {
          res[field] = matcher.map(function (m) {
            return mergeAndedSelectors([m]);
          });
        } else {
          res[field] = mergeAndedSelectors([matcher]);
        }
      } else {
        var fieldMatchers = res[field] = res[field] || {};
        Object.keys(matcher).forEach(function (operator) {
          var value = matcher[operator];

          if (operator === '$gt' || operator === '$gte') {
            return mergeGtGte(operator, value, fieldMatchers);
          } else if (operator === '$lt' || operator === '$lte') {
            return mergeLtLte(operator, value, fieldMatchers);
          } else if (operator === '$ne') {
            return mergeNe(value, fieldMatchers);
          } else if (operator === '$eq') {
            return mergeEq(value, fieldMatchers);
          }
          fieldMatchers[operator] = value;
        });
      }
    });
  });

  return res;
}



// collapse logically equivalent gt/gte values
function mergeGtGte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$gte !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gte) { // more specificity
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value >= fieldMatchers.$gte) { // more specificity
        delete fieldMatchers.$gte;
        fieldMatchers.$gt = value;
      }
    }
  } else if (typeof fieldMatchers.$gt !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gt) { // more specificity
        delete fieldMatchers.$gt;
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value > fieldMatchers.$gt) { // more specificity
        fieldMatchers.$gt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// collapse logically equivalent lt/lte values
function mergeLtLte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$lte !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lte) { // more specificity
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value <= fieldMatchers.$lte) { // more specificity
        delete fieldMatchers.$lte;
        fieldMatchers.$lt = value;
      }
    }
  } else if (typeof fieldMatchers.$lt !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lt) { // more specificity
        delete fieldMatchers.$lt;
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value < fieldMatchers.$lt) { // more specificity
        fieldMatchers.$lt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// combine $ne values into one array
function mergeNe(value, fieldMatchers) {
  if ('$ne' in fieldMatchers) {
    // there are many things this could "not" be
    fieldMatchers.$ne.push(value);
  } else { // doesn't exist yet
    fieldMatchers.$ne = [value];
  }
}

// add $eq into the mix
function mergeEq(value, fieldMatchers) {
  // these all have less specificity than the $eq
  // TODO: check for user errors here
  delete fieldMatchers.$gt;
  delete fieldMatchers.$gte;
  delete fieldMatchers.$lt;
  delete fieldMatchers.$lte;
  delete fieldMatchers.$ne;
  fieldMatchers.$eq = value;
}


//
// normalize the selector
//
function massageSelector(input) {
  var result = clone(input);
  var wasAnded = false;
  if ('$and' in result) {
    result = mergeAndedSelectors(result['$and']);
    wasAnded = true;
  }

  ['$or', '$nor'].forEach(function (orOrNor) {
    if (orOrNor in result) {
      // message each individual selector
      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
      result[orOrNor].forEach(function (subSelector) {
        var fields = Object.keys(subSelector);
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var matcher = subSelector[field];
          if (typeof matcher !== 'object' || matcher === null) {
            subSelector[field] = {$eq: matcher};
          }
        }
      });
    }
  });

  if ('$not' in result) {
    //This feels a little like forcing, but it will work for now,
    //I would like to come back to this and make the merging of selectors a little more generic
    result['$not'] = mergeAndedSelectors([result['$not']]);
  }

  var fields = Object.keys(result);

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var matcher = result[field];

    if (typeof matcher !== 'object' || matcher === null) {
      matcher = {$eq: matcher};
    } else if ('$ne' in matcher && !wasAnded) {
      // I put these in an array, since there may be more than one
      // but in the "mergeAnded" operation, I already take care of that
      matcher.$ne = [matcher.$ne];
    }
    result[field] = matcher;
  }

  return result;
}

function pad(str, padWith, upToLength) {
  var padding = '';
  var targetLength = upToLength - str.length;
  /* istanbul ignore next */
  while (padding.length < targetLength) {
    padding += padWith;
  }
  return padding;
}

function padLeft(str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return padding + str;
}

var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
var MAGNITUDE_DIGITS = 3; // ditto
var SEP = ''; // set to '_' for easier debugging 

function collate(a, b) {

  if (a === b) {
    return 0;
  }

  a = normalizeKey(a);
  b = normalizeKey(b);

  var ai = collationIndex(a);
  var bi = collationIndex(b);
  if ((ai - bi) !== 0) {
    return ai - bi;
  }
  switch (typeof a) {
    case 'number':
      return a - b;
    case 'boolean':
      return a < b ? -1 : 1;
    case 'string':
      return stringCollate(a, b);
  }
  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
}

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
function normalizeKey(key) {
  switch (typeof key) {
    case 'undefined':
      return null;
    case 'number':
      if (key === Infinity || key === -Infinity || isNaN(key)) {
        return null;
      }
      return key;
    case 'object':
      var origKey = key;
      if (Array.isArray(key)) {
        var len = key.length;
        key = new Array(len);
        for (var i = 0; i < len; i++) {
          key[i] = normalizeKey(origKey[i]);
        }
      /* istanbul ignore next */
      } else if (key instanceof Date) {
        return key.toJSON();
      } else if (key !== null) { // generic object
        key = {};
        for (var k in origKey) {
          if (origKey.hasOwnProperty(k)) {
            var val = origKey[k];
            if (typeof val !== 'undefined') {
              key[k] = normalizeKey(val);
            }
          }
        }
      }
  }
  return key;
}

function indexify(key) {
  if (key !== null) {
    switch (typeof key) {
      case 'boolean':
        return key ? 1 : 0;
      case 'number':
        return numToIndexableString(key);
      case 'string':
        // We've to be sure that key does not contain \u0000
        // Do order-preserving replacements:
        // 0 -> 1, 1
        // 1 -> 1, 2
        // 2 -> 2, 2
        /* eslint-disable no-control-regex */
        return key
          .replace(/\u0002/g, '\u0002\u0002')
          .replace(/\u0001/g, '\u0001\u0002')
          .replace(/\u0000/g, '\u0001\u0001');
        /* eslint-enable no-control-regex */
      case 'object':
        var isArray = Array.isArray(key);
        var arr = isArray ? key : Object.keys(key);
        var i = -1;
        var len = arr.length;
        var result = '';
        if (isArray) {
          while (++i < len) {
            result += toIndexableString(arr[i]);
          }
        } else {
          while (++i < len) {
            var objKey = arr[i];
            result += toIndexableString(objKey) +
                toIndexableString(key[objKey]);
          }
        }
        return result;
    }
  }
  return '';
}

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
function toIndexableString(key) {
  var zero = '\u0000';
  key = normalizeKey(key);
  return collationIndex(key) + SEP + indexify(key) + zero;
}

function parseNumber(str, i) {
  var originalIdx = i;
  var num;
  var zero = str[i] === '1';
  if (zero) {
    num = 0;
    i++;
  } else {
    var neg = str[i] === '0';
    i++;
    var numAsString = '';
    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
    /* istanbul ignore next */
    if (neg) {
      magnitude = -magnitude;
    }
    i += MAGNITUDE_DIGITS;
    while (true) {
      var ch = str[i];
      if (ch === '\u0000') {
        break;
      } else {
        numAsString += ch;
      }
      i++;
    }
    numAsString = numAsString.split('.');
    if (numAsString.length === 1) {
      num = parseInt(numAsString, 10);
    } else {
      /* istanbul ignore next */
      num = parseFloat(numAsString[0] + '.' + numAsString[1]);
    }
    /* istanbul ignore next */
    if (neg) {
      num = num - 10;
    }
    /* istanbul ignore next */
    if (magnitude !== 0) {
      // parseFloat is more reliable than pow due to rounding errors
      // e.g. Number.MAX_VALUE would return Infinity if we did
      // num * Math.pow(10, magnitude);
      num = parseFloat(num + 'e' + magnitude);
    }
  }
  return {num: num, length : i - originalIdx};
}

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
function pop(stack, metaStack) {
  var obj = stack.pop();

  if (metaStack.length) {
    var lastMetaElement = metaStack[metaStack.length - 1];
    if (obj === lastMetaElement.element) {
      // popping a meta-element, e.g. an object whose value is another object
      metaStack.pop();
      lastMetaElement = metaStack[metaStack.length - 1];
    }
    var element = lastMetaElement.element;
    var lastElementIndex = lastMetaElement.index;
    if (Array.isArray(element)) {
      element.push(obj);
    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
      var key = stack.pop();
      element[key] = obj;
    } else {
      stack.push(obj); // obj with key only
    }
  }
}

function parseIndexableString(str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;

  /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
  while (true) {
    var collationIndex = str[i++];
    if (collationIndex === '\u0000') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case '1':
        stack.push(null);
        break;
      case '2':
        stack.push(str[i] === '1');
        i++;
        break;
      case '3':
        var parsedNum = parseNumber(str, i);
        stack.push(parsedNum.num);
        i += parsedNum.length;
        break;
      case '4':
        var parsedStr = '';
        /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
        while (true) {
          var ch = str[i];
          if (ch === '\u0000') {
            break;
          }
          parsedStr += ch;
          i++;
        }
        // perform the reverse of the order-preserving replacement
        // algorithm (see above)
        /* eslint-disable no-control-regex */
        parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
          .replace(/\u0001\u0002/g, '\u0001')
          .replace(/\u0002\u0002/g, '\u0002');
        /* eslint-enable no-control-regex */
        stack.push(parsedStr);
        break;
      case '5':
        var arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '6':
        var objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      /* istanbul ignore next */
      default:
        throw new Error(
          'bad collationIndex or unexpectedly reached end of input: ' +
            collationIndex);
    }
  }
}

function arrayCollate(a, b) {
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; i++) {
    var sort = collate(a[i], b[i]);
    if (sort !== 0) {
      return sort;
    }
  }
  return (a.length === b.length) ? 0 :
    (a.length > b.length) ? 1 : -1;
}
function stringCollate(a, b) {
  // See: https://github.com/daleharvey/pouchdb/issues/40
  // This is incompatible with the CouchDB implementation, but its the
  // best we can do for now
  return (a === b) ? 0 : ((a > b) ? 1 : -1);
}
function objectCollate(a, b) {
  var ak = Object.keys(a), bk = Object.keys(b);
  var len = Math.min(ak.length, bk.length);
  for (var i = 0; i < len; i++) {
    // First sort the keys
    var sort = collate(ak[i], bk[i]);
    if (sort !== 0) {
      return sort;
    }
    // if the keys are equal sort the values
    sort = collate(a[ak[i]], b[bk[i]]);
    if (sort !== 0) {
      return sort;
    }

  }
  return (ak.length === bk.length) ? 0 :
    (ak.length > bk.length) ? 1 : -1;
}
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
function collationIndex(x) {
  var id = ['boolean', 'number', 'string', 'object'];
  var idx = id.indexOf(typeof x);
  //false if -1 otherwise true, but fast!!!!1
  if (~idx) {
    if (x === null) {
      return 1;
    }
    if (Array.isArray(x)) {
      return 5;
    }
    return idx < 3 ? (idx + 2) : (idx + 3);
  }
  /* istanbul ignore next */
  if (Array.isArray(x)) {
    return 5;
  }
}

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
function numToIndexableString(num) {

  if (num === 0) {
    return '1';
  }

  // convert number to exponential format for easier and
  // more succinct string sorting
  var expFormat = num.toExponential().split(/e\+?/);
  var magnitude = parseInt(expFormat[1], 10);

  var neg = num < 0;

  var result = neg ? '0' : '2';

  // first sort by magnitude
  // it's easier if all magnitudes are positive
  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

  result += SEP + magString;

  // then sort by the factor
  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
  /* istanbul ignore next */
  if (neg) { // for negative reverse ordering
    factor = 10 - factor;
  }

  var factorStr = factor.toFixed(20);

  // strip zeros from the end
  factorStr = factorStr.replace(/\.?0+$/, '');

  result += SEP + factorStr;

  return result;
}

// create a comparator based on the sort object
function createFieldSorter(sort) {

  function getFieldValuesAsArray(doc) {
    return sort.map(function (sorting) {
      var fieldName = getKey(sorting);
      var parsedField = parseField(fieldName);
      var docFieldValue = getFieldFromDoc(doc, parsedField);
      return docFieldValue;
    });
  }

  return function (aRow, bRow) {
    var aFieldValues = getFieldValuesAsArray(aRow.doc);
    var bFieldValues = getFieldValuesAsArray(bRow.doc);
    var collation = collate(aFieldValues, bFieldValues);
    if (collation !== 0) {
      return collation;
    }
    // this is what mango seems to do
    return compare$1(aRow.doc._id, bRow.doc._id);
  };
}

function filterInMemoryFields(rows, requestDef, inMemoryFields) {
  rows = rows.filter(function (row) {
    return rowFilter(row.doc, requestDef.selector, inMemoryFields);
  });

  if (requestDef.sort) {
    // in-memory sort
    var fieldSorter = createFieldSorter(requestDef.sort);
    rows = rows.sort(fieldSorter);
    if (typeof requestDef.sort[0] !== 'string' &&
        getValue(requestDef.sort[0]) === 'desc') {
      rows = rows.reverse();
    }
  }

  if ('limit' in requestDef || 'skip' in requestDef) {
    // have to do the limit in-memory
    var skip = requestDef.skip || 0;
    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
    rows = rows.slice(skip, limit);
  }
  return rows;
}

function rowFilter(doc, selector, inMemoryFields) {
  return inMemoryFields.every(function (field) {
    var matcher = selector[field];
    var parsedField = parseField(field);
    var docFieldValue = getFieldFromDoc(doc, parsedField);
    if (isCombinationalField(field)) {
      return matchCominationalSelector(field, matcher, doc);
    }

    return matchSelector(matcher, doc, parsedField, docFieldValue);
  });
}

function matchSelector(matcher, doc, parsedField, docFieldValue) {
  if (!matcher) {
    // no filtering necessary; this field is just needed for sorting
    return true;
  }

  return Object.keys(matcher).every(function (userOperator) {
    var userValue = matcher[userOperator];
    return match(userOperator, doc, userValue, parsedField, docFieldValue);
  });
}

function matchCominationalSelector(field, matcher, doc) {

  if (field === '$or') {
    return matcher.some(function (orMatchers) {
      return rowFilter(doc, orMatchers, Object.keys(orMatchers));
    });
  }

  if (field === '$not') {
    return !rowFilter(doc, matcher, Object.keys(matcher));
  }

  //`$nor`
  return !matcher.find(function (orMatchers) {
    return rowFilter(doc, orMatchers, Object.keys(orMatchers));
  });

}

function match(userOperator, doc, userValue, parsedField, docFieldValue) {
  if (!matchers[userOperator]) {
    throw new Error('unknown operator "' + userOperator +
      '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
  }
  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
}

function fieldExists(docFieldValue) {
  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
}

function fieldIsNotUndefined(docFieldValue) {
  return typeof docFieldValue !== 'undefined';
}

function modField(docFieldValue, userValue) {
  var divisor = userValue[0];
  var mod = userValue[1];
  if (divisor === 0) {
    throw new Error('Bad divisor, cannot divide by zero');
  }

  if (parseInt(divisor, 10) !== divisor ) {
    throw new Error('Divisor is not an integer');
  }

  if (parseInt(mod, 10) !== mod ) {
    throw new Error('Modulus is not an integer');
  }

  if (parseInt(docFieldValue, 10) !== docFieldValue) {
    return false;
  }

  return docFieldValue % divisor === mod;
}

function arrayContainsValue(docFieldValue, userValue) {
  return userValue.some(function (val) {
    if (docFieldValue instanceof Array) {
      return docFieldValue.indexOf(val) > -1;
    }

    return docFieldValue === val;
  });
}

function arrayContainsAllValues(docFieldValue, userValue) {
  return userValue.every(function (val) {
    return docFieldValue.indexOf(val) > -1;
  });
}

function arraySize(docFieldValue, userValue) {
  return docFieldValue.length === userValue;
}

function regexMatch(docFieldValue, userValue) {
  var re = new RegExp(userValue);

  return re.test(docFieldValue);
}

function typeMatch(docFieldValue, userValue) {

  switch (userValue) {
    case 'null':
      return docFieldValue === null;
    case 'boolean':
      return typeof (docFieldValue) === 'boolean';
    case 'number':
      return typeof (docFieldValue) === 'number';
    case 'string':
      return typeof (docFieldValue) === 'string';
    case 'array':
      return docFieldValue instanceof Array;
    case 'object':
      return ({}).toString.call(docFieldValue) === '[object Object]';
  }

  throw new Error(userValue + ' not supported as a type.' +
                  'Please use one of object, string, array, number, boolean or null.');

}

var matchers = {

  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.some(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.some(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    /* istanbul ignore next */
    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.every(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.every(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$eq': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
  },

  '$gte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
  },

  '$gt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
  },

  '$lte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
  },

  '$lt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
  },

  '$exists': function (doc, userValue, parsedField, docFieldValue) {
    //a field that is null is still considered to exist
    if (userValue) {
      return fieldIsNotUndefined(docFieldValue);
    }

    return !fieldIsNotUndefined(docFieldValue);
  },

  '$mod': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
  },

  '$ne': function (doc, userValue, parsedField, docFieldValue) {
    return userValue.every(function (neValue) {
      return collate(docFieldValue, neValue) !== 0;
    });
  },
  '$in': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
  },

  '$nin': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
  },

  '$size': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
  },

  '$all': function (doc, userValue, parsedField, docFieldValue) {
    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
  },

  '$regex': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
  },

  '$type': function (doc, userValue, parsedField, docFieldValue) {
    return typeMatch(docFieldValue, userValue);
  }
};

// return true if the given doc matches the supplied selector
function matchesSelector(doc, selector) {
  /* istanbul ignore if */
  if (typeof selector !== 'object') {
    // match the CouchDB error message
    throw new Error('Selector error: expected a JSON object');
  }

  selector = massageSelector(selector);
  var row = {
    'doc': doc
  };

  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
  return rowsMatched && rowsMatched.length === 1;
}

function evalFilter(input) {
  return scopeEval('"use strict";\nreturn ' + input + ';', {});
}

function evalView(input) {
  var code = [
    'return function(doc) {',
    '  "use strict";',
    '  var emitted = false;',
    '  var emit = function (a, b) {',
    '    emitted = true;',
    '  };',
    '  var view = ' + input + ';',
    '  view(doc);',
    '  if (emitted) {',
    '    return true;',
    '  }',
    '};'
  ].join('\n');

  return scopeEval(code, {});
}

function validate(opts, callback) {
  if (opts.selector) {
    if (opts.filter && opts.filter !== '_selector') {
      var filterName = typeof opts.filter === 'string' ?
        opts.filter : 'function';
      return callback(new Error('selector invalid for filter "' + filterName + '"'));
    }
  }
  callback();
}

function normalize(opts) {
  if (opts.view && !opts.filter) {
    opts.filter = '_view';
  }

  if (opts.selector && !opts.filter) {
    opts.filter = '_selector';
  }

  if (opts.filter && typeof opts.filter === 'string') {
    if (opts.filter === '_view') {
      opts.view = normalizeDesignDocFunctionName(opts.view);
    } else {
      opts.filter = normalizeDesignDocFunctionName(opts.filter);
    }
  }
}

function shouldFilter(changesHandler, opts) {
  return opts.filter && typeof opts.filter === 'string' &&
    !opts.doc_ids && !isRemote(changesHandler.db);
}

function filter(changesHandler, opts) {
  var callback = opts.complete;
  if (opts.filter === '_view') {
    if (!opts.view || typeof opts.view !== 'string') {
      var err = createError(BAD_REQUEST,
        '`view` filter parameter not found or invalid.');
      return callback(err);
    }
    // fetch a view from a design doc, make it behave like a filter
    var viewName = parseDesignDocFunctionName(opts.view);
    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&
        ddoc.views[viewName[1]].map;
      if (!mapFun) {
        return callback(createError(MISSING_DOC,
          (ddoc.views ? 'missing json key: ' + viewName[1] :
            'missing json key: views')));
      }
      opts.filter = evalView(mapFun);
      changesHandler.doChanges(opts);
    });
  } else if (opts.selector) {
    opts.filter = function (doc) {
      return matchesSelector(doc, opts.selector);
    };
    changesHandler.doChanges(opts);
  } else {
    // fetch a filter from a design doc
    var filterName = parseDesignDocFunctionName(opts.filter);
    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
      if (!filterFun) {
        return callback(createError(MISSING_DOC,
          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
            : 'missing json key: filters')));
      }
      opts.filter = evalFilter(filterFun);
      changesHandler.doChanges(opts);
    });
  }
}

function applyChangesFilterPlugin(PouchDB) {
  PouchDB._changesFilterPlugin = {
    validate: validate,
    normalize: normalize,
    shouldFilter: shouldFilter,
    filter: filter
  };
}

// TODO: remove from pouchdb-core (breaking)
PouchDB.plugin(applyChangesFilterPlugin);

PouchDB.version = version;

function toObject(array) {
  return array.reduce(function (obj, item) {
    obj[item] = true;
    return obj;
  }, {});
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats',
  // Specific to Couchbase Sync Gateway
  '_removed'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

function parseRevisionInfo(rev) {
  if (!/^\d+-./.test(rev)) {
    return createError(INVALID_REV);
  }
  var idx = rev.indexOf('-');
  var left = rev.substring(0, idx);
  var right = rev.substring(idx + 1);
  return {
    prefix: parseInt(left, 10),
    id: right
  };
}

function makeRevTreeFromRevisions(revisions, opts) {
  var pos = revisions.start - revisions.ids.length + 1;

  var revisionIds = revisions.ids;
  var ids = [revisionIds[0], opts, []];

  for (var i = 1, len = revisionIds.length; i < len; i++) {
    ids = [revisionIds[i], {status: 'missing'}, [ids]];
  }

  return [{
    pos: pos,
    ids: ids
  }];
}

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
function parseDoc(doc, newEdits, dbOpts) {
  if (!dbOpts) {
    dbOpts = {
      deterministic_revs: true
    };
  }

  var nRevNum;
  var newRevId;
  var revInfo;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = uuid();
    }
    newRevId = rev$$1(doc, dbOpts.deterministic_revs);
    if (doc._rev) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      doc._rev_tree = [{
        pos: revInfo.prefix,
        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = revInfo.prefix + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      nRevNum = revInfo.prefix;
      newRevId = revInfo.id;
      doc._rev_tree = [{
        pos: nRevNum,
        ids: [newRevId, opts, []]
      }];
    }
  }

  invalidIdError(doc._id);

  doc._rev = nRevNum + '-' + newRevId;

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(doc, key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        var error = createError(DOC_VALIDATION, key);
        error.message = DOC_VALIDATION.message + ': ' + key;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
}

function parseBase64(data) {
  try {
    return thisAtob(data);
  } catch (e) {
    var err = createError(BAD_ARG,
      'Attachment is not a valid base64 string');
    return {error: err};
  }
}

function preprocessString(att, blobType, callback) {
  var asBinary = parseBase64(att.data);
  if (asBinary.error) {
    return callback(asBinary.error);
  }

  att.length = asBinary.length;
  if (blobType === 'blob') {
    att.data = binStringToBluffer(asBinary, att.content_type);
  } else if (blobType === 'base64') {
    att.data = thisBtoa(asBinary);
  } else { // binary
    att.data = asBinary;
  }
  binaryMd5(asBinary, function (result) {
    att.digest = 'md5-' + result;
    callback();
  });
}

function preprocessBlob(att, blobType, callback) {
  binaryMd5(att.data, function (md5) {
    att.digest = 'md5-' + md5;
    // size is for blobs (browser), length is for buffers (node)
    att.length = att.data.size || att.data.length || 0;
    if (blobType === 'binary') {
      blobToBinaryString(att.data, function (binString) {
        att.data = binString;
        callback();
      });
    } else if (blobType === 'base64') {
      blobToBase64(att.data, function (b64) {
        att.data = b64;
        callback();
      });
    } else {
      callback();
    }
  });
}

function preprocessAttachment(att, blobType, callback) {
  if (att.stub) {
    return callback();
  }
  if (typeof att.data === 'string') { // input is a base64 string
    preprocessString(att, blobType, callback);
  } else { // input is a blob
    preprocessBlob(att, blobType, callback);
  }
}

function preprocessAttachments(docInfos, blobType, callback) {

  if (!docInfos.length) {
    return callback();
  }

  var docv = 0;
  var overallErr;

  docInfos.forEach(function (docInfo) {
    var attachments = docInfo.data && docInfo.data._attachments ?
      Object.keys(docInfo.data._attachments) : [];
    var recv = 0;

    if (!attachments.length) {
      return done();
    }

    function processedAttachment(err) {
      overallErr = err;
      recv++;
      if (recv === attachments.length) {
        done();
      }
    }

    for (var key in docInfo.data._attachments) {
      if (docInfo.data._attachments.hasOwnProperty(key)) {
        preprocessAttachment(docInfo.data._attachments[key],
          blobType, processedAttachment);
      }
    }
  });

  function done() {
    docv++;
    if (docInfos.length === docv) {
      if (overallErr) {
        callback(overallErr);
      } else {
        callback();
      }
    }
  }
}

function updateDoc(revLimit, prev, docInfo, results,
                   i, cb, writeDoc, newEdits) {

  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {
    results[i] = docInfo;
    return cb();
  }

  // sometimes this is pre-calculated. historically not always
  var previousWinningRev = prev.winningRev || winningRev(prev);
  var previouslyDeleted = 'deleted' in prev ? prev.deleted :
    isDeleted(prev, previousWinningRev);
  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
    isDeleted(docInfo.metadata);
  var isRoot = /^1-/.test(docInfo.metadata.rev);

  if (previouslyDeleted && !deleted && newEdits && isRoot) {
    var newDoc = docInfo.data;
    newDoc._rev = previousWinningRev;
    newDoc._id = docInfo.metadata.id;
    docInfo = parseDoc(newDoc, newEdits);
  }

  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

  var inConflict = newEdits && ((
    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

  if (inConflict) {
    var err = createError(REV_CONFLICT);
    results[i] = err;
    return cb();
  }

  var newRev = docInfo.metadata.rev;
  docInfo.metadata.rev_tree = merged.tree;
  docInfo.stemmedRevs = merged.stemmedRevs || [];
  /* istanbul ignore else */
  if (prev.rev_map) {
    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
  }

  // recalculate
  var winningRev$$1 = winningRev(docInfo.metadata);
  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);

  // calculate the total number of documents that were added/removed,
  // from the perspective of total_rows/doc_count
  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
    previouslyDeleted < winningRevIsDeleted ? -1 : 1;

  var newRevIsDeleted;
  if (newRev === winningRev$$1) {
    // if the new rev is the same as the winning rev, we can reuse that value
    newRevIsDeleted = winningRevIsDeleted;
  } else {
    // if they're not the same, then we need to recalculate
    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
  }

  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
    true, delta, i, cb);
}

function rootIsMissing(docInfo) {
  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
}

function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                     writeDoc, opts, overallCallback) {

  // Default to 1000 locally
  revLimit = revLimit || 1000;

  function insertDoc(docInfo, resultsIdx, callback) {
    // Cant insert new deleted documents
    var winningRev$$1 = winningRev(docInfo.metadata);
    var deleted = isDeleted(docInfo.metadata, winningRev$$1);
    if ('was_delete' in opts && deleted) {
      results[resultsIdx] = createError(MISSING_DOC, 'deleted');
      return callback();
    }

    // 4712 - detect whether a new document was inserted with a _rev
    var inConflict = newEdits && rootIsMissing(docInfo);

    if (inConflict) {
      var err = createError(REV_CONFLICT);
      results[resultsIdx] = err;
      return callback();
    }

    var delta = deleted ? 0 : 1;

    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
      delta, resultsIdx, callback);
  }

  var newEdits = opts.new_edits;
  var idsToDocs = new ExportedMap();

  var docsDone = 0;
  var docsToDo = docInfos.length;

  function checkAllDocsDone() {
    if (++docsDone === docsToDo && overallCallback) {
      overallCallback();
    }
  }

  docInfos.forEach(function (currentDoc, resultsIdx) {

    if (currentDoc._id && isLocalId(currentDoc._id)) {
      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
      api[fun](currentDoc, {ctx: tx}, function (err, res) {
        results[resultsIdx] = err || res;
        checkAllDocsDone();
      });
      return;
    }

    var id = currentDoc.metadata.id;
    if (idsToDocs.has(id)) {
      docsToDo--; // duplicate
      idsToDocs.get(id).push([currentDoc, resultsIdx]);
    } else {
      idsToDocs.set(id, [[currentDoc, resultsIdx]]);
    }
  });

  // in the case of new_edits, the user can provide multiple docs
  // with the same id. these need to be processed sequentially
  idsToDocs.forEach(function (docs, id) {
    var numDone = 0;

    function docWritten() {
      if (++numDone < docs.length) {
        nextDoc();
      } else {
        checkAllDocsDone();
      }
    }
    function nextDoc() {
      var value = docs[numDone];
      var currentDoc = value[0];
      var resultsIdx = value[1];

      if (fetchedDocs.has(id)) {
        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
          resultsIdx, docWritten, writeDoc, newEdits);
      } else {
        // Ensure stemming applies to new writes as well
        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
        currentDoc.metadata.rev_tree = merged.tree;
        currentDoc.stemmedRevs = merged.stemmedRevs || [];
        insertDoc(currentDoc, resultsIdx, docWritten);
      }
    }
    nextDoc();
  });
}

// IndexedDB requires a versioned database structure, so we use the
// version here to manage migrations.
var ADAPTER_VERSION = 5;

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
// Keyed by document id
var DOC_STORE = 'document-store';
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE = 'by-sequence';
// Where we store attachments
var ATTACH_STORE = 'attach-store';
// Where we store many-to-many relations
// between attachment digests and seqs
var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

// Where we store database-wide meta data in a single record
// keyed by id: META_STORE
var META_STORE = 'meta-store';
// Where we store local documents
var LOCAL_STORE = 'local-store';
// Where we detect blob support
var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

function safeJsonParse(str) {
  // This try/catch guards against stack overflow errors.
  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
  // cannot overflow.
  try {
    return JSON.parse(str);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.parse(str);
  }
}

function safeJsonStringify(json) {
  try {
    return JSON.stringify(json);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela.stringify(json);
  }
}

function idbError(callback) {
  return function (evt) {
    var message = 'unknown_error';
    if (evt.target && evt.target.error) {
      message = evt.target.error.name || evt.target.error.message;
    }
    callback(createError(IDB_ERROR, message, evt.type));
  };
}

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
function encodeMetadata(metadata, winningRev, deleted) {
  return {
    data: safeJsonStringify(metadata),
    winningRev: winningRev,
    deletedOrLocal: deleted ? '1' : '0',
    seq: metadata.seq, // highest seq for this doc
    id: metadata.id
  };
}

function decodeMetadata(storedObject) {
  if (!storedObject) {
    return null;
  }
  var metadata = safeJsonParse(storedObject.data);
  metadata.winningRev = storedObject.winningRev;
  metadata.deleted = storedObject.deletedOrLocal === '1';
  metadata.seq = storedObject.seq;
  return metadata;
}

// read the doc back out from the database. we don't store the
// _id or _rev because we already have _doc_id_rev.
function decodeDoc(doc) {
  if (!doc) {
    return doc;
  }
  var idx = doc._doc_id_rev.lastIndexOf(':');
  doc._id = doc._doc_id_rev.substring(0, idx - 1);
  doc._rev = doc._doc_id_rev.substring(idx + 1);
  delete doc._doc_id_rev;
  return doc;
}

// Read a blob from the database, encoding as necessary
// and translating from base64 if the IDB doesn't support
// native Blobs
function readBlobData(body, type, asBlob, callback) {
  if (asBlob) {
    if (!body) {
      callback(createBlob([''], {type: type}));
    } else if (typeof body !== 'string') { // we have blob support
      callback(body);
    } else { // no blob support
      callback(b64ToBluffer(body, type));
    }
  } else { // as base64 string
    if (!body) {
      callback('');
    } else if (typeof body !== 'string') { // we have blob support
      readAsBinaryString(body, function (binary) {
        callback(thisBtoa(binary));
      });
    } else { // no blob support
      callback(body);
    }
  }
}

function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
  var attachments = Object.keys(doc._attachments || {});
  if (!attachments.length) {
    return cb && cb();
  }
  var numDone = 0;

  function checkDone() {
    if (++numDone === attachments.length && cb) {
      cb();
    }
  }

  function fetchAttachment(doc, att) {
    var attObj = doc._attachments[att];
    var digest = attObj.digest;
    var req = txn.objectStore(ATTACH_STORE).get(digest);
    req.onsuccess = function (e) {
      attObj.body = e.target.result.body;
      checkDone();
    };
  }

  attachments.forEach(function (att) {
    if (opts.attachments && opts.include_docs) {
      fetchAttachment(doc, att);
    } else {
      doc._attachments[att].stub = true;
      checkDone();
    }
  });
}

// IDB-specific postprocessing necessary because
// we don't know whether we stored a true Blob or
// a base64-encoded string, and if it's a Blob it
// needs to be read outside of the transaction context
function postProcessAttachments(results, asBlob) {
  return Promise.all(results.map(function (row) {
    if (row.doc && row.doc._attachments) {
      var attNames = Object.keys(row.doc._attachments);
      return Promise.all(attNames.map(function (att) {
        var attObj = row.doc._attachments[att];
        if (!('body' in attObj)) { // already processed
          return;
        }
        var body = attObj.body;
        var type = attObj.content_type;
        return new Promise(function (resolve) {
          readBlobData(body, type, asBlob, function (data) {
            row.doc._attachments[att] = $inject_Object_assign(
              pick(attObj, ['digest', 'content_type']),
              {data: data}
            );
            resolve();
          });
        });
      }));
    }
  }));
}

function compactRevs(revs, docId, txn) {

  var possiblyOrphanedDigests = [];
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var attStore = txn.objectStore(ATTACH_STORE);
  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
  var count = revs.length;

  function checkDone() {
    count--;
    if (!count) { // done processing all revs
      deleteOrphanedAttachments();
    }
  }

  function deleteOrphanedAttachments() {
    if (!possiblyOrphanedDigests.length) {
      return;
    }
    possiblyOrphanedDigests.forEach(function (digest) {
      var countReq = attAndSeqStore.index('digestSeq').count(
        IDBKeyRange.bound(
          digest + '::', digest + '::\uffff', false, false));
      countReq.onsuccess = function (e) {
        var count = e.target.result;
        if (!count) {
          // orphaned
          attStore.delete(digest);
        }
      };
    });
  }

  revs.forEach(function (rev) {
    var index = seqStore.index('_doc_id_rev');
    var key = docId + "::" + rev;
    index.getKey(key).onsuccess = function (e) {
      var seq = e.target.result;
      if (typeof seq !== 'number') {
        return checkDone();
      }
      seqStore.delete(seq);

      var cursor = attAndSeqStore.index('seq')
        .openCursor(IDBKeyRange.only(seq));

      cursor.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          var digest = cursor.value.digestSeq.split('::')[0];
          possiblyOrphanedDigests.push(digest);
          attAndSeqStore.delete(cursor.primaryKey);
          cursor.continue();
        } else { // done
          checkDone();
        }
      };
    };
  });
}

function openTransactionSafely(idb, stores, mode) {
  try {
    return {
      txn: idb.transaction(stores, mode)
    };
  } catch (err) {
    return {
      error: err
    };
  }
}

var changesHandler = new Changes();

function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
  var docInfos = req.docs;
  var txn;
  var docStore;
  var bySeqStore;
  var attachStore;
  var attachAndSeqStore;
  var metaStore;
  var docInfoError;
  var metaDoc;

  for (var i = 0, len = docInfos.length; i < len; i++) {
    var doc = docInfos[i];
    if (doc._id && isLocalId(doc._id)) {
      continue;
    }
    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);
    if (doc.error && !docInfoError) {
      docInfoError = doc;
    }
  }

  if (docInfoError) {
    return callback(docInfoError);
  }

  var allDocsProcessed = false;
  var docCountDelta = 0;
  var results = new Array(docInfos.length);
  var fetchedDocs = new ExportedMap();
  var preconditionErrored = false;
  var blobType = api._meta.blobSupport ? 'blob' : 'base64';

  preprocessAttachments(docInfos, blobType, function (err) {
    if (err) {
      return callback(err);
    }
    startTransaction();
  });

  function startTransaction() {

    var stores = [
      DOC_STORE, BY_SEQ_STORE,
      ATTACH_STORE,
      LOCAL_STORE, ATTACH_AND_SEQ_STORE,
      META_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    txn = txnResult.txn;
    txn.onabort = idbError(callback);
    txn.ontimeout = idbError(callback);
    txn.oncomplete = complete;
    docStore = txn.objectStore(DOC_STORE);
    bySeqStore = txn.objectStore(BY_SEQ_STORE);
    attachStore = txn.objectStore(ATTACH_STORE);
    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
    metaStore = txn.objectStore(META_STORE);

    metaStore.get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result;
      updateDocCountIfReady();
    };

    verifyAttachments(function (err) {
      if (err) {
        preconditionErrored = true;
        return callback(err);
      }
      fetchExistingDocs();
    });
  }

  function onAllDocsProcessed() {
    allDocsProcessed = true;
    updateDocCountIfReady();
  }

  function idbProcessDocs() {
    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                txn, results, writeDoc, opts, onAllDocsProcessed);
  }

  function updateDocCountIfReady() {
    if (!metaDoc || !allDocsProcessed) {
      return;
    }
    // caching the docCount saves a lot of time in allDocs() and
    // info(), which is why we go to all the trouble of doing this
    metaDoc.docCount += docCountDelta;
    metaStore.put(metaDoc);
  }

  function fetchExistingDocs() {

    if (!docInfos.length) {
      return;
    }

    var numFetched = 0;

    function checkDone() {
      if (++numFetched === docInfos.length) {
        idbProcessDocs();
      }
    }

    function readMetadata(event) {
      var metadata = decodeMetadata(event.target.result);

      if (metadata) {
        fetchedDocs.set(metadata.id, metadata);
      }
      checkDone();
    }

    for (var i = 0, len = docInfos.length; i < len; i++) {
      var docInfo = docInfos[i];
      if (docInfo._id && isLocalId(docInfo._id)) {
        checkDone(); // skip local docs
        continue;
      }
      var req = docStore.get(docInfo.metadata.id);
      req.onsuccess = readMetadata;
    }
  }

  function complete() {
    if (preconditionErrored) {
      return;
    }

    changesHandler.notify(api._meta.name);
    callback(null, results);
  }

  function verifyAttachment(digest, callback) {

    var req = attachStore.get(digest);
    req.onsuccess = function (e) {
      if (!e.target.result) {
        var err = createError(MISSING_STUB,
          'unknown stub attachment with digest ' +
          digest);
        err.status = 412;
        callback(err);
      } else {
        callback();
      }
    };
  }

  function verifyAttachments(finish) {


    var digests = [];
    docInfos.forEach(function (docInfo) {
      if (docInfo.data && docInfo.data._attachments) {
        Object.keys(docInfo.data._attachments).forEach(function (filename) {
          var att = docInfo.data._attachments[filename];
          if (att.stub) {
            digests.push(att.digest);
          }
        });
      }
    });
    if (!digests.length) {
      return finish();
    }
    var numDone = 0;
    var err;

    function checkDone() {
      if (++numDone === digests.length) {
        finish(err);
      }
    }
    digests.forEach(function (digest) {
      verifyAttachment(digest, function (attErr) {
        if (attErr && !err) {
          err = attErr;
        }
        checkDone();
      });
    });
  }

  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                    isUpdate, delta, resultsIdx, callback) {

    docInfo.metadata.winningRev = winningRev$$1;
    docInfo.metadata.deleted = winningRevIsDeleted;

    var doc = docInfo.data;
    doc._id = docInfo.metadata.id;
    doc._rev = docInfo.metadata.rev;

    if (newRevIsDeleted) {
      doc._deleted = true;
    }

    var hasAttachments = doc._attachments &&
      Object.keys(doc._attachments).length;
    if (hasAttachments) {
      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
        isUpdate, resultsIdx, callback);
    }

    docCountDelta += delta;
    updateDocCountIfReady();

    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
      isUpdate, resultsIdx, callback);
  }

  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
                     isUpdate, resultsIdx, callback) {

    var doc = docInfo.data;
    var metadata = docInfo.metadata;

    doc._doc_id_rev = metadata.id + '::' + metadata.rev;
    delete doc._id;
    delete doc._rev;

    function afterPutDoc(e) {
      var revsToDelete = docInfo.stemmedRevs || [];

      if (isUpdate && api.auto_compaction) {
        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
      }

      if (revsToDelete && revsToDelete.length) {
        compactRevs(revsToDelete, docInfo.metadata.id, txn);
      }

      metadata.seq = e.target.result;
      // Current _rev is calculated from _rev_tree on read
      // delete metadata.rev;
      var metadataToStore = encodeMetadata(metadata, winningRev$$1,
        winningRevIsDeleted);
      var metaDataReq = docStore.put(metadataToStore);
      metaDataReq.onsuccess = afterPutMetadata;
    }

    function afterPutDocError(e) {
      // ConstraintError, need to update, not put (see #1638 for details)
      e.preventDefault(); // avoid transaction abort
      e.stopPropagation(); // avoid transaction onerror
      var index = bySeqStore.index('_doc_id_rev');
      var getKeyReq = index.getKey(doc._doc_id_rev);
      getKeyReq.onsuccess = function (e) {
        var putReq = bySeqStore.put(doc, e.target.result);
        putReq.onsuccess = afterPutDoc;
      };
    }

    function afterPutMetadata() {
      results[resultsIdx] = {
        ok: true,
        id: metadata.id,
        rev: metadata.rev
      };
      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
      insertAttachmentMappings(docInfo, metadata.seq, callback);
    }

    var putReq = bySeqStore.put(doc);

    putReq.onsuccess = afterPutDoc;
    putReq.onerror = afterPutDocError;
  }

  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
                            isUpdate, resultsIdx, callback) {


    var doc = docInfo.data;

    var numDone = 0;
    var attachments = Object.keys(doc._attachments);

    function collectResults() {
      if (numDone === attachments.length) {
        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
          isUpdate, resultsIdx, callback);
      }
    }

    function attachmentSaved() {
      numDone++;
      collectResults();
    }

    attachments.forEach(function (key) {
      var att = docInfo.data._attachments[key];
      if (!att.stub) {
        var data = att.data;
        delete att.data;
        att.revpos = parseInt(winningRev$$1, 10);
        var digest = att.digest;
        saveAttachment(digest, data, attachmentSaved);
      } else {
        numDone++;
        collectResults();
      }
    });
  }

  // map seqs to attachment digests, which
  // we will need later during compaction
  function insertAttachmentMappings(docInfo, seq, callback) {

    var attsAdded = 0;
    var attsToAdd = Object.keys(docInfo.data._attachments || {});

    if (!attsToAdd.length) {
      return callback();
    }

    function checkDone() {
      if (++attsAdded === attsToAdd.length) {
        callback();
      }
    }

    function add(att) {
      var digest = docInfo.data._attachments[att].digest;
      var req = attachAndSeqStore.put({
        seq: seq,
        digestSeq: digest + '::' + seq
      });

      req.onsuccess = checkDone;
      req.onerror = function (e) {
        // this callback is for a constaint error, which we ignore
        // because this docid/rev has already been associated with
        // the digest (e.g. when new_edits == false)
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
        checkDone();
      };
    }
    for (var i = 0; i < attsToAdd.length; i++) {
      add(attsToAdd[i]); // do in parallel
    }
  }

  function saveAttachment(digest, data, callback) {


    var getKeyReq = attachStore.count(digest);
    getKeyReq.onsuccess = function (e) {
      var count = e.target.result;
      if (count) {
        return callback(); // already exists
      }
      var newAtt = {
        digest: digest,
        body: data
      };
      var putReq = attachStore.put(newAtt);
      putReq.onsuccess = callback;
    };
  }
}

// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
// we're not processing each document one-at-a-time.
function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {

  if (batchSize === -1) {
    batchSize = 1000;
  }

  // Bail out of getAll()/getAllKeys() in the following cases:
  // 1) either method is unsupported - we need both
  // 2) batchSize is 1 (might as well use IDBCursor)
  // 3) descending – no real way to do this via getAll()/getAllKeys()

  var useGetAll = typeof objectStore.getAll === 'function' &&
    typeof objectStore.getAllKeys === 'function' &&
    batchSize > 1 && !descending;

  var keysBatch;
  var valuesBatch;
  var pseudoCursor;

  function onGetAll(e) {
    valuesBatch = e.target.result;
    if (keysBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function onGetAllKeys(e) {
    keysBatch = e.target.result;
    if (valuesBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function continuePseudoCursor() {
    if (!keysBatch.length) { // no more results
      return onBatch();
    }
    // fetch next batch, exclusive start
    var lastKey = keysBatch[keysBatch.length - 1];
    var newKeyRange;
    if (keyRange && keyRange.upper) {
      try {
        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
          true, keyRange.upperOpen);
      } catch (e) {
        if (e.name === "DataError" && e.code === 0) {
          return onBatch(); // we're done, startkey and endkey are equal
        }
      }
    } else {
      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
    }
    keyRange = newKeyRange;
    keysBatch = null;
    valuesBatch = null;
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  }

  function onCursor(e) {
    var cursor = e.target.result;
    if (!cursor) { // done
      return onBatch();
    }
    // regular IDBCursor acts like a batch where batch size is always 1
    onBatch([cursor.key], [cursor.value], cursor);
  }

  if (useGetAll) {
    pseudoCursor = {"continue": continuePseudoCursor};
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  } else if (descending) {
    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
  } else {
    objectStore.openCursor(keyRange).onsuccess = onCursor;
  }
}

// simple shim for objectStore.getAll(), falling back to IDBCursor
function getAll(objectStore, keyRange, onSuccess) {
  if (typeof objectStore.getAll === 'function') {
    // use native getAll
    objectStore.getAll(keyRange).onsuccess = onSuccess;
    return;
  }
  // fall back to cursors
  var values = [];

  function onCursor(e) {
    var cursor = e.target.result;
    if (cursor) {
      values.push(cursor.value);
      cursor.continue();
    } else {
      onSuccess({
        target: {
          result: values
        }
      });
    }
  }

  objectStore.openCursor(keyRange).onsuccess = onCursor;
}

function allDocsKeys(keys, docStore, onBatch) {
  // It's not guaranted to be returned in right order  
  var valuesBatch = new Array(keys.length);
  var count = 0;
  keys.forEach(function (key, index) {
    docStore.get(key).onsuccess = function (event) {
      if (event.target.result) {
        valuesBatch[index] = event.target.result;
      } else {
        valuesBatch[index] = {key: key, error: 'not_found'};
      }
      count++;
      if (count === keys.length) {
        onBatch(keys, valuesBatch, {});
      }
    };
  });
}

function createKeyRange(start, end, inclusiveEnd, key, descending) {
  try {
    if (start && end) {
      if (descending) {
        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
      } else {
        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
      }
    } else if (start) {
      if (descending) {
        return IDBKeyRange.upperBound(start);
      } else {
        return IDBKeyRange.lowerBound(start);
      }
    } else if (end) {
      if (descending) {
        return IDBKeyRange.lowerBound(end, !inclusiveEnd);
      } else {
        return IDBKeyRange.upperBound(end, !inclusiveEnd);
      }
    } else if (key) {
      return IDBKeyRange.only(key);
    }
  } catch (e) {
    return {error: e};
  }
  return null;
}

function idbAllDocs(opts, idb, callback) {
  var start = 'startkey' in opts ? opts.startkey : false;
  var end = 'endkey' in opts ? opts.endkey : false;
  var key = 'key' in opts ? opts.key : false;
  var keys = 'keys' in opts ? opts.keys : false; 
  var skip = opts.skip || 0;
  var limit = typeof opts.limit === 'number' ? opts.limit : -1;
  var inclusiveEnd = opts.inclusive_end !== false;

  var keyRange ; 
  var keyRangeError;
  if (!keys) {
    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
    keyRangeError = keyRange && keyRange.error;
    if (keyRangeError && 
      !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
      // DataError with error code 0 indicates start is less than end, so
      // can just do an empty query. Else need to throw
      return callback(createError(IDB_ERROR,
        keyRangeError.name, keyRangeError.message));
    }
  }

  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

  if (opts.attachments) {
    stores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, stores, 'readonly');
  if (txnResult.error) {
    return callback(txnResult.error);
  }
  var txn = txnResult.txn;
  txn.oncomplete = onTxnComplete;
  txn.onabort = idbError(callback);
  var docStore = txn.objectStore(DOC_STORE);
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var metaStore = txn.objectStore(META_STORE);
  var docIdRevIndex = seqStore.index('_doc_id_rev');
  var results = [];
  var docCount;
  var updateSeq;

  metaStore.get(META_STORE).onsuccess = function (e) {
    docCount = e.target.result.docCount;
  };

  /* istanbul ignore if */
  if (opts.update_seq) {
    getMaxUpdateSeq(seqStore, function (e) { 
      if (e.target.result && e.target.result.length > 0) {
        updateSeq = e.target.result[0];
      }
    });
  }

  function getMaxUpdateSeq(objectStore, onSuccess) {
    function onCursor(e) {
      var cursor = e.target.result;
      var maxKey = undefined;
      if (cursor && cursor.key) {
        maxKey = cursor.key;
      } 
      return onSuccess({
        target: {
          result: [maxKey]
        }
      });
    }
    objectStore.openCursor(null, 'prev').onsuccess = onCursor;
  }

  // if the user specifies include_docs=true, then we don't
  // want to block the main cursor while we're fetching the doc
  function fetchDocAsynchronously(metadata, row, winningRev$$1) {
    var key = metadata.id + "::" + winningRev$$1;
    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {
      row.doc = decodeDoc(e.target.result) || {};
      if (opts.conflicts) {
        var conflicts = collectConflicts(metadata);
        if (conflicts.length) {
          row.doc._conflicts = conflicts;
        }
      }
      fetchAttachmentsIfNecessary(row.doc, opts, txn);
    };
  }

  function allDocsInner(winningRev$$1, metadata) {
    var row = {
      id: metadata.id,
      key: metadata.id,
      value: {
        rev: winningRev$$1
      }
    };
    var deleted = metadata.deleted;
    if (deleted) {
      if (keys) {
        results.push(row);
        // deleted docs are okay with "keys" requests
        row.value.deleted = true;
        row.doc = null;
      }
    } else if (skip-- <= 0) {
      results.push(row);
      if (opts.include_docs) {
        fetchDocAsynchronously(metadata, row, winningRev$$1);
      }
    }
  }

  function processBatch(batchValues) {
    for (var i = 0, len = batchValues.length; i < len; i++) {
      if (results.length === limit) {
        break;
      }
      var batchValue = batchValues[i];
      if (batchValue.error && keys) {
        // key was not found with "keys" requests
        results.push(batchValue);
        continue;
      }
      var metadata = decodeMetadata(batchValue);
      var winningRev$$1 = metadata.winningRev;
      allDocsInner(winningRev$$1, metadata);
    }
  }

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor) {
      return;
    }
    processBatch(batchValues);
    if (results.length < limit) {
      cursor.continue();
    }
  }

  function onGetAll(e) {
    var values = e.target.result;
    if (opts.descending) {
      values = values.reverse();
    }
    processBatch(values);
  }

  function onResultsReady() {
    var returnVal = {
      total_rows: docCount,
      offset: opts.skip,
      rows: results
    };
    
    /* istanbul ignore if */
    if (opts.update_seq && updateSeq !== undefined) {
      returnVal.update_seq = updateSeq;
    }
    callback(null, returnVal);
  }

  function onTxnComplete() {
    if (opts.attachments) {
      postProcessAttachments(results, opts.binary).then(onResultsReady);
    } else {
      onResultsReady();
    }
  }

  // don't bother doing any requests if start > end or limit === 0
  if (keyRangeError || limit === 0) {
    return;
  }
  if (keys) {
    return allDocsKeys(opts.keys, docStore, onBatch);
  }
  if (limit === -1) { // just fetch everything
    return getAll(docStore, keyRange, onGetAll);
  }
  // else do a cursor
  // choose a batch size based on the skip, since we'll need to skip that many
  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
function checkBlobSupport(txn) {
  return new Promise(function (resolve) {
    var blob$$1 = createBlob(['']);
    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');

    req.onsuccess = function () {
      var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
      var matchedEdge = navigator.userAgent.match(/Edge\//);
      // MS Edge pretends to be Chrome 42:
      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
      resolve(matchedEdge || !matchedChrome ||
        parseInt(matchedChrome[1], 10) >= 43);
    };

    req.onerror = txn.onabort = function (e) {
      // If the transaction aborts now its due to not being able to
      // write to the database, likely due to the disk being full
      e.preventDefault();
      e.stopPropagation();
      resolve(false);
    };
  }).catch(function () {
    return false; // error, so assume unsupported
  });
}

function countDocs(txn, cb) {
  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
    cb(e.target.result);
  };
}

// This task queue ensures that IDB open calls are done in their own tick

var running = false;
var queue = [];

function tryCode(fun, err, res, PouchDB) {
  try {
    fun(err, res);
  } catch (err) {
    // Shouldn't happen, but in some odd cases
    // IndexedDB implementations might throw a sync
    // error, in which case this will at least log it.
    PouchDB.emit('error', err);
  }
}

function applyNext() {
  if (running || !queue.length) {
    return;
  }
  running = true;
  queue.shift()();
}

function enqueueTask(action, callback, PouchDB) {
  queue.push(function runAction() {
    action(function runCallback(err, res) {
      tryCode(callback, err, res, PouchDB);
      running = false;
      nextTick(function runNext() {
        applyNext(PouchDB);
      });
    });
  });
  applyNext();
}

function changes(opts, api, dbName, idb) {
  opts = clone(opts);

  if (opts.continuous) {
    var id = dbName + ':' + uuid();
    changesHandler.addListener(dbName, id, api, opts);
    changesHandler.notify(dbName);
    return {
      cancel: function () {
        changesHandler.removeListener(dbName, id);
      }
    };
  }

  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);

  opts.since = opts.since || 0;
  var lastSeq = opts.since;

  var limit = 'limit' in opts ? opts.limit : -1;
  if (limit === 0) {
    limit = 1; // per CouchDB _changes spec
  }

  var results = [];
  var numResults = 0;
  var filter = filterChange(opts);
  var docIdsToMetadata = new ExportedMap();

  var txn;
  var bySeqStore;
  var docStore;
  var docIdRevIndex;

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor || !batchKeys.length) { // done
      return;
    }

    var winningDocs = new Array(batchKeys.length);
    var metadatas = new Array(batchKeys.length);

    function processMetadataAndWinningDoc(metadata, winningDoc) {
      var change = opts.processChange(winningDoc, metadata, opts);
      lastSeq = change.seq = metadata.seq;

      var filtered = filter(change);
      if (typeof filtered === 'object') { // anything but true/false indicates error
        return Promise.reject(filtered);
      }

      if (!filtered) {
        return Promise.resolve();
      }
      numResults++;
      if (opts.return_docs) {
        results.push(change);
      }
      // process the attachment immediately
      // for the benefit of live listeners
      if (opts.attachments && opts.include_docs) {
        return new Promise(function (resolve) {
          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
            postProcessAttachments([change], opts.binary).then(function () {
              resolve(change);
            });
          });
        });
      } else {
        return Promise.resolve(change);
      }
    }

    function onBatchDone() {
      var promises = [];
      for (var i = 0, len = winningDocs.length; i < len; i++) {
        if (numResults === limit) {
          break;
        }
        var winningDoc = winningDocs[i];
        if (!winningDoc) {
          continue;
        }
        var metadata = metadatas[i];
        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));
      }

      Promise.all(promises).then(function (changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          if (changes[i]) {
            opts.onChange(changes[i]);
          }
        }
      }).catch(opts.complete);

      if (numResults !== limit) {
        cursor.continue();
      }
    }

    // Fetch all metadatas/winningdocs from this batch in parallel, then process
    // them all only once all data has been collected. This is done in parallel
    // because it's faster than doing it one-at-a-time.
    var numDone = 0;
    batchValues.forEach(function (value, i) {
      var doc = decodeDoc(value);
      var seq = batchKeys[i];
      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
        metadatas[i] = metadata;
        winningDocs[i] = winningDoc;
        if (++numDone === batchKeys.length) {
          onBatchDone();
        }
      });
    });
  }

  function onGetMetadata(doc, seq, metadata, cb) {
    if (metadata.seq !== seq) {
      // some other seq is later
      return cb();
    }

    if (metadata.winningRev === doc._rev) {
      // this is the winning doc
      return cb(metadata, doc);
    }

    // fetch winning doc in separate request
    var docIdRev = doc._id + '::' + metadata.winningRev;
    var req = docIdRevIndex.get(docIdRev);
    req.onsuccess = function (e) {
      cb(metadata, decodeDoc(e.target.result));
    };
  }

  function fetchWinningDocAndMetadata(doc, seq, cb) {
    if (docIds && !docIds.has(doc._id)) {
      return cb();
    }

    var metadata = docIdsToMetadata.get(doc._id);
    if (metadata) { // cached
      return onGetMetadata(doc, seq, metadata, cb);
    }
    // metadata not cached, have to go fetch it
    docStore.get(doc._id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      docIdsToMetadata.set(doc._id, metadata);
      onGetMetadata(doc, seq, metadata, cb);
    };
  }

  function finish() {
    opts.complete(null, {
      results: results,
      last_seq: lastSeq
    });
  }

  function onTxnComplete() {
    if (!opts.continuous && opts.attachments) {
      // cannot guarantee that postProcessing was already done,
      // so do it again
      postProcessAttachments(results).then(finish);
    } else {
      finish();
    }
  }

  var objectStores = [DOC_STORE, BY_SEQ_STORE];
  if (opts.attachments) {
    objectStores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
  if (txnResult.error) {
    return opts.complete(txnResult.error);
  }
  txn = txnResult.txn;
  txn.onabort = idbError(opts.complete);
  txn.oncomplete = onTxnComplete;

  bySeqStore = txn.objectStore(BY_SEQ_STORE);
  docStore = txn.objectStore(DOC_STORE);
  docIdRevIndex = bySeqStore.index('_doc_id_rev');

  var keyRange = (opts.since && !opts.descending) ?
    IDBKeyRange.lowerBound(opts.since, true) : null;

  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
}

var cachedDBs = new ExportedMap();
var blobSupportPromise;
var openReqList = new ExportedMap();

function IdbPouch(opts, callback) {
  var api = this;

  enqueueTask(function (thisCallback) {
    init(api, opts, thisCallback);
  }, callback, api.constructor);
}

function init(api, opts, callback) {

  var dbName = opts.name;

  var idb = null;
  api._meta = null;

  // called when creating a fresh new database
  function createSchema(db) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

    // added in v2
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    // added in v3
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});

    // added in v4
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 2
  // unfortunately "deletedOrLocal" is a misnomer now that we no longer
  // store local docs in the main doc-store, but whaddyagonnado
  function addDeletedOrLocalIndex(txn, callback) {
    var docStore = txn.objectStore(DOC_STORE);
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    docStore.openCursor().onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var deleted = isDeleted(metadata);
        metadata.deletedOrLocal = deleted ? "1" : "0";
        docStore.put(metadata);
        cursor.continue();
      } else {
        callback();
      }
    };
  }

  // migration to version 3 (part 1)
  function createLocalStoreSchema(db) {
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
  }

  // migration to version 3 (part 2)
  function migrateLocalStore(txn, cb) {
    var localStore = txn.objectStore(LOCAL_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);

    var cursor = docStore.openCursor();
    cursor.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var docId = metadata.id;
        var local = isLocalId(docId);
        var rev = winningRev(metadata);
        if (local) {
          var docIdRev = docId + "::" + rev;
          // remove all seq entries
          // associated with this docId
          var start = docId + "::";
          var end = docId + "::~";
          var index = seqStore.index('_doc_id_rev');
          var range = IDBKeyRange.bound(start, end, false, false);
          var seqCursor = index.openCursor(range);
          seqCursor.onsuccess = function (e) {
            seqCursor = e.target.result;
            if (!seqCursor) {
              // done
              docStore.delete(cursor.primaryKey);
              cursor.continue();
            } else {
              var data = seqCursor.value;
              if (data._doc_id_rev === docIdRev) {
                localStore.put(data);
              }
              seqStore.delete(seqCursor.primaryKey);
              seqCursor.continue();
            }
          };
        } else {
          cursor.continue();
        }
      } else if (cb) {
        cb();
      }
    };
  }

  // migration to version 4 (part 1)
  function addAttachAndSeqStore(db) {
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 4 (part 2)
  function migrateAttsAndSeqs(txn, callback) {
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    // need to actually populate the table. this is the expensive part,
    // so as an optimization, check first that this database even
    // contains attachments
    var req = attStore.count();
    req.onsuccess = function (e) {
      var count = e.target.result;
      if (!count) {
        return callback(); // done
      }

      seqStore.openCursor().onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          return callback(); // done
        }
        var doc = cursor.value;
        var seq = cursor.primaryKey;
        var atts = Object.keys(doc._attachments || {});
        var digestMap = {};
        for (var j = 0; j < atts.length; j++) {
          var att = doc._attachments[atts[j]];
          digestMap[att.digest] = true; // uniq digests, just in case
        }
        var digests = Object.keys(digestMap);
        for (j = 0; j < digests.length; j++) {
          var digest = digests[j];
          attAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });
        }
        cursor.continue();
      };
    };
  }

  // migration to version 5
  // Instead of relying on on-the-fly migration of metadata,
  // this brings the doc-store to its modern form:
  // - metadata.winningrev
  // - metadata.seq
  // - stringify the metadata when storing it
  function migrateMetadata(txn) {

    function decodeMetadataCompat(storedObject) {
      if (!storedObject.data) {
        // old format, when we didn't store it stringified
        storedObject.deleted = storedObject.deletedOrLocal === '1';
        return storedObject;
      }
      return decodeMetadata(storedObject);
    }

    // ensure that every metadata has a winningRev and seq,
    // which was previously created on-the-fly but better to migrate
    var bySeqStore = txn.objectStore(BY_SEQ_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var cursor = docStore.openCursor();
    cursor.onsuccess = function (e) {
      var cursor = e.target.result;
      if (!cursor) {
        return; // done
      }
      var metadata = decodeMetadataCompat(cursor.value);

      metadata.winningRev = metadata.winningRev ||
        winningRev(metadata);

      function fetchMetadataSeq() {
        // metadata.seq was added post-3.2.0, so if it's missing,
        // we need to fetch it manually
        var start = metadata.id + '::';
        var end = metadata.id + '::\uffff';
        var req = bySeqStore.index('_doc_id_rev').openCursor(
          IDBKeyRange.bound(start, end));

        var metadataSeq = 0;
        req.onsuccess = function (e) {
          var cursor = e.target.result;
          if (!cursor) {
            metadata.seq = metadataSeq;
            return onGetMetadataSeq();
          }
          var seq = cursor.primaryKey;
          if (seq > metadataSeq) {
            metadataSeq = seq;
          }
          cursor.continue();
        };
      }

      function onGetMetadataSeq() {
        var metadataToStore = encodeMetadata(metadata,
          metadata.winningRev, metadata.deleted);

        var req = docStore.put(metadataToStore);
        req.onsuccess = function () {
          cursor.continue();
        };
      }

      if (metadata.seq) {
        return onGetMetadataSeq();
      }

      fetchMetadataSeq();
    };

  }

  api._remote = false;
  api.type = function () {
    return 'idb';
  };

  api._id = toPromise(function (callback) {
    callback(null, api._meta.instanceId);
  });

  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
    idbBulkDocs(opts, req, reqOpts, api, idb, callback);
  };

  // First we look up the metadata in the ids database, then we fetch the
  // current revision(s) from the by sequence store
  api._get = function idb_get(id, opts, callback) {
    var doc;
    var metadata;
    var err;
    var txn = opts.ctx;
    if (!txn) {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: txn});
    }

    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      // we can determine the result here if:
      // 1. there is no such document
      // 2. the document is deleted and we don't ask about specific rev
      // When we ask with opts.rev we expect the answer to be either
      // doc (possibly with _deleted=true) or missing error
      if (!metadata) {
        err = createError(MISSING_DOC, 'missing');
        return finish();
      }

      var rev;
      if (!opts.rev) {
        rev = metadata.winningRev;
        var deleted = isDeleted(metadata);
        if (deleted) {
          err = createError(MISSING_DOC, "deleted");
          return finish();
        }
      } else {
        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;
      }

      var objectStore = txn.objectStore(BY_SEQ_STORE);
      var key = metadata.id + '::' + rev;

      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
        doc = e.target.result;
        if (doc) {
          doc = decodeDoc(doc);
        }
        if (!doc) {
          err = createError(MISSING_DOC, 'missing');
          return finish();
        }
        finish();
      };
    };
  };

  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var txn;
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }
    var digest = attachment.digest;
    var type = attachment.content_type;

    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
      var body = e.target.result.body;
      readBlobData(body, type, opts.binary, function (blobData) {
        callback(null, blobData);
      });
    };
  };

  api._info = function idb_info(callback) {
    var updateSeq;
    var docCount;

    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      docCount = e.target.result.docCount;
    };
    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
      var cursor = e.target.result;
      updateSeq = cursor ? cursor.key : 0;
    };

    txn.oncomplete = function () {
      callback(null, {
        doc_count: docCount,
        update_seq: updateSeq,
        // for debugging
        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
      });
    };
  };

  api._allDocs = function idb_allDocs(opts, callback) {
    idbAllDocs(opts, idb, callback);
  };

  api._changes = function idbChanges(opts) {
    return changes(opts, api, dbName, idb);
  };

  api._close = function (callback) {
    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
    // "Returns immediately and closes the connection in a separate thread..."
    idb.close();
    cachedDBs.delete(dbName);
    callback();
  };

  api._getRevisionTree = function (docId, callback) {
    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    var req = txn.objectStore(DOC_STORE).get(docId);
    req.onsuccess = function (event) {
      var doc = decodeMetadata(event.target.result);
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        callback(null, doc.rev_tree);
      }
    };
  };

  // This function removes revisions of document docId
  // which are listed in revs and sets this document
  // revision to to rev_tree
  api._doCompaction = function (docId, revs, callback) {
    var stores = [
      DOC_STORE,
      BY_SEQ_STORE,
      ATTACH_STORE,
      ATTACH_AND_SEQ_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;

    var docStore = txn.objectStore(DOC_STORE);

    docStore.get(docId).onsuccess = function (event) {
      var metadata = decodeMetadata(event.target.result);
      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev = pos + '-' + revHash;
        if (revs.indexOf(rev) !== -1) {
          opts.status = 'missing';
        }
      });
      compactRevs(revs, docId, txn);
      var winningRev$$1 = metadata.winningRev;
      var deleted = metadata.deleted;
      txn.objectStore(DOC_STORE).put(
        encodeMetadata(metadata, winningRev$$1, deleted));
    };
    txn.onabort = idbError(callback);
    txn.oncomplete = function () {
      callback();
    };
  };


  api._getLocal = function (id, callback) {
    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var tx = txnResult.txn;
    var req = tx.objectStore(LOCAL_STORE).get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        delete doc['_doc_id_rev']; // for backwards compat
        callback(null, doc);
      }
    };
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    if (!oldRev) {
      doc._rev = '0-1';
    } else {
      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }

    var tx = opts.ctx;
    var ret;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.onerror = idbError(callback);
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }

    var oStore = tx.objectStore(LOCAL_STORE);
    var req;
    if (oldRev) {
      req = oStore.get(id);
      req.onsuccess = function (e) {
        var oldDoc = e.target.result;
        if (!oldDoc || oldDoc._rev !== oldRev) {
          callback(createError(REV_CONFLICT));
        } else { // update
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };
    } else { // new doc
      req = oStore.add(doc);
      req.onerror = function (e) {
        // constraint error, already exists
        callback(createError(REV_CONFLICT));
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
      };
      req.onsuccess = function () {
        ret = {ok: true, id: doc._id, rev: doc._rev};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      };
    }
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var tx = opts.ctx;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }
    var ret;
    var id = doc._id;
    var oStore = tx.objectStore(LOCAL_STORE);
    var req = oStore.get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var oldDoc = e.target.result;
      if (!oldDoc || oldDoc._rev !== doc._rev) {
        callback(createError(MISSING_DOC));
      } else {
        oStore.delete(id);
        ret = {ok: true, id: id, rev: '0-0'};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      }
    };
  };

  api._destroy = function (opts, callback) {
    changesHandler.removeAllListeners(dbName);

    //Close open request for "dbName" database to fix ie delay.
    var openReq = openReqList.get(dbName);
    if (openReq && openReq.result) {
      openReq.result.close();
      cachedDBs.delete(dbName);
    }
    var req = indexedDB.deleteDatabase(dbName);

    req.onsuccess = function () {
      //Remove open request from the list.
      openReqList.delete(dbName);
      if (hasLocalStorage() && (dbName in localStorage)) {
        delete localStorage[dbName];
      }
      callback(null, { 'ok': true });
    };

    req.onerror = idbError(callback);
  };

  var cached = cachedDBs.get(dbName);

  if (cached) {
    idb = cached.idb;
    api._meta = cached.global;
    return nextTick(function () {
      callback(null, api);
    });
  }

  var req = indexedDB.open(dbName, ADAPTER_VERSION);
  openReqList.set(dbName, req);

  req.onupgradeneeded = function (e) {
    var db = e.target.result;
    if (e.oldVersion < 1) {
      return createSchema(db); // new db, initial schema
    }
    // do migrations

    var txn = e.currentTarget.transaction;
    // these migrations have to be done in this function, before
    // control is returned to the event loop, because IndexedDB

    if (e.oldVersion < 3) {
      createLocalStoreSchema(db); // v2 -> v3
    }
    if (e.oldVersion < 4) {
      addAttachAndSeqStore(db); // v3 -> v4
    }

    var migrations = [
      addDeletedOrLocalIndex, // v1 -> v2
      migrateLocalStore,      // v2 -> v3
      migrateAttsAndSeqs,     // v3 -> v4
      migrateMetadata         // v4 -> v5
    ];

    var i = e.oldVersion;

    function next() {
      var migration = migrations[i - 1];
      i++;
      if (migration) {
        migration(txn, next);
      }
    }

    next();
  };

  req.onsuccess = function (e) {

    idb = e.target.result;

    idb.onversionchange = function () {
      idb.close();
      cachedDBs.delete(dbName);
    };

    idb.onabort = function (e) {
      guardedConsole('error', 'Database has a global failure', e.target.error);
      idb.close();
      cachedDBs.delete(dbName);
    };

    // Do a few setup operations (in parallel as much as possible):
    // 1. Fetch meta doc
    // 2. Check blob support
    // 3. Calculate docCount
    // 4. Generate an instanceId if necessary
    // 5. Store docCount and instanceId on meta doc

    var txn = idb.transaction([
      META_STORE,
      DETECT_BLOB_SUPPORT_STORE,
      DOC_STORE
    ], 'readwrite');

    var storedMetaDoc = false;
    var metaDoc;
    var docCount;
    var blobSupport;
    var instanceId;

    function completeSetup() {
      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
        return;
      }
      api._meta = {
        name: dbName,
        instanceId: instanceId,
        blobSupport: blobSupport
      };

      cachedDBs.set(dbName, {
        idb: idb,
        global: api._meta
      });
      callback(null, api);
    }

    function storeMetaDocIfReady() {
      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
        return;
      }
      var instanceKey = dbName + '_id';
      if (instanceKey in metaDoc) {
        instanceId = metaDoc[instanceKey];
      } else {
        metaDoc[instanceKey] = instanceId = uuid();
      }
      metaDoc.docCount = docCount;
      txn.objectStore(META_STORE).put(metaDoc);
    }

    //
    // fetch or generate the instanceId
    //
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result || { id: META_STORE };
      storeMetaDocIfReady();
    };

    //
    // countDocs
    //
    countDocs(txn, function (count) {
      docCount = count;
      storeMetaDocIfReady();
    });

    //
    // check blob support
    //
    if (!blobSupportPromise) {
      // make sure blob support is only checked once
      blobSupportPromise = checkBlobSupport(txn);
    }

    blobSupportPromise.then(function (val) {
      blobSupport = val;
      completeSetup();
    });

    // only when the metadata put transaction has completed,
    // consider the setup done
    txn.oncomplete = function () {
      storedMetaDoc = true;
      completeSetup();
    };
    txn.onabort = idbError(callback);
  };

  req.onerror = function () {
    var msg = 'Failed to open indexedDB, are you in private browsing mode?';
    guardedConsole('error', msg);
    callback(createError(IDB_ERROR, msg));
  };
}

IdbPouch.valid = function () {
  // Following #7085 buggy idb versions (typically Safari < 10.1) are
  // considered valid.

  // On Firefox SecurityError is thrown while referencing indexedDB if cookies
  // are not allowed. `typeof indexedDB` also triggers the error.
  try {
    // some outdated implementations of IDB that appear on Samsung
    // and HTC Android devices <4.4 are missing IDBKeyRange
    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
  } catch (e) {
    return false;
  }
};

function IDBPouch (PouchDB) {
  PouchDB.adapter('idb', IdbPouch, true);
}

// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool
// but much smaller in code size. limits the number of concurrent promises that are executed


function pool(promiseFactories, limit) {
  return new Promise(function (resolve, reject) {
    var running = 0;
    var current = 0;
    var done = 0;
    var len = promiseFactories.length;
    var err;

    function runNext() {
      running++;
      promiseFactories[current++]().then(onSuccess, onError);
    }

    function doNext() {
      if (++done === len) {
        /* istanbul ignore if */
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      } else {
        runNextBatch();
      }
    }

    function onSuccess() {
      running--;
      doNext();
    }

    /* istanbul ignore next */
    function onError(thisErr) {
      running--;
      err = err || thisErr;
      doNext();
    }

    function runNextBatch() {
      while (running < limit && current < len) {
        runNext();
      }
    }

    runNextBatch();
  });
}

var CHANGES_BATCH_SIZE = 25;
var MAX_SIMULTANEOUS_REVS = 50;
var CHANGES_TIMEOUT_BUFFER = 5000;
var DEFAULT_HEARTBEAT = 10000;

var supportsBulkGetMap = {};

function readAttachmentsAsBlobOrBuffer(row) {
  var doc = row.doc || row.ok;
  var atts = doc._attachments;
  if (!atts) {
    return;
  }
  Object.keys(atts).forEach(function (filename) {
    var att = atts[filename];
    att.data = b64ToBluffer(att.data, att.content_type);
  });
}

function encodeDocId(id) {
  if (/^_design/.test(id)) {
    return '_design/' + encodeURIComponent(id.slice(8));
  }
  if (/^_local/.test(id)) {
    return '_local/' + encodeURIComponent(id.slice(7));
  }
  return encodeURIComponent(id);
}

function preprocessAttachments$1(doc) {
  if (!doc._attachments || !Object.keys(doc._attachments)) {
    return Promise.resolve();
  }

  return Promise.all(Object.keys(doc._attachments).map(function (key) {
    var attachment = doc._attachments[key];
    if (attachment.data && typeof attachment.data !== 'string') {
      return new Promise(function (resolve) {
        blobToBase64(attachment.data, resolve);
      }).then(function (b64) {
        attachment.data = b64;
      });
    }
  }));
}

function hasUrlPrefix(opts) {
  if (!opts.prefix) {
    return false;
  }
  var protocol = parseUri(opts.prefix).protocol;
  return protocol === 'http' || protocol === 'https';
}

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
function getHost(name, opts) {
  // encode db name if opts.prefix is a url (#5574)
  if (hasUrlPrefix(opts)) {
    var dbName = opts.name.substr(opts.prefix.length);
    // Ensure prefix has a trailing slash
    var prefix = opts.prefix.replace(/\/?$/, '/');
    name = prefix + encodeURIComponent(dbName);
  }

  var uri = parseUri(name);
  if (uri.user || uri.password) {
    uri.auth = {username: uri.user, password: uri.password};
  }

  // Split the path part of the URI into parts using '/' as the delimiter
  // after removing any leading '/' and any trailing '/'
  var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

  uri.db = parts.pop();
  // Prevent double encoding of URI component
  if (uri.db.indexOf('%') === -1) {
    uri.db = encodeURIComponent(uri.db);
  }

  uri.path = parts.join('/');

  return uri;
}

// Generate a URL with the host data given by opts and the given path
function genDBUrl(opts, path) {
  return genUrl(opts, opts.db + '/' + path);
}

// Generate a URL with the host data given by opts and the given path
function genUrl(opts, path) {
  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  var pathDel = !opts.path ? '' : '/';

  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  return opts.protocol + '://' + opts.host +
         (opts.port ? (':' + opts.port) : '') +
         '/' + opts.path + pathDel + path;
}

function paramsToStr(params) {
  return '?' + Object.keys(params).map(function (k) {
    return k + '=' + encodeURIComponent(params[k]);
  }).join('&');
}

function shouldCacheBust(opts) {
  var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?
      navigator.userAgent.toLowerCase() : '';
  var isIE = ua.indexOf('msie') !== -1;
  var isTrident = ua.indexOf('trident') !== -1;
  var isEdge = ua.indexOf('edge') !== -1;
  var isGET = !('method' in opts) || opts.method === 'GET';
  return (isIE || isTrident || isEdge) && isGET;
}

// Implements the PouchDB API for dealing with CouchDB instances over HTTP
function HttpPouch(opts, callback) {

  // The functions that will be publicly available for HttpPouch
  var api = this;

  var host = getHost(opts.name, opts);
  var dbUrl = genDBUrl(host, '');

  opts = clone(opts);

  var ourFetch = function (url, options) {

    options = options || {};
    options.headers = options.headers || new h();

    if (opts.auth || host.auth) {
      var nAuth = opts.auth || host.auth;
      var str = nAuth.username + ':' + nAuth.password;
      var token = thisBtoa(unescape(encodeURIComponent(str)));
      options.headers.set('Authorization', 'Basic ' + token);
    }

    var headers = opts.headers || {};
    Object.keys(headers).forEach(function (key) {
      options.headers.append(key, headers[key]);
    });

    /* istanbul ignore if */
    if (shouldCacheBust(options)) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();
    }

    var fetchFun = opts.fetch || f$1;
    return fetchFun(url, options);
  };

  function adapterFun$$1(name, fun) {
    return adapterFun(name, getArguments(function (args) {
      setup().then(function () {
        return fun.apply(this, args);
      }).catch(function (e) {
        var callback = args.pop();
        callback(e);
      });
    })).bind(api);
  }

  function fetchJSON(url, options, callback) {

    var result = {};

    options = options || {};
    options.headers = options.headers || new h();

    if (!options.headers.get('Content-Type')) {
      options.headers.set('Content-Type', 'application/json');
    }
    if (!options.headers.get('Accept')) {
      options.headers.set('Accept', 'application/json');
    }

    return ourFetch(url, options).then(function (response) {
      result.ok = response.ok;
      result.status = response.status;
      return response.json();
    }).then(function (json) {
      result.data = json;
      if (!result.ok) {
        result.data.status = result.status;
        var err = generateErrorFromResponse(result.data);
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }

      if (Array.isArray(result.data)) {
        result.data = result.data.map(function (v) {
          if (v.error || v.missing) {
            return generateErrorFromResponse(v);
          } else {
            return v;
          }
        });
      }

      if (callback) {
        callback(null, result.data);
      } else {
        return result;
      }
    });
  }

  var setupPromise;

  function setup() {
    if (opts.skip_setup) {
      return Promise.resolve();
    }

    // If there is a setup in process or previous successful setup
    // done then we will use that
    // If previous setups have been rejected we will try again
    if (setupPromise) {
      return setupPromise;
    }

    setupPromise = fetchJSON(dbUrl).catch(function (err) {
      if (err && err.status && err.status === 404) {
        // Doesnt exist, create it
        explainError(404, 'PouchDB is just detecting if the remote exists.');
        return fetchJSON(dbUrl, {method: 'PUT'});
      } else {
        return Promise.reject(err);
      }
    }).catch(function (err) {
      // If we try to create a database that already exists, skipped in
      // istanbul since its catching a race condition.
      /* istanbul ignore if */
      if (err && err.status && err.status === 412) {
        return true;
      }
      return Promise.reject(err);
    });

    setupPromise.catch(function () {
      setupPromise = null;
    });

    return setupPromise;
  }

  nextTick(function () {
    callback(null, api);
  });

  api._remote = true;

  /* istanbul ignore next */
  api.type = function () {
    return 'http';
  };

  api.id = adapterFun$$1('id', function (callback) {
    ourFetch(genUrl(host, '')).then(function (response) {
      return response.json();
    }).then(function (result) {
      var uuid$$1 = (result && result.uuid) ?
          (result.uuid + host.db) : genDBUrl(host, '');
      callback(null, uuid$$1);
    }).catch(function (err) {
      callback(err);
    });
  });

  // Sends a POST request to the host calling the couchdb _compact function
  //    version: The version of CouchDB it is running
  api.compact = adapterFun$$1('compact', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {
      function ping() {
        api.info(function (err, res) {
          // CouchDB may send a "compact_running:true" if it's
          // already compacting. PouchDB Server doesn't.
          /* istanbul ignore else */
          if (res && !res.compact_running) {
            callback(null, {ok: true});
          } else {
            setTimeout(ping, opts.interval || 200);
          }
        });
      }
      // Ping the http if it's finished compaction
      ping();
    });
  });

  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
    var self = this;

    function doBulkGet(cb) {
      var params = {};
      if (opts.revs) {
        params.revs = true;
      }
      if (opts.attachments) {
        /* istanbul ignore next */
        params.attachments = true;
      }
      if (opts.latest) {
        params.latest = true;
      }
      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {
        method: 'POST',
        body: JSON.stringify({ docs: opts.docs})
      }).then(function (result) {
        if (opts.attachments && opts.binary) {
          result.data.results.forEach(function (res) {
            res.docs.forEach(readAttachmentsAsBlobOrBuffer);
          });
        }
        cb(null, result.data);
      }).catch(cb);
    }

    /* istanbul ignore next */
    function doBulkGetShim() {
      // avoid "url too long error" by splitting up into multiple requests
      var batchSize = MAX_SIMULTANEOUS_REVS;
      var numBatches = Math.ceil(opts.docs.length / batchSize);
      var numDone = 0;
      var results = new Array(numBatches);

      function onResult(batchNum) {
        return function (err, res) {
          // err is impossible because shim returns a list of errs in that case
          results[batchNum] = res.results;
          if (++numDone === numBatches) {
            callback(null, {results: flatten(results)});
          }
        };
      }

      for (var i = 0; i < numBatches; i++) {
        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);
        subOpts.docs = opts.docs.slice(i * batchSize,
          Math.min(opts.docs.length, (i + 1) * batchSize));
        bulkGet(self, subOpts, onResult(i));
      }
    }

    // mark the whole database as either supporting or not supporting _bulk_get
    var dbUrl = genUrl(host, '');
    var supportsBulkGet = supportsBulkGetMap[dbUrl];

    /* istanbul ignore next */
    if (typeof supportsBulkGet !== 'boolean') {
      // check if this database supports _bulk_get
      doBulkGet(function (err, res) {
        if (err) {
          supportsBulkGetMap[dbUrl] = false;
          explainError(
            err.status,
            'PouchDB is just detecting if the remote ' +
            'supports the _bulk_get API.'
          );
          doBulkGetShim();
        } else {
          supportsBulkGetMap[dbUrl] = true;
          callback(null, res);
        }
      });
    } else if (supportsBulkGet) {
      doBulkGet(callback);
    } else {
      doBulkGetShim();
    }
  });

  // Calls GET on the host, which gets back a JSON string containing
  //    couchdb: A welcome string
  //    version: The version of CouchDB it is running
  api._info = function (callback) {
    setup().then(function () {
      return ourFetch(genDBUrl(host, ''));
    }).then(function (response) {
      return response.json();
    }).then(function (info) {
      info.host = genDBUrl(host, '');
      callback(null, info);
    }).catch(callback);
  };

  api.fetch = function (path, options) {
    return setup().then(function () {
      return ourFetch(genDBUrl(host, path), options);
    });
  };

  // Get the document with the given id from the database given by host.
  // The id could be solely the _id in the database, or it may be a
  // _design/ID or _local/ID path
  api.get = adapterFun$$1('get', function (id, opts, callback) {
    // If no options were given, set the callback to the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};

    if (opts.revs) {
      params.revs = true;
    }

    if (opts.revs_info) {
      params.revs_info = true;
    }

    if (opts.latest) {
      params.latest = true;
    }

    if (opts.open_revs) {
      if (opts.open_revs !== "all") {
        opts.open_revs = JSON.stringify(opts.open_revs);
      }
      params.open_revs = opts.open_revs;
    }

    if (opts.rev) {
      params.rev = opts.rev;
    }

    if (opts.conflicts) {
      params.conflicts = opts.conflicts;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = opts.update_seq;
    }

    id = encodeDocId(id);

    function fetchAttachments(doc) {
      var atts = doc._attachments;
      var filenames = atts && Object.keys(atts);
      if (!atts || !filenames.length) {
        return;
      }
      // we fetch these manually in separate XHRs, because
      // Sync Gateway would normally send it back as multipart/mixed,
      // which we cannot parse. Also, this is more efficient than
      // receiving attachments as base64-encoded strings.
      function fetchData(filename) {
        var att = atts[filename];
        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
            '?rev=' + doc._rev;
        return ourFetch(genDBUrl(host, path)).then(function (response) {
          if (typeof process !== 'undefined' && !process.browser) {
            return response.buffer();
          } else {
            /* istanbul ignore next */
            return response.blob();
          }
        }).then(function (blob) {
          if (opts.binary) {
            // TODO: Can we remove this?
            if (typeof process !== 'undefined' && !process.browser) {
              blob.type = att.content_type;
            }
            return blob;
          }
          return new Promise(function (resolve) {
            blobToBase64(blob, resolve);
          });
        }).then(function (data) {
          delete att.stub;
          delete att.length;
          att.data = data;
        });
      }

      var promiseFactories = filenames.map(function (filename) {
        return function () {
          return fetchData(filename);
        };
      });

      // This limits the number of parallel xhr requests to 5 any time
      // to avoid issues with maximum browser request limits
      return pool(promiseFactories, 5);
    }

    function fetchAllAttachments(docOrDocs) {
      if (Array.isArray(docOrDocs)) {
        return Promise.all(docOrDocs.map(function (doc) {
          if (doc.ok) {
            return fetchAttachments(doc.ok);
          }
        }));
      }
      return fetchAttachments(docOrDocs);
    }

    var url = genDBUrl(host, id + paramsToStr(params));
    fetchJSON(url).then(function (res) {
      return Promise.resolve().then(function () {
        if (opts.attachments) {
          return fetchAllAttachments(res.data);
        }
      }).then(function () {
        callback(null, res.data);
      });
    }).catch(function (e) {
      e.docId = id;
      callback(e);
    });
  });


  // Delete the document given by doc from the database given by host.
  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {
    var doc;
    if (typeof optsOrRev === 'string') {
      // id, rev, opts, callback style
      doc = {
        _id: docOrId,
        _rev: optsOrRev
      };
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
    } else {
      // doc, opts, callback style
      doc = docOrId;
      if (typeof optsOrRev === 'function') {
        cb = optsOrRev;
        opts = {};
      } else {
        cb = opts;
        opts = optsOrRev;
      }
    }

    var rev = (doc._rev || opts.rev);
    var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev;

    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);
  });

  function encodeAttachmentId(attachmentId) {
    return attachmentId.split("/").map(encodeURIComponent).join("/");
  }

  // Get the attachment
  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,
                                                            opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var params = opts.rev ? ('?rev=' + opts.rev) : '';
    var url = genDBUrl(host, encodeDocId(docId)) + '/' +
        encodeAttachmentId(attachmentId) + params;
    var contentType;
    ourFetch(url, {method: 'GET'}).then(function (response) {
      contentType = response.headers.get('content-type');
      if (!response.ok) {
        throw response;
      } else {
        if (typeof process !== 'undefined' && !process.browser) {
          return response.buffer();
        } else {
          /* istanbul ignore next */
          return response.blob();
        }
      }
    }).then(function (blob) {
      // TODO: also remove
      if (typeof process !== 'undefined' && !process.browser) {
        blob.type = contentType;
      }
      callback(null, blob);
    }).catch(function (err) {
      callback(err);
    });
  });

  // Remove the attachment given by the id and rev
  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,
                                                                   attachmentId,
                                                                   rev,
                                                                   callback) {
    var url = genDBUrl(host, encodeDocId(docId) + '/' +
                       encodeAttachmentId(attachmentId)) + '?rev=' + rev;
    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);
  });

  // Add the attachment given by blob and its contentType property
  // to the document with the given id, the revision given by rev, and
  // add it to the database given by host.
  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,
                                                            rev, blob,
                                                            type, callback) {
    if (typeof type === 'function') {
      callback = type;
      type = blob;
      blob = rev;
      rev = null;
    }
    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
    var url = genDBUrl(host, id);
    if (rev) {
      url += '?rev=' + rev;
    }

    if (typeof blob === 'string') {
      // input is assumed to be a base64 string
      var binary;
      try {
        binary = thisAtob(blob);
      } catch (err) {
        return callback(createError(BAD_ARG,
                        'Attachment is not a valid base64 string'));
      }
      blob = binary ? binStringToBluffer(binary, type) : '';
    }

    // Add the attachment
    fetchJSON(url, {
      headers: new h({'Content-Type': type}),
      method: 'PUT',
      body: blob
    }, callback).catch(callback);
  });

  // Update/create multiple documents given by req in the database
  // given by host.
  api._bulkDocs = function (req, opts, callback) {
    // If new_edits=false then it prevents the database from creating
    // new revision numbers for the documents. Instead it just uses
    // the old ones. This is used in database replication.
    req.new_edits = opts.new_edits;

    setup().then(function () {
      return Promise.all(req.docs.map(preprocessAttachments$1));
    }).then(function () {
      // Update/create the documents
      return fetchJSON(genDBUrl(host, '_bulk_docs'), {
        method: 'POST',
        body: JSON.stringify(req)
      }, callback);
    }).catch(callback);
  };


  // Update/create document
  api._put = function (doc, opts, callback) {
    setup().then(function () {
      return preprocessAttachments$1(doc);
    }).then(function () {
      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {
        method: 'PUT',
        body: JSON.stringify(doc)
      });
    }).then(function (result) {
      callback(null, result.data);
    }).catch(function (err) {
      err.docId = doc && doc._id;
      callback(err);
    });
  };


  // Get a listing of the documents in the database given
  // by host and ordered by increasing id.
  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};
    var body;
    var method = 'GET';

    if (opts.conflicts) {
      params.conflicts = true;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if (opts.include_docs) {
      params.include_docs = true;
    }

    // added in CouchDB 1.6.0
    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.key) {
      params.key = JSON.stringify(opts.key);
    }

    if (opts.start_key) {
      opts.startkey = opts.start_key;
    }

    if (opts.startkey) {
      params.startkey = JSON.stringify(opts.startkey);
    }

    if (opts.end_key) {
      opts.endkey = opts.end_key;
    }

    if (opts.endkey) {
      params.endkey = JSON.stringify(opts.endkey);
    }

    if (typeof opts.inclusive_end !== 'undefined') {
      params.inclusive_end = !!opts.inclusive_end;
    }

    if (typeof opts.limit !== 'undefined') {
      params.limit = opts.limit;
    }

    if (typeof opts.skip !== 'undefined') {
      params.skip = opts.skip;
    }

    var paramStr = paramsToStr(params);

    if (typeof opts.keys !== 'undefined') {
      method = 'POST';
      body = {keys: opts.keys};
    }

    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {
       method: method,
      body: JSON.stringify(body)
    }).then(function (result) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);
      }
      callback(null, result.data);
    }).catch(callback);
  });

  // Get a list of changes made to documents in the database given by host.
  // TODO According to the README, there should be two other methods here,
  // api.changes.addListener and api.changes.removeListener.
  api._changes = function (opts) {

    // We internally page the results of a changes request, this means
    // if there is a large set of changes to be returned we can start
    // processing them quicker instead of waiting on the entire
    // set of changes to return and attempting to process them at once
    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

    opts = clone(opts);

    if (opts.continuous && !('heartbeat' in opts)) {
      opts.heartbeat = DEFAULT_HEARTBEAT;
    }

    var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;

    // ensure CHANGES_TIMEOUT_BUFFER applies
    if ('timeout' in opts && opts.timeout &&
      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
    }

    /* istanbul ignore if */
    if ('heartbeat' in opts && opts.heartbeat &&
       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
    }

    var params = {};
    if ('timeout' in opts && opts.timeout) {
      params.timeout = opts.timeout;
    }

    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
    var leftToFetch = limit;

    if (opts.style) {
      params.style = opts.style;
    }

    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
      params.include_docs = true;
    }

    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.continuous) {
      params.feed = 'longpoll';
    }

    if (opts.seq_interval) {
      params.seq_interval = opts.seq_interval;
    }

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }
    
    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if ('heartbeat' in opts) {
      // If the heartbeat value is false, it disables the default heartbeat
      if (opts.heartbeat) {
        params.heartbeat = opts.heartbeat;
      }
    }

    if (opts.filter && typeof opts.filter === 'string') {
      params.filter = opts.filter;
    }

    if (opts.view && typeof opts.view === 'string') {
      params.filter = '_view';
      params.view = opts.view;
    }

    // If opts.query_params exists, pass it through to the changes request.
    // These parameters may be used by the filter on the source database.
    if (opts.query_params && typeof opts.query_params === 'object') {
      for (var param_name in opts.query_params) {
        /* istanbul ignore else */
        if (opts.query_params.hasOwnProperty(param_name)) {
          params[param_name] = opts.query_params[param_name];
        }
      }
    }

    var method = 'GET';
    var body;

    if (opts.doc_ids) {
      // set this automagically for the user; it's annoying that couchdb
      // requires both a "filter" and a "doc_ids" param.
      params.filter = '_doc_ids';
      method = 'POST';
      body = {doc_ids: opts.doc_ids };
    }
    /* istanbul ignore next */
    else if (opts.selector) {
      // set this automagically for the user, similar to above
      params.filter = '_selector';
      method = 'POST';
      body = {selector: opts.selector };
    }

    var controller = new a();
    var lastFetchedSeq;

    // Get all the changes starting wtih the one immediately after the
    // sequence number given by since.
    var fetchData = function (since, callback) {
      if (opts.aborted) {
        return;
      }
      params.since = since;
      // "since" can be any kind of json object in Cloudant/CouchDB 2.x
      /* istanbul ignore next */
      if (typeof params.since === "object") {
        params.since = JSON.stringify(params.since);
      }

      if (opts.descending) {
        if (limit) {
          params.limit = leftToFetch;
        }
      } else {
        params.limit = (!limit || leftToFetch > batchSize) ?
          batchSize : leftToFetch;
      }

      // Set the options for the ajax call
      var url = genDBUrl(host, '_changes' + paramsToStr(params));
      var fetchOpts = {
        signal: controller.signal,
        method: method,
        body: JSON.stringify(body)
      };
      lastFetchedSeq = since;

      /* istanbul ignore if */
      if (opts.aborted) {
        return;
      }

      // Get the changes
      setup().then(function () {
        return fetchJSON(url, fetchOpts, callback);
      }).catch(callback);
    };

    // If opts.since exists, get all the changes from the sequence
    // number given by opts.since. Otherwise, get all the changes
    // from the sequence number 0.
    var results = {results: []};

    var fetched = function (err, res) {
      if (opts.aborted) {
        return;
      }
      var raw_results_length = 0;
      // If the result of the ajax call (res) contains changes (res.results)
      if (res && res.results) {
        raw_results_length = res.results.length;
        results.last_seq = res.last_seq;
        var pending = null;
        var lastSeq = null;
        // Attach 'pending' property if server supports it (CouchDB 2.0+)
        /* istanbul ignore if */
        if (typeof res.pending === 'number') {
          pending = res.pending;
        }
        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {
          lastSeq = results.last_seq;
        }
        // For each change
        var req = {};
        req.query = opts.query_params;
        res.results = res.results.filter(function (c) {
          leftToFetch--;
          var ret = filterChange(opts)(c);
          if (ret) {
            if (opts.include_docs && opts.attachments && opts.binary) {
              readAttachmentsAsBlobOrBuffer(c);
            }
            if (opts.return_docs) {
              results.results.push(c);
            }
            opts.onChange(c, pending, lastSeq);
          }
          return ret;
        });
      } else if (err) {
        // In case of an error, stop listening for changes and call
        // opts.complete
        opts.aborted = true;
        opts.complete(err);
        return;
      }

      // The changes feed may have timed out with no results
      // if so reuse last update sequence
      if (res && res.last_seq) {
        lastFetchedSeq = res.last_seq;
      }

      var finished = (limit && leftToFetch <= 0) ||
        (res && raw_results_length < batchSize) ||
        (opts.descending);

      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
        // Queue a call to fetch again with the newest sequence number
        nextTick(function () { fetchData(lastFetchedSeq, fetched); });
      } else {
        // We're done, call the callback
        opts.complete(null, results);
      }
    };

    fetchData(opts.since || 0, fetched);

    // Return a method to cancel this method from processing any more
    return {
      cancel: function () {
        opts.aborted = true;
        controller.abort();
      }
    };
  };

  // Given a set of document/revision IDs (given by req), tets the subset of
  // those that do NOT correspond to revisions stored in the database.
  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    // Get the missing document/revision IDs
    fetchJSON(genDBUrl(host, '_revs_diff'), {
      method: 'POST',
      body: JSON.stringify(req)
    }, callback).catch(callback);
  });

  api._close = function (callback) {
    callback();
  };

  api._destroy = function (options, callback) {
    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {
      callback(null, json);
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status === 404) {
        callback(null, {ok: true});
      } else {
        callback(err);
      }
    });
  };
}

// HttpPouch is a valid adapter.
HttpPouch.valid = function () {
  return true;
};

function HttpPouch$1 (PouchDB) {
  PouchDB.adapter('http', HttpPouch, false);
  PouchDB.adapter('https', HttpPouch, false);
}

function QueryParseError(message) {
  this.status = 400;
  this.name = 'query_parse_error';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, QueryParseError);
  } catch (e) {}
}

inherits(QueryParseError, Error);

function NotFoundError(message) {
  this.status = 404;
  this.name = 'not_found';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, NotFoundError);
  } catch (e) {}
}

inherits(NotFoundError, Error);

function BuiltInError(message) {
  this.status = 500;
  this.name = 'invalid_value';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, BuiltInError);
  } catch (e) {}
}

inherits(BuiltInError, Error);

function promisedCallback(promise, callback) {
  if (callback) {
    promise.then(function (res) {
      nextTick(function () {
        callback(null, res);
      });
    }, function (reason) {
      nextTick(function () {
        callback(reason);
      });
    });
  }
  return promise;
}

function callbackify(fun) {
  return getArguments(function (args) {
    var cb = args.pop();
    var promise = fun.apply(this, args);
    if (typeof cb === 'function') {
      promisedCallback(promise, cb);
    }
    return promise;
  });
}

// Promise finally util similar to Q.finally
function fin(promise, finalPromiseFactory) {
  return promise.then(function (res) {
    return finalPromiseFactory().then(function () {
      return res;
    });
  }, function (reason) {
    return finalPromiseFactory().then(function () {
      throw reason;
    });
  });
}

function sequentialize(queue, promiseFactory) {
  return function () {
    var args = arguments;
    var that = this;
    return queue.add(function () {
      return promiseFactory.apply(that, args);
    });
  };
}

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
function uniq(arr) {
  var theSet = new ExportedSet(arr);
  var result = new Array(theSet.size);
  var index = -1;
  theSet.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

function mapToKeysArray(map) {
  var result = new Array(map.size);
  var index = -1;
  map.forEach(function (value, key) {
    result[++index] = key;
  });
  return result;
}

function createBuiltInError(name) {
  var message = 'builtin ' + name +
    ' function requires map values to be numbers' +
    ' or number arrays';
  return new BuiltInError(message);
}

function sum(values) {
  var result = 0;
  for (var i = 0, len = values.length; i < len; i++) {
    var num = values[i];
    if (typeof num !== 'number') {
      if (Array.isArray(num)) {
        // lists of numbers are also allowed, sum them separately
        result = typeof result === 'number' ? [result] : result;
        for (var j = 0, jLen = num.length; j < jLen; j++) {
          var jNum = num[j];
          if (typeof jNum !== 'number') {
            throw createBuiltInError('_sum');
          } else if (typeof result[j] === 'undefined') {
            result.push(jNum);
          } else {
            result[j] += jNum;
          }
        }
      } else { // not array/number
        throw createBuiltInError('_sum');
      }
    } else if (typeof result === 'number') {
      result += num;
    } else { // add number to array
      result[0] += num;
    }
  }
  return result;
}

var log = guardedConsole.bind(null, 'log');
var isArray = Array.isArray;
var toJSON = JSON.parse;

function evalFunctionWithEval(func, emit) {
  return scopeEval(
    "return (" + func.replace(/;\s*$/, "") + ");",
    {
      emit: emit,
      sum: sum,
      log: log,
      isArray: isArray,
      toJSON: toJSON
    }
  );
}

/*
 * Simple task queue to sequentialize actions. Assumes
 * callbacks will eventually fire (once).
 */


function TaskQueue$1() {
  this.promise = new Promise(function (fulfill) {fulfill(); });
}
TaskQueue$1.prototype.add = function (promiseFactory) {
  this.promise = this.promise.catch(function () {
    // just recover
  }).then(function () {
    return promiseFactory();
  });
  return this.promise;
};
TaskQueue$1.prototype.finish = function () {
  return this.promise;
};

function stringify(input) {
  if (!input) {
    return 'undefined'; // backwards compat for empty reduce
  }
  // for backwards compat with mapreduce, functions/strings are stringified
  // as-is. everything else is JSON-stringified.
  switch (typeof input) {
    case 'function':
      // e.g. a mapreduce map
      return input.toString();
    case 'string':
      // e.g. a mapreduce built-in _reduce function
      return input.toString();
    default:
      // e.g. a JSON object in the case of mango queries
      return JSON.stringify(input);
  }
}

/* create a string signature for a view so we can cache it and uniq it */
function createViewSignature(mapFun, reduceFun) {
  // the "undefined" part is for backwards compatibility
  return stringify(mapFun) + stringify(reduceFun) + 'undefined';
}

function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
  var viewSignature = createViewSignature(mapFun, reduceFun);

  var cachedViews;
  if (!temporary) {
    // cache this to ensure we don't try to update the same view twice
    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
    if (cachedViews[viewSignature]) {
      return cachedViews[viewSignature];
    }
  }

  var promiseForView = sourceDB.info().then(function (info) {

    var depDbName = info.db_name + '-mrview-' +
      (temporary ? 'temp' : stringMd5(viewSignature));

    // save the view name in the source db so it can be cleaned up if necessary
    // (e.g. when the _design doc is deleted, remove all associated view data)
    function diffFunction(doc) {
      doc.views = doc.views || {};
      var fullViewName = viewName;
      if (fullViewName.indexOf('/') === -1) {
        fullViewName = viewName + '/' + viewName;
      }
      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
      /* istanbul ignore if */
      if (depDbs[depDbName]) {
        return; // no update necessary
      }
      depDbs[depDbName] = true;
      return doc;
    }
    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
        var db = res.db;
        db.auto_compaction = true;
        var view = {
          name: depDbName,
          db: db,
          sourceDB: sourceDB,
          adapter: sourceDB.adapter,
          mapFun: mapFun,
          reduceFun: reduceFun
        };
        return view.db.get('_local/lastSeq').catch(function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
        }).then(function (lastSeqDoc) {
          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
          if (cachedViews) {
            view.db.once('destroyed', function () {
              delete cachedViews[viewSignature];
            });
          }
          return view;
        });
      });
    });
  });

  if (cachedViews) {
    cachedViews[viewSignature] = promiseForView;
  }
  return promiseForView;
}

var persistentQueues = {};
var tempViewQueue = new TaskQueue$1();
var CHANGES_BATCH_SIZE$1 = 50;

function parseViewName(name) {
  // can be either 'ddocname/viewname' or just 'viewname'
  // (where the ddoc name is the same)
  return name.indexOf('/') === -1 ? [name, name] : name.split('/');
}

function isGenOne(changes) {
  // only return true if the current change is 1-
  // and there are no other leafs
  return changes.length === 1 && /^1-/.test(changes[0].rev);
}

function emitError(db, e) {
  try {
    db.emit('error', e);
  } catch (err) {
    guardedConsole('error',
      'The user\'s map/reduce function threw an uncaught error.\n' +
      'You can debug this error by doing:\n' +
      'myDatabase.on(\'error\', function (err) { debugger; });\n' +
      'Please double-check your map/reduce function.');
    guardedConsole('error', e);
  }
}

/**
 * Returns an "abstract" mapreduce object of the form:
 *
 *   {
 *     query: queryFun,
 *     viewCleanup: viewCleanupFun
 *   }
 *
 * Arguments are:
 *
 * localDoc: string
 *   This is for the local doc that gets saved in order to track the
 *   "dependent" DBs and clean them up for viewCleanup. It should be
 *   unique, so that indexer plugins don't collide with each other.
 * mapper: function (mapFunDef, emit)
 *   Returns a map function based on the mapFunDef, which in the case of
 *   normal map/reduce is just the de-stringified function, but may be
 *   something else, such as an object in the case of pouchdb-find.
 * reducer: function (reduceFunDef)
 *   Ditto, but for reducing. Modules don't have to support reducing
 *   (e.g. pouchdb-find).
 * ddocValidator: function (ddoc, viewName)
 *   Throws an error if the ddoc or viewName is not valid.
 *   This could be a way to communicate to the user that the configuration for the
 *   indexer is invalid.
 */
function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {

  function tryMap(db, fun, doc) {
    // emit an event if there was an error thrown by a map function.
    // putting try/catches in a single function also avoids deoptimizations.
    try {
      fun(doc);
    } catch (e) {
      emitError(db, e);
    }
  }

  function tryReduce(db, fun, keys, values, rereduce) {
    // same as above, but returning the result or an error. there are two separate
    // functions to avoid extra memory allocations since the tryCode() case is used
    // for custom map functions (common) vs this function, which is only used for
    // custom reduce functions (rare)
    try {
      return {output : fun(keys, values, rereduce)};
    } catch (e) {
      emitError(db, e);
      return {error: e};
    }
  }

  function sortByKeyThenValue(x, y) {
    var keyCompare = collate(x.key, y.key);
    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
  }

  function sliceResults(results, limit, skip) {
    skip = skip || 0;
    if (typeof limit === 'number') {
      return results.slice(skip, limit + skip);
    } else if (skip > 0) {
      return results.slice(skip);
    }
    return results;
  }

  function rowToDocId(row) {
    var val = row.value;
    // Users can explicitly specify a joined doc _id, or it
    // defaults to the doc _id that emitted the key/value.
    var docId = (val && typeof val === 'object' && val._id) || row.id;
    return docId;
  }

  function readAttachmentsAsBlobOrBuffer(res) {
    res.rows.forEach(function (row) {
      var atts = row.doc && row.doc._attachments;
      if (!atts) {
        return;
      }
      Object.keys(atts).forEach(function (filename) {
        var att = atts[filename];
        atts[filename].data = b64ToBluffer(att.data, att.content_type);
      });
    });
  }

  function postprocessAttachments(opts) {
    return function (res) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        readAttachmentsAsBlobOrBuffer(res);
      }
      return res;
    };
  }

  function addHttpParam(paramName, opts, params, asJson) {
    // add an http param from opts to params, optionally json-encoded
    var val = opts[paramName];
    if (typeof val !== 'undefined') {
      if (asJson) {
        val = encodeURIComponent(JSON.stringify(val));
      }
      params.push(paramName + '=' + val);
    }
  }

  function coerceInteger(integerCandidate) {
    if (typeof integerCandidate !== 'undefined') {
      var asNumber = Number(integerCandidate);
      // prevents e.g. '1foo' or '1.1' being coerced to 1
      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
        return asNumber;
      } else {
        return integerCandidate;
      }
    }
  }

  function coerceOptions(opts) {
    opts.group_level = coerceInteger(opts.group_level);
    opts.limit = coerceInteger(opts.limit);
    opts.skip = coerceInteger(opts.skip);
    return opts;
  }

  function checkPositiveInteger(number) {
    if (number) {
      if (typeof number !== 'number') {
        return  new QueryParseError('Invalid value for integer: "' +
          number + '"');
      }
      if (number < 0) {
        return new QueryParseError('Invalid value for positive integer: ' +
          '"' + number + '"');
      }
    }
  }

  function checkQueryParseError(options, fun) {
    var startkeyName = options.descending ? 'endkey' : 'startkey';
    var endkeyName = options.descending ? 'startkey' : 'endkey';

    if (typeof options[startkeyName] !== 'undefined' &&
      typeof options[endkeyName] !== 'undefined' &&
      collate(options[startkeyName], options[endkeyName]) > 0) {
      throw new QueryParseError('No rows can match your key range, ' +
        'reverse your start_key and end_key or set {descending : true}');
    } else if (fun.reduce && options.reduce !== false) {
      if (options.include_docs) {
        throw new QueryParseError('{include_docs:true} is invalid for reduce');
      } else if (options.keys && options.keys.length > 1 &&
        !options.group && !options.group_level) {
        throw new QueryParseError('Multi-key fetches for reduce views must use ' +
          '{group: true}');
      }
    }
    ['group_level', 'limit', 'skip'].forEach(function (optionName) {
      var error = checkPositiveInteger(options[optionName]);
      if (error) {
        throw error;
      }
    });
  }

  function httpQuery(db, fun, opts) {
    // List of parameters to add to the PUT request
    var params = [];
    var body;
    var method = 'GET';
    var ok, status;

    // If opts.reduce exists and is defined, then add it to the list
    // of parameters.
    // If reduce=false then the results are that of only the map function
    // not the final result of map and reduce.
    addHttpParam('reduce', opts, params);
    addHttpParam('include_docs', opts, params);
    addHttpParam('attachments', opts, params);
    addHttpParam('limit', opts, params);
    addHttpParam('descending', opts, params);
    addHttpParam('group', opts, params);
    addHttpParam('group_level', opts, params);
    addHttpParam('skip', opts, params);
    addHttpParam('stale', opts, params);
    addHttpParam('conflicts', opts, params);
    addHttpParam('startkey', opts, params, true);
    addHttpParam('start_key', opts, params, true);
    addHttpParam('endkey', opts, params, true);
    addHttpParam('end_key', opts, params, true);
    addHttpParam('inclusive_end', opts, params);
    addHttpParam('key', opts, params, true);
    addHttpParam('update_seq', opts, params);

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    params = params === '' ? '' : '?' + params;

    // If keys are supplied, issue a POST to circumvent GET query string limits
    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.keys !== 'undefined') {
      var MAX_URL_LENGTH = 2000;
      // according to http://stackoverflow.com/a/417184/680742,
      // the de facto URL length limit is 2000 characters

      var keysAsString =
        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
        // If the keys are short enough, do a GET. we do this to work around
        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
        params += (params[0] === '?' ? '&' : '?') + keysAsString;
      } else {
        method = 'POST';
        if (typeof fun === 'string') {
          body = {keys: opts.keys};
        } else { // fun is {map : mapfun}, so append to this
          fun.keys = opts.keys;
        }
      }
    }

    // We are referencing a query defined in the design doc
    if (typeof fun === 'string') {
      var parts = parseViewName(fun);
      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {
        headers: new h({'Content-Type': 'application/json'}),
        method: method,
        body: JSON.stringify(body)
      }).then(function (response) {
        ok = response.ok;
        status = response.status;
        return response.json();
      }).then(function (result) {
        if (!ok) {
          result.status = status;
          throw generateErrorFromResponse(result);
        }
        // fail the entire request if the result contains an error
        result.rows.forEach(function (row) {
          /* istanbul ignore if */
          if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
            throw new Error(row.reason);
          }
        });
        return result;
      }).then(postprocessAttachments(opts));
    }

    // We are using a temporary view, terrible for performance, good for testing
    body = body || {};
    Object.keys(fun).forEach(function (key) {
      if (Array.isArray(fun[key])) {
        body[key] = fun[key];
      } else {
        body[key] = fun[key].toString();
      }
    });

    return db.fetch('_temp_view' + params, {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST',
      body: JSON.stringify(body)
    }).then(function (response) {
        ok = response.ok;
        status = response.status;
      return response.json();
    }).then(function (result) {
      if (!ok) {
        result.status = status;
        throw generateErrorFromResponse(result);
      }
      return result;
    }).then(postprocessAttachments(opts));
  }

  // custom adapters can define their own api._query
  // and override the default behavior
  /* istanbul ignore next */
  function customQuery(db, fun, opts) {
    return new Promise(function (resolve, reject) {
      db._query(fun, opts, function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  // custom adapters can define their own api._viewCleanup
  // and override the default behavior
  /* istanbul ignore next */
  function customViewCleanup(db) {
    return new Promise(function (resolve, reject) {
      db._viewCleanup(function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  function defaultsTo(value) {
    return function (reason) {
      /* istanbul ignore else */
      if (reason.status === 404) {
        return value;
      } else {
        throw reason;
      }
    };
  }

  // returns a promise for a list of docs to update, based on the input docId.
  // the order doesn't matter, because post-3.2.0, bulkDocs
  // is an atomic operation in all three adapters.
  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
    var metaDocId = '_local/doc_' + docId;
    var defaultMetaDoc = {_id: metaDocId, keys: []};
    var docData = docIdsToChangesAndEmits.get(docId);
    var indexableKeysToKeyValues = docData[0];
    var changes = docData[1];

    function getMetaDoc() {
      if (isGenOne(changes)) {
        // generation 1, so we can safely assume initial state
        // for performance reasons (avoids unnecessary GETs)
        return Promise.resolve(defaultMetaDoc);
      }
      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));
    }

    function getKeyValueDocs(metaDoc) {
      if (!metaDoc.keys.length) {
        // no keys, no need for a lookup
        return Promise.resolve({rows: []});
      }
      return view.db.allDocs({
        keys: metaDoc.keys,
        include_docs: true
      });
    }

    function processKeyValueDocs(metaDoc, kvDocsRes) {
      var kvDocs = [];
      var oldKeys = new ExportedSet();

      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
        var row = kvDocsRes.rows[i];
        var doc = row.doc;
        if (!doc) { // deleted
          continue;
        }
        kvDocs.push(doc);
        oldKeys.add(doc._id);
        doc._deleted = !indexableKeysToKeyValues.has(doc._id);
        if (!doc._deleted) {
          var keyValue = indexableKeysToKeyValues.get(doc._id);
          if ('value' in keyValue) {
            doc.value = keyValue.value;
          }
        }
      }
      var newKeys = mapToKeysArray(indexableKeysToKeyValues);
      newKeys.forEach(function (key) {
        if (!oldKeys.has(key)) {
          // new doc
          var kvDoc = {
            _id: key
          };
          var keyValue = indexableKeysToKeyValues.get(key);
          if ('value' in keyValue) {
            kvDoc.value = keyValue.value;
          }
          kvDocs.push(kvDoc);
        }
      });
      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
      kvDocs.push(metaDoc);

      return kvDocs;
    }

    return getMetaDoc().then(function (metaDoc) {
      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
        return processKeyValueDocs(metaDoc, kvDocsRes);
      });
    });
  }

  // updates all emitted key/value docs and metaDocs in the mrview database
  // for the given batch of documents from the source database
  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
    var seqDocId = '_local/lastSeq';
    return view.db.get(seqDocId)
      .catch(defaultsTo({_id: seqDocId, seq: 0}))
      .then(function (lastSeqDoc) {
        var docIds = mapToKeysArray(docIdsToChangesAndEmits);
        return Promise.all(docIds.map(function (docId) {
          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
        })).then(function (listOfDocsToPersist) {
          var docsToPersist = flatten(listOfDocsToPersist);
          lastSeqDoc.seq = seq;
          docsToPersist.push(lastSeqDoc);
          // write all docs in a single operation, update the seq once
          return view.db.bulkDocs({docs : docsToPersist});
        });
      });
  }

  function getQueue(view) {
    var viewName = typeof view === 'string' ? view : view.name;
    var queue = persistentQueues[viewName];
    if (!queue) {
      queue = persistentQueues[viewName] = new TaskQueue$1();
    }
    return queue;
  }

  function updateView(view) {
    return sequentialize(getQueue(view), function () {
      return updateViewInQueue(view);
    })();
  }

  function updateViewInQueue(view) {
    // bind the emit function once
    var mapResults;
    var doc;

    function emit(key, value) {
      var output = {id: doc._id, key: normalizeKey(key)};
      // Don't explicitly store the value unless it's defined and non-null.
      // This saves on storage space, because often people don't use it.
      if (typeof value !== 'undefined' && value !== null) {
        output.value = normalizeKey(value);
      }
      mapResults.push(output);
    }

    var mapFun = mapper(view.mapFun, emit);

    var currentSeq = view.seq || 0;

    function processChange(docIdsToChangesAndEmits, seq) {
      return function () {
        return saveKeyValues(view, docIdsToChangesAndEmits, seq);
      };
    }

    var queue = new TaskQueue$1();

    function processNextBatch() {
      return view.sourceDB.changes({
        return_docs: true,
        conflicts: true,
        include_docs: true,
        style: 'all_docs',
        since: currentSeq,
        limit: CHANGES_BATCH_SIZE$1
      }).then(processBatch);
    }

    function processBatch(response) {
      var results = response.results;
      if (!results.length) {
        return;
      }
      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
      if (results.length < CHANGES_BATCH_SIZE$1) {
        return;
      }
      return processNextBatch();
    }

    function createDocIdsToChangesAndEmits(results) {
      var docIdsToChangesAndEmits = new ExportedMap();
      for (var i = 0, len = results.length; i < len; i++) {
        var change = results[i];
        if (change.doc._id[0] !== '_') {
          mapResults = [];
          doc = change.doc;

          if (!doc._deleted) {
            tryMap(view.sourceDB, mapFun, doc);
          }
          mapResults.sort(sortByKeyThenValue);

          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
          docIdsToChangesAndEmits.set(change.doc._id, [
            indexableKeysToKeyValues,
            change.changes
          ]);
        }
        currentSeq = change.seq;
      }
      return docIdsToChangesAndEmits;
    }

    function createIndexableKeysToKeyValues(mapResults) {
      var indexableKeysToKeyValues = new ExportedMap();
      var lastKey;
      for (var i = 0, len = mapResults.length; i < len; i++) {
        var emittedKeyValue = mapResults[i];
        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
          complexKey.push(i); // dup key+id, so make it unique
        }
        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
        lastKey = emittedKeyValue.key;
      }
      return indexableKeysToKeyValues;
    }

    return processNextBatch().then(function () {
      return queue.finish();
    }).then(function () {
      view.seq = currentSeq;
    });
  }

  function reduceView(view, results, options) {
    if (options.group_level === 0) {
      delete options.group_level;
    }

    var shouldGroup = options.group || options.group_level;

    var reduceFun = reducer(view.reduceFun);

    var groups = [];
    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
      options.group_level;
    results.forEach(function (e) {
      var last = groups[groups.length - 1];
      var groupKey = shouldGroup ? e.key : null;

      // only set group_level for array keys
      if (shouldGroup && Array.isArray(groupKey)) {
        groupKey = groupKey.slice(0, lvl);
      }

      if (last && collate(last.groupKey, groupKey) === 0) {
        last.keys.push([e.key, e.id]);
        last.values.push(e.value);
        return;
      }
      groups.push({
        keys: [[e.key, e.id]],
        values: [e.value],
        groupKey: groupKey
      });
    });
    results = [];
    for (var i = 0, len = groups.length; i < len; i++) {
      var e = groups[i];
      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
        // CouchDB returns an error if a built-in errors out
        throw reduceTry.error;
      }
      results.push({
        // CouchDB just sets the value to null if a non-built-in errors out
        value: reduceTry.error ? null : reduceTry.output,
        key: e.groupKey
      });
    }
    // no total_rows/offset when reducing
    return {rows: sliceResults(results, options.limit, options.skip)};
  }

  function queryView(view, opts) {
    return sequentialize(getQueue(view), function () {
      return queryViewInQueue(view, opts);
    })();
  }

  function queryViewInQueue(view, opts) {
    var totalRows;
    var shouldReduce = view.reduceFun && opts.reduce !== false;
    var skip = opts.skip || 0;
    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
      // equivalent query
      opts.limit = 0;
      delete opts.keys;
    }

    function fetchFromView(viewOpts) {
      viewOpts.include_docs = true;
      return view.db.allDocs(viewOpts).then(function (res) {
        totalRows = res.total_rows;
        return res.rows.map(function (result) {

          // implicit migration - in older versions of PouchDB,
          // we explicitly stored the doc as {id: ..., key: ..., value: ...}
          // this is tested in a migration test
          /* istanbul ignore next */
          if ('value' in result.doc && typeof result.doc.value === 'object' &&
            result.doc.value !== null) {
            var keys = Object.keys(result.doc.value).sort();
            // this detection method is not perfect, but it's unlikely the user
            // emitted a value which was an object with these 3 exact keys
            var expectedKeys = ['id', 'key', 'value'];
            if (!(keys < expectedKeys || keys > expectedKeys)) {
              return result.doc.value;
            }
          }

          var parsedKeyAndDocId = parseIndexableString(result.doc._id);
          return {
            key: parsedKeyAndDocId[0],
            id: parsedKeyAndDocId[1],
            value: ('value' in result.doc ? result.doc.value : null)
          };
        });
      });
    }

    function onMapResultsReady(rows) {
      var finalResults;
      if (shouldReduce) {
        finalResults = reduceView(view, rows, opts);
      } else {
        finalResults = {
          total_rows: totalRows,
          offset: skip,
          rows: rows
        };
      }
      /* istanbul ignore if */
      if (opts.update_seq) {
        finalResults.update_seq = view.seq;
      }
      if (opts.include_docs) {
        var docIds = uniq(rows.map(rowToDocId));

        return view.sourceDB.allDocs({
          keys: docIds,
          include_docs: true,
          conflicts: opts.conflicts,
          attachments: opts.attachments,
          binary: opts.binary
        }).then(function (allDocsRes) {
          var docIdsToDocs = new ExportedMap();
          allDocsRes.rows.forEach(function (row) {
            docIdsToDocs.set(row.id, row.doc);
          });
          rows.forEach(function (row) {
            var docId = rowToDocId(row);
            var doc = docIdsToDocs.get(docId);
            if (doc) {
              row.doc = doc;
            }
          });
          return finalResults;
        });
      } else {
        return finalResults;
      }
    }

    if (typeof opts.keys !== 'undefined') {
      var keys = opts.keys;
      var fetchPromises = keys.map(function (key) {
        var viewOpts = {
          startkey : toIndexableString([key]),
          endkey   : toIndexableString([key, {}])
        };
        /* istanbul ignore if */
        if (opts.update_seq) {
          viewOpts.update_seq = true;
        }
        return fetchFromView(viewOpts);
      });
      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
    } else { // normal query, no 'keys'
      var viewOpts = {
        descending : opts.descending
      };
      /* istanbul ignore if */
      if (opts.update_seq) {
        viewOpts.update_seq = true;
      }
      var startkey;
      var endkey;
      if ('start_key' in opts) {
        startkey = opts.start_key;
      }
      if ('startkey' in opts) {
        startkey = opts.startkey;
      }
      if ('end_key' in opts) {
        endkey = opts.end_key;
      }
      if ('endkey' in opts) {
        endkey = opts.endkey;
      }
      if (typeof startkey !== 'undefined') {
        viewOpts.startkey = opts.descending ?
          toIndexableString([startkey, {}]) :
          toIndexableString([startkey]);
      }
      if (typeof endkey !== 'undefined') {
        var inclusiveEnd = opts.inclusive_end !== false;
        if (opts.descending) {
          inclusiveEnd = !inclusiveEnd;
        }

        viewOpts.endkey = toIndexableString(
          inclusiveEnd ? [endkey, {}] : [endkey]);
      }
      if (typeof opts.key !== 'undefined') {
        var keyStart = toIndexableString([opts.key]);
        var keyEnd = toIndexableString([opts.key, {}]);
        if (viewOpts.descending) {
          viewOpts.endkey = keyStart;
          viewOpts.startkey = keyEnd;
        } else {
          viewOpts.startkey = keyStart;
          viewOpts.endkey = keyEnd;
        }
      }
      if (!shouldReduce) {
        if (typeof opts.limit === 'number') {
          viewOpts.limit = opts.limit;
        }
        viewOpts.skip = skip;
      }
      return fetchFromView(viewOpts).then(onMapResultsReady);
    }
  }

  function httpViewCleanup(db) {
    return db.fetch('_view_cleanup', {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST'
    }).then(function (response) {
      return response.json();
    });
  }

  function localViewCleanup(db) {
    return db.get('_local/' + localDocName).then(function (metaDoc) {
      var docsToViews = new ExportedMap();
      Object.keys(metaDoc.views).forEach(function (fullViewName) {
        var parts = parseViewName(fullViewName);
        var designDocName = '_design/' + parts[0];
        var viewName = parts[1];
        var views = docsToViews.get(designDocName);
        if (!views) {
          views = new ExportedSet();
          docsToViews.set(designDocName, views);
        }
        views.add(viewName);
      });
      var opts = {
        keys : mapToKeysArray(docsToViews),
        include_docs : true
      };
      return db.allDocs(opts).then(function (res) {
        var viewsToStatus = {};
        res.rows.forEach(function (row) {
          var ddocName = row.key.substring(8); // cuts off '_design/'
          docsToViews.get(row.key).forEach(function (viewName) {
            var fullViewName = ddocName + '/' + viewName;
            /* istanbul ignore if */
            if (!metaDoc.views[fullViewName]) {
              // new format, without slashes, to support PouchDB 2.2.0
              // migration test in pouchdb's browser.migration.js verifies this
              fullViewName = viewName;
            }
            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
            // design doc deleted, or view function nonexistent
            var statusIsGood = row.doc && row.doc.views &&
              row.doc.views[viewName];
            viewDBNames.forEach(function (viewDBName) {
              viewsToStatus[viewDBName] =
                viewsToStatus[viewDBName] || statusIsGood;
            });
          });
        });
        var dbsToDelete = Object.keys(viewsToStatus).filter(
          function (viewDBName) { return !viewsToStatus[viewDBName]; });
        var destroyPromises = dbsToDelete.map(function (viewDBName) {
          return sequentialize(getQueue(viewDBName), function () {
            return new db.constructor(viewDBName, db.__opts).destroy();
          })();
        });
        return Promise.all(destroyPromises).then(function () {
          return {ok: true};
        });
      });
    }, defaultsTo({ok: true}));
  }

  function queryPromised(db, fun, opts) {
    /* istanbul ignore next */
    if (typeof db._query === 'function') {
      return customQuery(db, fun, opts);
    }
    if (isRemote(db)) {
      return httpQuery(db, fun, opts);
    }

    if (typeof fun !== 'string') {
      // temp_view
      checkQueryParseError(opts, fun);

      tempViewQueue.add(function () {
        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ 'temp_view/temp_view',
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ true,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          return fin(updateView(view).then(function () {
            return queryView(view, opts);
          }), function () {
            return view.db.destroy();
          });
        });
      });
      return tempViewQueue.finish();
    } else {
      // persistent view
      var fullViewName = fun;
      var parts = parseViewName(fullViewName);
      var designDocName = parts[0];
      var viewName = parts[1];
      return db.get('_design/' + designDocName).then(function (doc) {
        var fun = doc.views && doc.views[viewName];

        if (!fun) {
          // basic validator; it's assumed that every subclass would want this
          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
            viewName);
        }

        ddocValidator(doc, viewName);
        checkQueryParseError(opts, fun);

        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ fullViewName,
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ false,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          if (opts.stale === 'ok' || opts.stale === 'update_after') {
            if (opts.stale === 'update_after') {
              nextTick(function () {
                updateView(view);
              });
            }
            return queryView(view, opts);
          } else { // stale not ok
            return updateView(view).then(function () {
              return queryView(view, opts);
            });
          }
        });
      });
    }
  }

  function abstractQuery(fun, opts, callback) {
    var db = this;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = opts ? coerceOptions(opts) : {};

    if (typeof fun === 'function') {
      fun = {map : fun};
    }

    var promise = Promise.resolve().then(function () {
      return queryPromised(db, fun, opts);
    });
    promisedCallback(promise, callback);
    return promise;
  }

  var abstractViewCleanup = callbackify(function () {
    var db = this;
    /* istanbul ignore next */
    if (typeof db._viewCleanup === 'function') {
      return customViewCleanup(db);
    }
    if (isRemote(db)) {
      return httpViewCleanup(db);
    }
    return localViewCleanup(db);
  });

  return {
    query: abstractQuery,
    viewCleanup: abstractViewCleanup
  };
}

var builtInReduce = {
  _sum: function (keys, values) {
    return sum(values);
  },

  _count: function (keys, values) {
    return values.length;
  },

  _stats: function (keys, values) {
    // no need to implement rereduce=true, because Pouch
    // will never call it
    function sumsqr(values) {
      var _sumsqr = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        _sumsqr += (num * num);
      }
      return _sumsqr;
    }
    return {
      sum     : sum(values),
      min     : Math.min.apply(null, values),
      max     : Math.max.apply(null, values),
      count   : values.length,
      sumsqr : sumsqr(values)
    };
  }
};

function getBuiltIn(reduceFunString) {
  if (/^_sum/.test(reduceFunString)) {
    return builtInReduce._sum;
  } else if (/^_count/.test(reduceFunString)) {
    return builtInReduce._count;
  } else if (/^_stats/.test(reduceFunString)) {
    return builtInReduce._stats;
  } else if (/^_/.test(reduceFunString)) {
    throw new Error(reduceFunString + ' is not a supported reduce function.');
  }
}

function mapper(mapFun, emit) {
  // for temp_views one can use emit(doc, emit), see #38
  if (typeof mapFun === "function" && mapFun.length === 2) {
    var origMap = mapFun;
    return function (doc) {
      return origMap(doc, emit);
    };
  } else {
    return evalFunctionWithEval(mapFun.toString(), emit);
  }
}

function reducer(reduceFun) {
  var reduceFunString = reduceFun.toString();
  var builtIn = getBuiltIn(reduceFunString);
  if (builtIn) {
    return builtIn;
  } else {
    return evalFunctionWithEval(reduceFunString);
  }
}

function ddocValidator(ddoc, viewName) {
  var fun = ddoc.views && ddoc.views[viewName];
  if (typeof fun.map !== 'string') {
    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +
      viewName + ', instead found object of type: ' + typeof fun.map);
  }
}

var localDocName = 'mrviews';
var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);

function query(fun, opts, callback) {
  return abstract.query.call(this, fun, opts, callback);
}

function viewCleanup(callback) {
  return abstract.viewCleanup.call(this, callback);
}

var mapreduce = {
  query: query,
  viewCleanup: viewCleanup
};

function isGenOne$1(rev) {
  return /^1-/.test(rev);
}

function fileHasChanged(localDoc, remoteDoc, filename) {
  return !localDoc._attachments ||
         !localDoc._attachments[filename] ||
         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
}

function getDocAttachments(db, doc) {
  var filenames = Object.keys(doc._attachments);
  return Promise.all(filenames.map(function (filename) {
    return db.getAttachment(doc._id, filename, {rev: doc._rev});
  }));
}

function getDocAttachmentsFromTargetOrSource(target, src, doc) {
  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
  var filenames = Object.keys(doc._attachments);

  if (!doCheckForLocalAttachments) {
    return getDocAttachments(src, doc);
  }

  return target.get(doc._id).then(function (localDoc) {
    return Promise.all(filenames.map(function (filename) {
      if (fileHasChanged(localDoc, doc, filename)) {
        return src.getAttachment(doc._id, filename);
      }

      return target.getAttachment(localDoc._id, filename);
    }));
  }).catch(function (error) {
    /* istanbul ignore if */
    if (error.status !== 404) {
      throw error;
    }

    return getDocAttachments(src, doc);
  });
}

function createBulkGetOpts(diffs) {
  var requests = [];
  Object.keys(diffs).forEach(function (id) {
    var missingRevs = diffs[id].missing;
    missingRevs.forEach(function (missingRev) {
      requests.push({
        id: id,
        rev: missingRev
      });
    });
  });

  return {
    docs: requests,
    revs: true,
    latest: true
  };
}

//
// Fetch all the documents from the src as described in the "diffs",
// which is a mapping of docs IDs to revisions. If the state ever
// changes to "cancelled", then the returned promise will be rejected.
// Else it will be resolved with a list of fetched documents.
//
function getDocs(src, target, diffs, state) {
  diffs = clone(diffs); // we do not need to modify this

  var resultDocs = [],
      ok = true;

  function getAllDocs() {

    var bulkGetOpts = createBulkGetOpts(diffs);

    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
      return;
    }

    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
      /* istanbul ignore if */
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {
        return Promise.all(bulkGetInfo.docs.map(function (doc) {
          var remoteDoc = doc.ok;

          if (doc.error) {
            // when AUTO_COMPACTION is set, docs can be returned which look
            // like this: {"missing":"1-7c3ac256b693c462af8442f992b83696"}
            ok = false;
          }

          if (!remoteDoc || !remoteDoc._attachments) {
            return remoteDoc;
          }

          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)
                   .then(function (attachments) {
                           var filenames = Object.keys(remoteDoc._attachments);
                           attachments
                             .forEach(function (attachment, i) {
                                        var att = remoteDoc._attachments[filenames[i]];
                                        delete att.stub;
                                        delete att.length;
                                        att.data = attachment;
                                      });

                                      return remoteDoc;
                                    });
        }));
      }))

      .then(function (results) {
        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
      });
    });
  }

  function hasAttachments(doc) {
    return doc._attachments && Object.keys(doc._attachments).length > 0;
  }

  function hasConflicts(doc) {
    return doc._conflicts && doc._conflicts.length > 0;
  }

  function fetchRevisionOneDocs(ids) {
    // Optimization: fetch gen-1 docs and attachments in
    // a single request using _all_docs
    return src.allDocs({
      keys: ids,
      include_docs: true,
      conflicts: true
    }).then(function (res) {
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      res.rows.forEach(function (row) {
        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||
            hasAttachments(row.doc) || hasConflicts(row.doc)) {
          // if any of these conditions apply, we need to fetch using get()
          return;
        }

        // strip _conflicts array to appease CSG (#5793)
        /* istanbul ignore if */
        if (row.doc._conflicts) {
          delete row.doc._conflicts;
        }

        // the doc we got back from allDocs() is sufficient
        resultDocs.push(row.doc);
        delete diffs[row.id];
      });
    });
  }

  function getRevisionOneDocs() {
    // filter out the generation 1 docs and get them
    // leaving the non-generation one docs to be got otherwise
    var ids = Object.keys(diffs).filter(function (id) {
      var missing = diffs[id].missing;
      return missing.length === 1 && isGenOne$1(missing[0]);
    });
    if (ids.length > 0) {
      return fetchRevisionOneDocs(ids);
    }
  }

  function returnResult() {
    return { ok:ok, docs:resultDocs };
  }

  return Promise.resolve()
    .then(getRevisionOneDocs)
    .then(getAllDocs)
    .then(returnResult);
}

var CHECKPOINT_VERSION = 1;
var REPLICATOR = "pouchdb";
// This is an arbitrary number to limit the
// amount of replication history we save in the checkpoint.
// If we save too much, the checkpoing docs will become very big,
// if we save fewer, we'll run a greater risk of having to
// read all the changes from 0 when checkpoint PUTs fail
// CouchDB 2.0 has a more involved history pruning,
// but let's go for the simple version for now.
var CHECKPOINT_HISTORY_SIZE = 5;
var LOWEST_SEQ = 0;

function updateCheckpoint(db, id, checkpoint, session, returnValue) {
  return db.get(id).catch(function (err) {
    if (err.status === 404) {
      if (db.adapter === 'http' || db.adapter === 'https') {
        explainError(
          404, 'PouchDB is just checking if a remote checkpoint exists.'
        );
      }
      return {
        session_id: session,
        _id: id,
        history: [],
        replicator: REPLICATOR,
        version: CHECKPOINT_VERSION
      };
    }
    throw err;
  }).then(function (doc) {
    if (returnValue.cancelled) {
      return;
    }

    // if the checkpoint has not changed, do not update
    if (doc.last_seq === checkpoint) {
      return;
    }

    // Filter out current entry for this replication
    doc.history = (doc.history || []).filter(function (item) {
      return item.session_id !== session;
    });

    // Add the latest checkpoint to history
    doc.history.unshift({
      last_seq: checkpoint,
      session_id: session
    });

    // Just take the last pieces in history, to
    // avoid really big checkpoint docs.
    // see comment on history size above
    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

    doc.version = CHECKPOINT_VERSION;
    doc.replicator = REPLICATOR;

    doc.session_id = session;
    doc.last_seq = checkpoint;

    return db.put(doc).catch(function (err) {
      if (err.status === 409) {
        // retry; someone is trying to write a checkpoint simultaneously
        return updateCheckpoint(db, id, checkpoint, session, returnValue);
      }
      throw err;
    });
  });
}

function Checkpointer(src, target, id, returnValue, opts) {
  this.src = src;
  this.target = target;
  this.id = id;
  this.returnValue = returnValue;
  this.opts = opts || {};
}

Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
  var self = this;
  return this.updateTarget(checkpoint, session).then(function () {
    return self.updateSource(checkpoint, session);
  });
};

Checkpointer.prototype.updateTarget = function (checkpoint, session) {
  if (this.opts.writeTargetCheckpoint) {
    return updateCheckpoint(this.target, this.id, checkpoint,
      session, this.returnValue);
  } else {
    return Promise.resolve(true);
  }
};

Checkpointer.prototype.updateSource = function (checkpoint, session) {
  if (this.opts.writeSourceCheckpoint) {
    var self = this;
    return updateCheckpoint(this.src, this.id, checkpoint,
      session, this.returnValue)
      .catch(function (err) {
        if (isForbiddenError(err)) {
          self.opts.writeSourceCheckpoint = false;
          return true;
        }
        throw err;
      });
  } else {
    return Promise.resolve(true);
  }
};

var comparisons = {
  "undefined": function (targetDoc, sourceDoc) {
    // This is the previous comparison function
    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
      return sourceDoc.last_seq;
    }
    /* istanbul ignore next */
    return 0;
  },
  "1": function (targetDoc, sourceDoc) {
    // This is the comparison function ported from CouchDB
    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
  }
};

Checkpointer.prototype.getCheckpoint = function () {
  var self = this;

  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {
    return self.src.get(self.id).then(function (sourceDoc) {
      return sourceDoc.last_seq || LOWEST_SEQ;
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        throw err;
      }
      return LOWEST_SEQ;
    });
  }

  return self.target.get(self.id).then(function (targetDoc) {
    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {
      return targetDoc.last_seq || LOWEST_SEQ;
    }

    return self.src.get(self.id).then(function (sourceDoc) {
      // Since we can't migrate an old version doc to a new one
      // (no session id), we just go with the lowest seq in this case
      /* istanbul ignore if */
      if (targetDoc.version !== sourceDoc.version) {
        return LOWEST_SEQ;
      }

      var version;
      if (targetDoc.version) {
        version = targetDoc.version.toString();
      } else {
        version = "undefined";
      }

      if (version in comparisons) {
        return comparisons[version](targetDoc, sourceDoc);
      }
      /* istanbul ignore next */
      return LOWEST_SEQ;
    }, function (err) {
      if (err.status === 404 && targetDoc.last_seq) {
        return self.src.put({
          _id: self.id,
          last_seq: LOWEST_SEQ
        }).then(function () {
          return LOWEST_SEQ;
        }, function (err) {
          if (isForbiddenError(err)) {
            self.opts.writeSourceCheckpoint = false;
            return targetDoc.last_seq;
          }
          /* istanbul ignore next */
          return LOWEST_SEQ;
        });
      }
      throw err;
    });
  }).catch(function (err) {
    if (err.status !== 404) {
      throw err;
    }
    return LOWEST_SEQ;
  });
};
// This checkpoint comparison is ported from CouchDBs source
// they come from here:
// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

function compareReplicationLogs(srcDoc, tgtDoc) {
  if (srcDoc.session_id === tgtDoc.session_id) {
    return {
      last_seq: srcDoc.last_seq,
      history: srcDoc.history
    };
  }

  return compareReplicationHistory(srcDoc.history, tgtDoc.history);
}

function compareReplicationHistory(sourceHistory, targetHistory) {
  // the erlang loop via function arguments is not so easy to repeat in JS
  // therefore, doing this as recursion
  var S = sourceHistory[0];
  var sourceRest = sourceHistory.slice(1);
  var T = targetHistory[0];
  var targetRest = targetHistory.slice(1);

  if (!S || targetHistory.length === 0) {
    return {
      last_seq: LOWEST_SEQ,
      history: []
    };
  }

  var sourceId = S.session_id;
  /* istanbul ignore if */
  if (hasSessionId(sourceId, targetHistory)) {
    return {
      last_seq: S.last_seq,
      history: sourceHistory
    };
  }

  var targetId = T.session_id;
  if (hasSessionId(targetId, sourceRest)) {
    return {
      last_seq: T.last_seq,
      history: targetRest
    };
  }

  return compareReplicationHistory(sourceRest, targetRest);
}

function hasSessionId(sessionId, history) {
  var props = history[0];
  var rest = history.slice(1);

  if (!sessionId || history.length === 0) {
    return false;
  }

  if (sessionId === props.session_id) {
    return true;
  }

  return hasSessionId(sessionId, rest);
}

function isForbiddenError(err) {
  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
}

var STARTING_BACK_OFF = 0;

function backOff(opts, returnValue, error, callback) {
  if (opts.retry === false) {
    returnValue.emit('error', error);
    returnValue.removeAllListeners();
    return;
  }
  /* istanbul ignore if */
  if (typeof opts.back_off_function !== 'function') {
    opts.back_off_function = defaultBackOff;
  }
  returnValue.emit('requestError', error);
  if (returnValue.state === 'active' || returnValue.state === 'pending') {
    returnValue.emit('paused', error);
    returnValue.state = 'stopped';
    var backOffSet = function backoffTimeSet() {
      opts.current_back_off = STARTING_BACK_OFF;
    };
    var removeBackOffSetter = function removeBackOffTimeSet() {
      returnValue.removeListener('active', backOffSet);
    };
    returnValue.once('paused', removeBackOffSetter);
    returnValue.once('active', backOffSet);
  }

  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
  opts.current_back_off = opts.back_off_function(opts.current_back_off);
  setTimeout(callback, opts.current_back_off);
}

function sortObjectPropertiesByKey(queryParams) {
  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
    result[key] = queryParams[key];
    return result;
  }, {});
}

// Generate a unique id particular to this replication.
// Not guaranteed to align perfectly with CouchDB's rep ids.
function generateReplicationId(src, target, opts) {
  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
  var filterFun = opts.filter ? opts.filter.toString() : '';
  var queryParams = '';
  var filterViewName =  '';
  var selector = '';

  // possibility for checkpoints to be lost here as behaviour of
  // JSON.stringify is not stable (see #6226)
  /* istanbul ignore if */
  if (opts.selector) {
    selector = JSON.stringify(opts.selector);
  }

  if (opts.filter && opts.query_params) {
    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
  }

  if (opts.filter && opts.filter === '_view') {
    filterViewName = opts.view.toString();
  }

  return Promise.all([src.id(), target.id()]).then(function (res) {
    var queryData = res[0] + res[1] + filterFun + filterViewName +
      queryParams + docIds + selector;
    return new Promise(function (resolve) {
      binaryMd5(queryData, resolve);
    });
  }).then(function (md5sum) {
    // can't use straight-up md5 alphabet, because
    // the char '/' is interpreted as being for attachments,
    // and + is also not url-safe
    md5sum = md5sum.replace(/\//g, '.').replace(/\+/g, '_');
    return '_local/' + md5sum;
  });
}

function replicate(src, target, opts, returnValue, result) {
  var batches = [];               // list of batches to be processed
  var currentBatch;               // the batch currently being processed
  var pendingBatch = {
    seq: 0,
    changes: [],
    docs: []
  }; // next batch, not yet ready to be processed
  var writingCheckpoint = false;  // true while checkpoint is being written
  var changesCompleted = false;   // true when all changes received
  var replicationCompleted = false; // true when replication has completed
  var last_seq = 0;
  var continuous = opts.continuous || opts.live || false;
  var batch_size = opts.batch_size || 100;
  var batches_limit = opts.batches_limit || 10;
  var changesPending = false;     // true while src.changes is running
  var doc_ids = opts.doc_ids;
  var selector = opts.selector;
  var repId;
  var checkpointer;
  var changedDocs = [];
  // Like couchdb, every replication gets a unique session id
  var session = uuid();

  result = result || {
    ok: true,
    start_time: new Date().toISOString(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };

  var changesOpts = {};
  returnValue.ready(src, target);

  function initCheckpointer() {
    if (checkpointer) {
      return Promise.resolve();
    }
    return generateReplicationId(src, target, opts).then(function (res) {
      repId = res;

      var checkpointOpts = {};
      if (opts.checkpoint === false) {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'source') {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'target') {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };
      } else {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };
      }

      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
    });
  }

  function writeDocs() {
    changedDocs = [];

    if (currentBatch.docs.length === 0) {
      return;
    }
    var docs = currentBatch.docs;
    var bulkOpts = {timeout: opts.timeout};
    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }

      // `res` doesn't include full documents (which live in `docs`), so we create a map of 
      // (id -> error), and check for errors while iterating over `docs`
      var errorsById = Object.create(null);
      res.forEach(function (res) {
        if (res.error) {
          errorsById[res.id] = res;
        }
      });

      var errorsNo = Object.keys(errorsById).length;
      result.doc_write_failures += errorsNo;
      result.docs_written += docs.length - errorsNo;

      docs.forEach(function (doc) {
        var error = errorsById[doc._id];
        if (error) {
          result.errors.push(error);
          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
          var errorName = (error.name || '').toLowerCase();
          if (errorName === 'unauthorized' || errorName === 'forbidden') {
            returnValue.emit('denied', clone(error));
          } else {
            throw error;
          }
        } else {
          changedDocs.push(doc);
        }
      });

    }, function (err) {
      result.doc_write_failures += docs.length;
      throw err;
    });
  }

  function finishBatch() {
    if (currentBatch.error) {
      throw new Error('There was a problem getting docs.');
    }
    result.last_seq = last_seq = currentBatch.seq;
    var outResult = clone(result);
    if (changedDocs.length) {
      outResult.docs = changedDocs;
      // Attach 'pending' property if server supports it (CouchDB 2.0+)
      /* istanbul ignore if */
      if (typeof currentBatch.pending === 'number') {
        outResult.pending = currentBatch.pending;
        delete currentBatch.pending;
      }
      returnValue.emit('change', outResult);
    }
    writingCheckpoint = true;
    return checkpointer.writeCheckpoint(currentBatch.seq,
        session).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      currentBatch = undefined;
      getChanges();
    }).catch(function (err) {
      onCheckpointError(err);
      throw err;
    });
  }

  function getDiffs() {
    var diff = {};
    currentBatch.changes.forEach(function (change) {
      // Couchbase Sync Gateway emits these, but we can ignore them
      /* istanbul ignore if */
      if (change.id === "_user/") {
        return;
      }
      diff[change.id] = change.changes.map(function (x) {
        return x.rev;
      });
    });
    return target.revsDiff(diff).then(function (diffs) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      // currentBatch.diffs elements are deleted as the documents are written
      currentBatch.diffs = diffs;
    });
  }

  function getBatchDocs() {
    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
      currentBatch.error = !got.ok;
      got.docs.forEach(function (doc) {
        delete currentBatch.diffs[doc._id];
        result.docs_read++;
        currentBatch.docs.push(doc);
      });
    });
  }

  function startNextBatch() {
    if (returnValue.cancelled || currentBatch) {
      return;
    }
    if (batches.length === 0) {
      processPendingBatch(true);
      return;
    }
    currentBatch = batches.shift();
    getDiffs()
      .then(getBatchDocs)
      .then(writeDocs)
      .then(finishBatch)
      .then(startNextBatch)
      .catch(function (err) {
        abortReplication('batch processing terminated with error', err);
      });
  }


  function processPendingBatch(immediate) {
    if (pendingBatch.changes.length === 0) {
      if (batches.length === 0 && !currentBatch) {
        if ((continuous && changesOpts.live) || changesCompleted) {
          returnValue.state = 'pending';
          returnValue.emit('paused');
        }
        if (changesCompleted) {
          completeReplication();
        }
      }
      return;
    }
    if (
      immediate ||
      changesCompleted ||
      pendingBatch.changes.length >= batch_size
    ) {
      batches.push(pendingBatch);
      pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      };
      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
        returnValue.state = 'active';
        returnValue.emit('active');
      }
      startNextBatch();
    }
  }


  function abortReplication(reason, err) {
    if (replicationCompleted) {
      return;
    }
    if (!err.message) {
      err.message = reason;
    }
    result.ok = false;
    result.status = 'aborting';
    batches = [];
    pendingBatch = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication(err);
  }


  function completeReplication(fatalError) {
    if (replicationCompleted) {
      return;
    }
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      result.status = 'cancelled';
      if (writingCheckpoint) {
        return;
      }
    }
    result.status = result.status || 'complete';
    result.end_time = new Date().toISOString();
    result.last_seq = last_seq;
    replicationCompleted = true;

    if (fatalError) {
      // need to extend the error because Firefox considers ".result" read-only
      fatalError = createError(fatalError);
      fatalError.result = result;

      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
      var errorName = (fatalError.name || '').toLowerCase();
      if (errorName === 'unauthorized' || errorName === 'forbidden') {
        returnValue.emit('error', fatalError);
        returnValue.removeAllListeners();
      } else {
        backOff(opts, returnValue, fatalError, function () {
          replicate(src, target, opts, returnValue);
        });
      }
    } else {
      returnValue.emit('complete', result);
      returnValue.removeAllListeners();
    }
  }


  function onChange(change, pending, lastSeq) {
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    // Attach 'pending' property if server supports it (CouchDB 2.0+)
    /* istanbul ignore if */
    if (typeof pending === 'number') {
      pendingBatch.pending = pending;
    }

    var filter = filterChange(opts)(change);
    if (!filter) {
      return;
    }
    pendingBatch.seq = change.seq || lastSeq;
    pendingBatch.changes.push(change);
    nextTick(function () {
      processPendingBatch(batches.length === 0 && changesOpts.live);
    });
  }


  function onChangesComplete(changes) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }

    // if no results were returned then we're done,
    // else fetch more
    if (changes.results.length > 0) {
      changesOpts.since = changes.results[changes.results.length - 1].seq;
      getChanges();
      processPendingBatch(true);
    } else {

      var complete = function () {
        if (continuous) {
          changesOpts.live = true;
          getChanges();
        } else {
          changesCompleted = true;
        }
        processPendingBatch(true);
      };

      // update the checkpoint so we start from the right seq next time
      if (!currentBatch && changes.results.length === 0) {
        writingCheckpoint = true;
        checkpointer.writeCheckpoint(changes.last_seq,
            session).then(function () {
          writingCheckpoint = false;
          result.last_seq = last_seq = changes.last_seq;
          complete();
        })
        .catch(onCheckpointError);
      } else {
        complete();
      }
    }
  }


  function onChangesError(err) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    abortReplication('changes rejected', err);
  }


  function getChanges() {
    if (!(
      !changesPending &&
      !changesCompleted &&
      batches.length < batches_limit
      )) {
      return;
    }
    changesPending = true;
    function abortChanges() {
      changes.cancel();
    }
    function removeListener() {
      returnValue.removeListener('cancel', abortChanges);
    }

    if (returnValue._changes) { // remove old changes() and listeners
      returnValue.removeListener('cancel', returnValue._abortChanges);
      returnValue._changes.cancel();
    }
    returnValue.once('cancel', abortChanges);

    var changes = src.changes(changesOpts)
      .on('change', onChange);
    changes.then(removeListener, removeListener);
    changes.then(onChangesComplete)
      .catch(onChangesError);

    if (opts.retry) {
      // save for later so we can cancel if necessary
      returnValue._changes = changes;
      returnValue._abortChanges = abortChanges;
    }
  }


  function startChanges() {
    initCheckpointer().then(function () {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      return checkpointer.getCheckpoint().then(function (checkpoint) {
        last_seq = checkpoint;
        changesOpts = {
          since: last_seq,
          limit: batch_size,
          batch_size: batch_size,
          style: 'all_docs',
          doc_ids: doc_ids,
          selector: selector,
          return_docs: true // required so we know when we're done
        };
        if (opts.filter) {
          if (typeof opts.filter !== 'string') {
            // required for the client-side filter in onChange
            changesOpts.include_docs = true;
          } else { // ddoc filter
            changesOpts.filter = opts.filter;
          }
        }
        if ('heartbeat' in opts) {
          changesOpts.heartbeat = opts.heartbeat;
        }
        if ('timeout' in opts) {
          changesOpts.timeout = opts.timeout;
        }
        if (opts.query_params) {
          changesOpts.query_params = opts.query_params;
        }
        if (opts.view) {
          changesOpts.view = opts.view;
        }
        getChanges();
      });
    }).catch(function (err) {
      abortReplication('getCheckpoint rejected with ', err);
    });
  }

  /* istanbul ignore next */
  function onCheckpointError(err) {
    writingCheckpoint = false;
    abortReplication('writeCheckpoint completed with error', err);
  }

  /* istanbul ignore if */
  if (returnValue.cancelled) { // cancelled immediately
    completeReplication();
    return;
  }

  if (!returnValue._addedListeners) {
    returnValue.once('cancel', completeReplication);

    if (typeof opts.complete === 'function') {
      returnValue.once('error', opts.complete);
      returnValue.once('complete', function (result) {
        opts.complete(null, result);
      });
    }
    returnValue._addedListeners = true;
  }

  if (typeof opts.since === 'undefined') {
    startChanges();
  } else {
    initCheckpointer().then(function () {
      writingCheckpoint = true;
      return checkpointer.writeCheckpoint(opts.since, session);
    }).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      last_seq = opts.since;
      startChanges();
    }).catch(onCheckpointError);
  }
}

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
inherits(Replication, events.EventEmitter);
function Replication() {
  events.EventEmitter.call(this);
  this.cancelled = false;
  this.state = 'pending';
  var self = this;
  var promise = new Promise(function (fulfill, reject) {
    self.once('complete', fulfill);
    self.once('error', reject);
  });
  self.then = function (resolve, reject) {
    return promise.then(resolve, reject);
  };
  self.catch = function (reject) {
    return promise.catch(reject);
  };
  // As we allow error handling via "error" event as well,
  // put a stub in here so that rejecting never throws UnhandledError.
  self.catch(function () {});
}

Replication.prototype.cancel = function () {
  this.cancelled = true;
  this.state = 'cancelled';
  this.emit('cancel');
};

Replication.prototype.ready = function (src, target) {
  var self = this;
  if (self._readyCalled) {
    return;
  }
  self._readyCalled = true;

  function onDestroy() {
    self.cancel();
  }
  src.once('destroyed', onDestroy);
  target.once('destroyed', onDestroy);
  function cleanup() {
    src.removeListener('destroyed', onDestroy);
    target.removeListener('destroyed', onDestroy);
  }
  self.once('complete', cleanup);
};

function toPouch(db, opts) {
  var PouchConstructor = opts.PouchConstructor;
  if (typeof db === 'string') {
    return new PouchConstructor(db, opts);
  } else {
    return db;
  }
}

function replicateWrapper(src, target, opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }

  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
    throw createError(BAD_REQUEST,
                       "`doc_ids` filter parameter is not a list.");
  }

  opts.complete = callback;
  opts = clone(opts);
  opts.continuous = opts.continuous || opts.live;
  opts.retry = ('retry' in opts) ? opts.retry : false;
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  var replicateRet = new Replication(opts);
  var srcPouch = toPouch(src, opts);
  var targetPouch = toPouch(target, opts);
  replicate(srcPouch, targetPouch, opts, replicateRet);
  return replicateRet;
}

inherits(Sync, events.EventEmitter);
function sync(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  opts = clone(opts);
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  src = toPouch(src, opts);
  target = toPouch(target, opts);
  return new Sync(src, target, opts, callback);
}

function Sync(src, target, opts, callback) {
  var self = this;
  this.canceled = false;

  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;

  this.push = replicateWrapper(src, target, optsPush);
  this.pull = replicateWrapper(target, src, optsPull);

  this.pushPaused = true;
  this.pullPaused = true;

  function pullChange(change) {
    self.emit('change', {
      direction: 'pull',
      change: change
    });
  }
  function pushChange(change) {
    self.emit('change', {
      direction: 'push',
      change: change
    });
  }
  function pushDenied(doc) {
    self.emit('denied', {
      direction: 'push',
      doc: doc
    });
  }
  function pullDenied(doc) {
    self.emit('denied', {
      direction: 'pull',
      doc: doc
    });
  }
  function pushPaused() {
    self.pushPaused = true;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('paused');
    }
  }
  function pullPaused() {
    self.pullPaused = true;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('paused');
    }
  }
  function pushActive() {
    self.pushPaused = false;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('active', {
        direction: 'push'
      });
    }
  }
  function pullActive() {
    self.pullPaused = false;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('active', {
        direction: 'pull'
      });
    }
  }

  var removed = {};

  function removeAll(type) { // type is 'push' or 'pull'
    return function (event, func) {
      var isChange = event === 'change' &&
        (func === pullChange || func === pushChange);
      var isDenied = event === 'denied' &&
        (func === pullDenied || func === pushDenied);
      var isPaused = event === 'paused' &&
        (func === pullPaused || func === pushPaused);
      var isActive = event === 'active' &&
        (func === pullActive || func === pushActive);

      if (isChange || isDenied || isPaused || isActive) {
        if (!(event in removed)) {
          removed[event] = {};
        }
        removed[event][type] = true;
        if (Object.keys(removed[event]).length === 2) {
          // both push and pull have asked to be removed
          self.removeAllListeners(event);
        }
      }
    };
  }

  if (opts.live) {
    this.push.on('complete', self.pull.cancel.bind(self.pull));
    this.pull.on('complete', self.push.cancel.bind(self.push));
  }

  function addOneListener(ee, event, listener) {
    if (ee.listeners(event).indexOf(listener) == -1) {
      ee.on(event, listener);
    }
  }

  this.on('newListener', function (event) {
    if (event === 'change') {
      addOneListener(self.pull, 'change', pullChange);
      addOneListener(self.push, 'change', pushChange);
    } else if (event === 'denied') {
      addOneListener(self.pull, 'denied', pullDenied);
      addOneListener(self.push, 'denied', pushDenied);
    } else if (event === 'active') {
      addOneListener(self.pull, 'active', pullActive);
      addOneListener(self.push, 'active', pushActive);
    } else if (event === 'paused') {
      addOneListener(self.pull, 'paused', pullPaused);
      addOneListener(self.push, 'paused', pushPaused);
    }
  });

  this.on('removeListener', function (event) {
    if (event === 'change') {
      self.pull.removeListener('change', pullChange);
      self.push.removeListener('change', pushChange);
    } else if (event === 'denied') {
      self.pull.removeListener('denied', pullDenied);
      self.push.removeListener('denied', pushDenied);
    } else if (event === 'active') {
      self.pull.removeListener('active', pullActive);
      self.push.removeListener('active', pushActive);
    } else if (event === 'paused') {
      self.pull.removeListener('paused', pullPaused);
      self.push.removeListener('paused', pushPaused);
    }
  });

  this.pull.on('removeListener', removeAll('pull'));
  this.push.on('removeListener', removeAll('push'));

  var promise = Promise.all([
    this.push,
    this.pull
  ]).then(function (resp) {
    var out = {
      push: resp[0],
      pull: resp[1]
    };
    self.emit('complete', out);
    if (callback) {
      callback(null, out);
    }
    self.removeAllListeners();
    return out;
  }, function (err) {
    self.cancel();
    if (callback) {
      // if there's a callback, then the callback can receive
      // the error event
      callback(err);
    } else {
      // if there's no callback, then we're safe to emit an error
      // event, which would otherwise throw an unhandled error
      // due to 'error' being a special event in EventEmitters
      self.emit('error', err);
    }
    self.removeAllListeners();
    if (callback) {
      // no sense throwing if we're already emitting an 'error' event
      throw err;
    }
  });

  this.then = function (success, err) {
    return promise.then(success, err);
  };

  this.catch = function (err) {
    return promise.catch(err);
  };
}

Sync.prototype.cancel = function () {
  if (!this.canceled) {
    this.canceled = true;
    this.push.cancel();
    this.pull.cancel();
  }
};

function replication(PouchDB) {
  PouchDB.replicate = replicateWrapper;
  PouchDB.sync = sync;

  Object.defineProperty(PouchDB.prototype, 'replicate', {
    get: function () {
      var self = this;
      if (typeof this.replicateMethods === 'undefined') {
        this.replicateMethods = {
          from: function (other, opts, callback) {
            return self.constructor.replicate(other, self, opts, callback);
          },
          to: function (other, opts, callback) {
            return self.constructor.replicate(self, other, opts, callback);
          }
        };
      }
      return this.replicateMethods;
    }
  });

  PouchDB.prototype.sync = function (dbName, opts, callback) {
    return this.constructor.sync(this, dbName, opts, callback);
  };
}

PouchDB.plugin(IDBPouch)
  .plugin(HttpPouch$1)
  .plugin(mapreduce)
  .plugin(replication);

// Pull from src because pouchdb-node/pouchdb-browser themselves

module.exports = PouchDB;

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"argsarray":1,"events":7,"immediate":9,"inherits":10,"rH1JPG":12,"spark-md5":13,"uuid":14,"vuvuzela":19}],12:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],13:[function(require,module,exports){
(function (factory) {
    if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals (with support for web workers)
        var glob;

        try {
            glob = window;
        } catch (e) {
            glob = self;
        }

        glob.SparkMD5 = factory();
    }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));

},{}],14:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":17,"./v4":18}],15:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],16:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));
if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],17:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":15,"./lib/rng":16}],18:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":15,"./lib/rng":16}],19:[function(require,module,exports){
'use strict';

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\t':
      case '\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\d\.\-e\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUUID = exports.measurementsDB = exports.chronicleDB = exports.annotatorsDB = exports.animalsDB = exports.adjectivesDB = exports.measurementsURL = exports.chronicleURL = exports.animalsURL = exports.adjectivesURL = exports.annotatorsURL = exports.uuidURL = void 0;

var _pouchdb = _interopRequireDefault(require("pouchdb"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseURL = 'https://k8s-testing.ohif.org/couchdb';
var uuidURL = "".concat(baseURL, "/_uuids");
exports.uuidURL = uuidURL;
var annotatorsURL = "".concat(baseURL, "/annotators");
exports.annotatorsURL = annotatorsURL;
var adjectivesURL = "".concat(baseURL, "/adjectives");
exports.adjectivesURL = adjectivesURL;
var animalsURL = "".concat(baseURL, "/animals");
exports.animalsURL = animalsURL;
var chronicleURL = "".concat(baseURL, "/chronicle"); //export const chronicleURL = `${baseURL}/compressed-chronicle2`;

exports.chronicleURL = chronicleURL;
var measurementsURL = "".concat(baseURL, "/measurements"); // console.log('url:', uuidUrl);
// export const uuidDB = new PouchDB(uuidURL);

exports.measurementsURL = measurementsURL;
var adjectivesDB = new _pouchdb.default(adjectivesURL);
exports.adjectivesDB = adjectivesDB;
var animalsDB = new _pouchdb.default(animalsURL);
exports.animalsDB = animalsDB;
var annotatorsDB = new _pouchdb.default(annotatorsURL);
exports.annotatorsDB = annotatorsDB;
var chronicleDB = new _pouchdb.default(chronicleURL);
exports.chronicleDB = chronicleDB;
var measurementsDB = new _pouchdb.default(measurementsURL);
exports.measurementsDB = measurementsDB;

var getUUID = function getUUID() {
  return new Promise(function (resolve, reject) {
    $.get(uuidURL, function (_ref) {
      var uuids = _ref.uuids;
      resolve(uuids[0]);
    }); // const uuid = doc.uuids[0];
    // console.log('uuid:', uuid);
  });
};

exports.getUUID = getUUID;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRiLmpzIl0sIm5hbWVzIjpbImJhc2VVUkwiLCJ1dWlkVVJMIiwiYW5ub3RhdG9yc1VSTCIsImFkamVjdGl2ZXNVUkwiLCJhbmltYWxzVVJMIiwiY2hyb25pY2xlVVJMIiwibWVhc3VyZW1lbnRzVVJMIiwiYWRqZWN0aXZlc0RCIiwiUG91Y2hEQiIsImFuaW1hbHNEQiIsImFubm90YXRvcnNEQiIsImNocm9uaWNsZURCIiwibWVhc3VyZW1lbnRzREIiLCJnZXRVVUlEIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCIkIiwiZ2V0IiwidXVpZHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUVBLElBQU1BLE9BQU8sR0FBQyxzQ0FBZDtBQUVPLElBQU1DLE9BQU8sYUFBTUQsT0FBTixZQUFiOztBQUNBLElBQU1FLGFBQWEsYUFBTUYsT0FBTixnQkFBbkI7O0FBQ0EsSUFBTUcsYUFBYSxhQUFNSCxPQUFOLGdCQUFuQjs7QUFDQSxJQUFNSSxVQUFVLGFBQU1KLE9BQU4sYUFBaEI7O0FBQ0EsSUFBTUssWUFBWSxhQUFNTCxPQUFOLGVBQWxCLEMsQ0FDUDs7O0FBRU8sSUFBTU0sZUFBZSxhQUFNTixPQUFOLGtCQUFyQixDLENBRVA7QUFFQTs7O0FBQ08sSUFBTU8sWUFBWSxHQUFHLElBQUlDLGdCQUFKLENBQVlMLGFBQVosQ0FBckI7O0FBQ0EsSUFBTU0sU0FBUyxHQUFHLElBQUlELGdCQUFKLENBQVlKLFVBQVosQ0FBbEI7O0FBQ0EsSUFBTU0sWUFBWSxHQUFHLElBQUlGLGdCQUFKLENBQVlOLGFBQVosQ0FBckI7O0FBQ0EsSUFBTVMsV0FBVyxHQUFHLElBQUlILGdCQUFKLENBQVlILFlBQVosQ0FBcEI7O0FBQ0EsSUFBTU8sY0FBYyxHQUFHLElBQUlKLGdCQUFKLENBQVlGLGVBQVosQ0FBdkI7OztBQUVBLElBQU1PLE9BQU8sR0FBRyxTQUFWQSxPQUFVLEdBQU07QUFDM0IsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDQyxJQUFBQSxDQUFDLENBQUNDLEdBQUYsQ0FBTWpCLE9BQU4sRUFBZSxnQkFBYTtBQUFBLFVBQVhrQixLQUFXLFFBQVhBLEtBQVc7QUFBQ0osTUFBQUEsT0FBTyxDQUFDSSxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQVA7QUFBa0IsS0FBL0MsRUFEc0MsQ0FFcEM7QUFDQTtBQUNILEdBSk0sQ0FBUDtBQUtELENBTk0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUG91Y2hEQiBmcm9tICdwb3VjaGRiJztcblxuY29uc3QgYmFzZVVSTD0naHR0cHM6Ly9rOHMtdGVzdGluZy5vaGlmLm9yZy9jb3VjaGRiJztcblxuZXhwb3J0IGNvbnN0IHV1aWRVUkwgPSBgJHtiYXNlVVJMfS9fdXVpZHNgO1xuZXhwb3J0IGNvbnN0IGFubm90YXRvcnNVUkwgPSBgJHtiYXNlVVJMfS9hbm5vdGF0b3JzYDtcbmV4cG9ydCBjb25zdCBhZGplY3RpdmVzVVJMID0gYCR7YmFzZVVSTH0vYWRqZWN0aXZlc2A7XG5leHBvcnQgY29uc3QgYW5pbWFsc1VSTCA9IGAke2Jhc2VVUkx9L2FuaW1hbHNgO1xuZXhwb3J0IGNvbnN0IGNocm9uaWNsZVVSTCA9IGAke2Jhc2VVUkx9L2Nocm9uaWNsZWA7XG4vL2V4cG9ydCBjb25zdCBjaHJvbmljbGVVUkwgPSBgJHtiYXNlVVJMfS9jb21wcmVzc2VkLWNocm9uaWNsZTJgO1xuXG5leHBvcnQgY29uc3QgbWVhc3VyZW1lbnRzVVJMID0gYCR7YmFzZVVSTH0vbWVhc3VyZW1lbnRzYDtcblxuLy8gY29uc29sZS5sb2coJ3VybDonLCB1dWlkVXJsKTtcblxuLy8gZXhwb3J0IGNvbnN0IHV1aWREQiA9IG5ldyBQb3VjaERCKHV1aWRVUkwpO1xuZXhwb3J0IGNvbnN0IGFkamVjdGl2ZXNEQiA9IG5ldyBQb3VjaERCKGFkamVjdGl2ZXNVUkwpO1xuZXhwb3J0IGNvbnN0IGFuaW1hbHNEQiA9IG5ldyBQb3VjaERCKGFuaW1hbHNVUkwpO1xuZXhwb3J0IGNvbnN0IGFubm90YXRvcnNEQiA9IG5ldyBQb3VjaERCKGFubm90YXRvcnNVUkwpO1xuZXhwb3J0IGNvbnN0IGNocm9uaWNsZURCID0gbmV3IFBvdWNoREIoY2hyb25pY2xlVVJMKTtcbmV4cG9ydCBjb25zdCBtZWFzdXJlbWVudHNEQiA9IG5ldyBQb3VjaERCKG1lYXN1cmVtZW50c1VSTCk7XG5cbmV4cG9ydCBjb25zdCBnZXRVVUlEID0gKCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICQuZ2V0KHV1aWRVUkwsICh7dXVpZHN9KSA9PiB7cmVzb2x2ZSh1dWlkc1swXSl9KTtcbiAgICAgIC8vIGNvbnN0IHV1aWQgPSBkb2MudXVpZHNbMF07XG4gICAgICAvLyBjb25zb2xlLmxvZygndXVpZDonLCB1dWlkKTtcbiAgfSk7XG59O1xuIl19
},{"pouchdb":11}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _login = _interopRequireDefault(require("../login/login"));

var _viewer = _interopRequireDefault(require("../viewer/viewer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  $modal: $('.error-modal'),
  $overlay: $('.loading-overlay'),
  logout: function logout() {
    this.$modal.removeClass('show');
    this.$overlay.addClass('invisible');

    _login.default.logout();
  },
  nextCase: function nextCase() {
    this.hide();

    _viewer.default.getNextCase();
  },
  show: function show() {
    this.$modal.addClass('show');
    this.$overlay.removeClass('invisible');
  },
  hide: function hide() {
    this.$modal.removeClass('show');
    this.$overlay.addClass('invisible');
  },
  init: function init() {
    var _this = this;

    this.$modal.find('.ok').on('click', function () {
      return _this.hide();
    }); // this.$modal.find('.next-case').on('click', () => this.nextCase());
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGFsLmpzIl0sIm5hbWVzIjpbIiRtb2RhbCIsIiQiLCIkb3ZlcmxheSIsImxvZ291dCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJMb2dpbiIsIm5leHRDYXNlIiwiaGlkZSIsIlZpZXdlciIsImdldE5leHRDYXNlIiwic2hvdyIsImluaXQiLCJmaW5kIiwib24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7OztlQUVlO0FBQ2JBLEVBQUFBLE1BQU0sRUFBRUMsQ0FBQyxDQUFDLGNBQUQsQ0FESTtBQUViQyxFQUFBQSxRQUFRLEVBQUVELENBQUMsQ0FBQyxrQkFBRCxDQUZFO0FBR2JFLEVBQUFBLE1BSGEsb0JBR0o7QUFDUCxTQUFLSCxNQUFMLENBQVlJLFdBQVosQ0FBd0IsTUFBeEI7QUFDQSxTQUFLRixRQUFMLENBQWNHLFFBQWQsQ0FBdUIsV0FBdkI7O0FBRUFDLG1CQUFNSCxNQUFOO0FBQ0QsR0FSWTtBQVNiSSxFQUFBQSxRQVRhLHNCQVNGO0FBQ1QsU0FBS0MsSUFBTDs7QUFFQUMsb0JBQU9DLFdBQVA7QUFDRCxHQWJZO0FBY2JDLEVBQUFBLElBZGEsa0JBY047QUFDTCxTQUFLWCxNQUFMLENBQVlLLFFBQVosQ0FBcUIsTUFBckI7QUFDQSxTQUFLSCxRQUFMLENBQWNFLFdBQWQsQ0FBMEIsV0FBMUI7QUFDRCxHQWpCWTtBQWtCYkksRUFBQUEsSUFsQmEsa0JBa0JOO0FBQ0wsU0FBS1IsTUFBTCxDQUFZSSxXQUFaLENBQXdCLE1BQXhCO0FBQ0EsU0FBS0YsUUFBTCxDQUFjRyxRQUFkLENBQXVCLFdBQXZCO0FBQ0QsR0FyQlk7QUFzQmJPLEVBQUFBLElBdEJhLGtCQXNCTjtBQUFBOztBQUNMLFNBQUtaLE1BQUwsQ0FBWWEsSUFBWixDQUFpQixLQUFqQixFQUF3QkMsRUFBeEIsQ0FBMkIsT0FBM0IsRUFBb0M7QUFBQSxhQUFNLEtBQUksQ0FBQ04sSUFBTCxFQUFOO0FBQUEsS0FBcEMsRUFESyxDQUVMO0FBQ0Q7QUF6QlksQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dpbiBmcm9tICcuLi9sb2dpbi9sb2dpbic7XG5pbXBvcnQgVmlld2VyIGZyb20gJy4uL3ZpZXdlci92aWV3ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICRtb2RhbDogJCgnLmVycm9yLW1vZGFsJyksXG4gICRvdmVybGF5OiAkKCcubG9hZGluZy1vdmVybGF5JyksXG4gIGxvZ291dCgpIHtcbiAgICB0aGlzLiRtb2RhbC5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuXG4gICAgTG9naW4ubG9nb3V0KCk7XG4gIH0sXG4gIG5leHRDYXNlKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgVmlld2VyLmdldE5leHRDYXNlKCk7XG4gIH0sXG4gIHNob3coKSB7XG4gICAgdGhpcy4kbW9kYWwuYWRkQ2xhc3MoJ3Nob3cnKTtcbiAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgfSxcbiAgaGlkZSgpIHtcbiAgICB0aGlzLiRtb2RhbC5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICB9LFxuICBpbml0KCkge1xuICAgIHRoaXMuJG1vZGFsLmZpbmQoJy5vaycpLm9uKCdjbGljaycsICgpID0+IHRoaXMuaGlkZSgpKTtcbiAgICAvLyB0aGlzLiRtb2RhbC5maW5kKCcubmV4dC1jYXNlJykub24oJ2NsaWNrJywgKCkgPT4gdGhpcy5uZXh0Q2FzZSgpKTtcbiAgfVxufVxuIl19
},{"../login/login":23,"../viewer/viewer":32}],22:[function(require,module,exports){
"use strict";

var _viewer = _interopRequireDefault(require("../viewer/viewer"));

var _login = _interopRequireDefault(require("./login"));

var _signup = _interopRequireDefault(require("../signup/signup"));

var _db = require("../db/db");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_login.default.$loginForm.off('submit').on('submit', function (evt) {
  evt.preventDefault();
  var $loginUsername = $('#login-username');
  var username = $loginUsername.val();

  if (username === '') {
    return;
  }

  _login.default.$loadingImg.removeClass('invisible');

  $loginUsername.val('');
  _login.default.username = username;
  console.log('username:', username); //console.log('Login Login:', Login);

  _db.annotatorsDB.get(username).then(function (user) {
    _login.default.user = user;
    console.log('Login.user is: ', _login.default.user);
    $('#username-bottom-left').text(_login.default.username);
    window.localStorage.setItem('username', username);

    _login.default.$loadingImg.addClass('invisible');

    _login.default.$loginWrapper.addClass('invisible');

    _viewer.default.initViewer();
  }).catch(function (err) {
    var loginError = $('#login-error');
    loginError.text("Username ".concat(username, " is not found. Try another username or sign up for a new account"));
    loginError.removeClass('invisible');

    _login.default.$loadingImg.addClass('invisible');
  });
});

$('#open-signup-btn-new').off('click').click(function (event) {
  event.preventDefault();

  _login.default.$loginWrapper.addClass('invisible');

  new _signup.default().init();
});
$(document.body).css({
  position: 'relative',
  overflow: 'auto'
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZha2VfNzhmMDQyNGUuanMiXSwibmFtZXMiOlsiTG9naW4iLCIkbG9naW5Gb3JtIiwib2ZmIiwib24iLCJldnQiLCJwcmV2ZW50RGVmYXVsdCIsIiRsb2dpblVzZXJuYW1lIiwiJCIsInVzZXJuYW1lIiwidmFsIiwiJGxvYWRpbmdJbWciLCJyZW1vdmVDbGFzcyIsImNvbnNvbGUiLCJsb2ciLCJhbm5vdGF0b3JzREIiLCJnZXQiLCJ0aGVuIiwidXNlciIsInRleHQiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiYWRkQ2xhc3MiLCIkbG9naW5XcmFwcGVyIiwiVmlld2VyIiwiaW5pdFZpZXdlciIsImNhdGNoIiwiZXJyIiwibG9naW5FcnJvciIsImNsaWNrIiwiZXZlbnQiLCJTaWdudXAiLCJpbml0IiwiZG9jdW1lbnQiLCJib2R5IiwiY3NzIiwicG9zaXRpb24iLCJvdmVyZmxvdyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBQSxlQUFNQyxVQUFOLENBQWlCQyxHQUFqQixDQUFxQixRQUFyQixFQUErQkMsRUFBL0IsQ0FBa0MsUUFBbEMsRUFBNEMsVUFBVUMsR0FBVixFQUFlO0FBQ3pEQSxFQUFBQSxHQUFHLENBQUNDLGNBQUo7QUFFQSxNQUFNQyxjQUFjLEdBQUdDLENBQUMsQ0FBQyxpQkFBRCxDQUF4QjtBQUNBLE1BQU1DLFFBQVEsR0FBR0YsY0FBYyxDQUFDRyxHQUFmLEVBQWpCOztBQUNBLE1BQUlELFFBQVEsS0FBSyxFQUFqQixFQUFxQjtBQUNuQjtBQUNEOztBQUVEUixpQkFBTVUsV0FBTixDQUFrQkMsV0FBbEIsQ0FBOEIsV0FBOUI7O0FBRUFMLEVBQUFBLGNBQWMsQ0FBQ0csR0FBZixDQUFtQixFQUFuQjtBQUNBVCxpQkFBTVEsUUFBTixHQUFpQkEsUUFBakI7QUFDQUksRUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksV0FBWixFQUF5QkwsUUFBekIsRUFieUQsQ0FjekQ7O0FBRUFNLG1CQUFhQyxHQUFiLENBQWlCUCxRQUFqQixFQUEyQlEsSUFBM0IsQ0FBZ0MsVUFBQ0MsSUFBRCxFQUFVO0FBQ3hDakIsbUJBQU1pQixJQUFOLEdBQWFBLElBQWI7QUFDQUwsSUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksaUJBQVosRUFBK0JiLGVBQU1pQixJQUFyQztBQUNBVixJQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQlcsSUFBM0IsQ0FBZ0NsQixlQUFNUSxRQUF0QztBQUVBVyxJQUFBQSxNQUFNLENBQUNDLFlBQVAsQ0FBb0JDLE9BQXBCLENBQTRCLFVBQTVCLEVBQXdDYixRQUF4Qzs7QUFDQVIsbUJBQU1VLFdBQU4sQ0FBa0JZLFFBQWxCLENBQTJCLFdBQTNCOztBQUNBdEIsbUJBQU11QixhQUFOLENBQW9CRCxRQUFwQixDQUE2QixXQUE3Qjs7QUFFQUUsb0JBQU9DLFVBQVA7QUFDRCxHQVZELEVBVUdDLEtBVkgsQ0FVUyxVQUFDQyxHQUFELEVBQVM7QUFDaEIsUUFBTUMsVUFBVSxHQUFHckIsQ0FBQyxDQUFDLGNBQUQsQ0FBcEI7QUFDQXFCLElBQUFBLFVBQVUsQ0FBQ1YsSUFBWCxvQkFBNEJWLFFBQTVCO0FBQ0FvQixJQUFBQSxVQUFVLENBQUNqQixXQUFYLENBQXVCLFdBQXZCOztBQUNBWCxtQkFBTVUsV0FBTixDQUFrQlksUUFBbEIsQ0FBMkIsV0FBM0I7QUFDRCxHQWZEO0FBZ0JELENBaENEOztBQWtDQWYsQ0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEJMLEdBQTFCLENBQThCLE9BQTlCLEVBQXVDMkIsS0FBdkMsQ0FBNkMsVUFBU0MsS0FBVCxFQUFnQjtBQUMzREEsRUFBQUEsS0FBSyxDQUFDekIsY0FBTjs7QUFFQUwsaUJBQU11QixhQUFOLENBQW9CRCxRQUFwQixDQUE2QixXQUE3Qjs7QUFFQSxNQUFJUyxlQUFKLEdBQWFDLElBQWI7QUFDRCxDQU5EO0FBUUF6QixDQUFDLENBQUMwQixRQUFRLENBQUNDLElBQVYsQ0FBRCxDQUFpQkMsR0FBakIsQ0FBcUI7QUFDbkJDLEVBQUFBLFFBQVEsRUFBRSxVQURTO0FBRW5CQyxFQUFBQSxRQUFRLEVBQUU7QUFGUyxDQUFyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWV3ZXIgZnJvbSAnLi4vdmlld2VyL3ZpZXdlcic7XG5pbXBvcnQgTG9naW4gZnJvbSAnLi9sb2dpbic7XG5pbXBvcnQgU2lnbnVwIGZyb20gJy4uL3NpZ251cC9zaWdudXAnO1xuaW1wb3J0IHthbm5vdGF0b3JzREJ9IGZyb20gJy4uL2RiL2RiJztcblxuTG9naW4uJGxvZ2luRm9ybS5vZmYoJ3N1Ym1pdCcpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGNvbnN0ICRsb2dpblVzZXJuYW1lID0gJCgnI2xvZ2luLXVzZXJuYW1lJyk7XG4gIGNvbnN0IHVzZXJuYW1lID0gJGxvZ2luVXNlcm5hbWUudmFsKCk7XG4gIGlmICh1c2VybmFtZSA9PT0gJycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBMb2dpbi4kbG9hZGluZ0ltZy5yZW1vdmVDbGFzcygnaW52aXNpYmxlJyk7XG5cbiAgJGxvZ2luVXNlcm5hbWUudmFsKCcnKTtcbiAgTG9naW4udXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgY29uc29sZS5sb2coJ3VzZXJuYW1lOicsIHVzZXJuYW1lKTtcbiAgLy9jb25zb2xlLmxvZygnTG9naW4gTG9naW46JywgTG9naW4pO1xuXG4gIGFubm90YXRvcnNEQi5nZXQodXNlcm5hbWUpLnRoZW4oKHVzZXIpID0+IHtcbiAgICBMb2dpbi51c2VyID0gdXNlcjtcbiAgICBjb25zb2xlLmxvZygnTG9naW4udXNlciBpczogJywgTG9naW4udXNlcik7XG4gICAgJCgnI3VzZXJuYW1lLWJvdHRvbS1sZWZ0JykudGV4dChMb2dpbi51c2VybmFtZSk7XG5cbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJuYW1lJywgdXNlcm5hbWUpO1xuICAgIExvZ2luLiRsb2FkaW5nSW1nLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICBMb2dpbi4kbG9naW5XcmFwcGVyLmFkZENsYXNzKCdpbnZpc2libGUnKTtcblxuICAgIFZpZXdlci5pbml0Vmlld2VyKCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBjb25zdCBsb2dpbkVycm9yID0gJCgnI2xvZ2luLWVycm9yJyk7XG4gICAgbG9naW5FcnJvci50ZXh0KGBVc2VybmFtZSAke3VzZXJuYW1lfSBpcyBub3QgZm91bmQuIFRyeSBhbm90aGVyIHVzZXJuYW1lIG9yIHNpZ24gdXAgZm9yIGEgbmV3IGFjY291bnRgKVxuICAgIGxvZ2luRXJyb3IucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgIExvZ2luLiRsb2FkaW5nSW1nLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgfSk7XG59KTtcblxuJCgnI29wZW4tc2lnbnVwLWJ0bi1uZXcnKS5vZmYoJ2NsaWNrJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICBMb2dpbi4kbG9naW5XcmFwcGVyLmFkZENsYXNzKCdpbnZpc2libGUnKTtcblxuICBuZXcgU2lnbnVwKCkuaW5pdCgpO1xufSk7XG5cbiQoZG9jdW1lbnQuYm9keSkuY3NzKHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIG92ZXJmbG93OiAnYXV0bydcbn0pO1xuIl19
},{"../db/db":20,"../signup/signup":26,"../viewer/viewer":32,"./login":23}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var $loadingImg = $('.login-wrapper .login-form button.submit .loading');
var $loginForm = $('.login-wrapper form');
var $loginWrapper = $('.login-wrapper');
var $homepage = $('#homepage');
var $signupWrapper = $('#signup-wrapper');
var $viewWrapper = $('.viewer-wrapper');
var $overlay = $('.loading-overlay');
var Login = {
  $loadingImg: $loadingImg,
  $loginForm: $loginForm,
  $loginWrapper: $loginWrapper,
  $viewWrapper: $viewWrapper,
  $overlay: $overlay,
  $homepage: $homepage,
  $signupWrapper: $signupWrapper,
  username: undefined,
  logout: function logout() {
    this.username = undefined;
    this.$overlay.addClass('invisible');
    this.$homepage.removeClass('invisible');
    this.$signupWrapper.addClass('invisible');
    this.$viewWrapper.addClass('invisible'); // Reset any body CSS imposed by the viewer

    $(document.body).css({
      position: 'relative',
      overflow: 'auto'
    }); // Remove this username from localstorage

    window.localStorage.removeItem('username');
  }
};
var _default = Login;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxvZ2luLmpzIl0sIm5hbWVzIjpbIiRsb2FkaW5nSW1nIiwiJCIsIiRsb2dpbkZvcm0iLCIkbG9naW5XcmFwcGVyIiwiJGhvbWVwYWdlIiwiJHNpZ251cFdyYXBwZXIiLCIkdmlld1dyYXBwZXIiLCIkb3ZlcmxheSIsIkxvZ2luIiwidXNlcm5hbWUiLCJ1bmRlZmluZWQiLCJsb2dvdXQiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiZG9jdW1lbnQiLCJib2R5IiwiY3NzIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQU1BLFdBQVcsR0FBR0MsQ0FBQyxDQUFDLG1EQUFELENBQXJCO0FBQ0EsSUFBTUMsVUFBVSxHQUFHRCxDQUFDLENBQUMscUJBQUQsQ0FBcEI7QUFDQSxJQUFNRSxhQUFhLEdBQUdGLENBQUMsQ0FBQyxnQkFBRCxDQUF2QjtBQUNBLElBQU1HLFNBQVMsR0FBR0gsQ0FBQyxDQUFDLFdBQUQsQ0FBbkI7QUFDQSxJQUFNSSxjQUFjLEdBQUdKLENBQUMsQ0FBQyxpQkFBRCxDQUF4QjtBQUNBLElBQU1LLFlBQVksR0FBR0wsQ0FBQyxDQUFDLGlCQUFELENBQXRCO0FBQ0EsSUFBTU0sUUFBUSxHQUFHTixDQUFDLENBQUMsa0JBQUQsQ0FBbEI7QUFFQSxJQUFNTyxLQUFLLEdBQUc7QUFDWlIsRUFBQUEsV0FBVyxFQUFYQSxXQURZO0FBRVpFLEVBQUFBLFVBQVUsRUFBVkEsVUFGWTtBQUdaQyxFQUFBQSxhQUFhLEVBQWJBLGFBSFk7QUFJWkcsRUFBQUEsWUFBWSxFQUFaQSxZQUpZO0FBS1pDLEVBQUFBLFFBQVEsRUFBUkEsUUFMWTtBQU1aSCxFQUFBQSxTQUFTLEVBQVRBLFNBTlk7QUFPWkMsRUFBQUEsY0FBYyxFQUFkQSxjQVBZO0FBUVpJLEVBQUFBLFFBQVEsRUFBRUMsU0FSRTtBQVNaQyxFQUFBQSxNQVRZLG9CQVNIO0FBQ1AsU0FBS0YsUUFBTCxHQUFnQkMsU0FBaEI7QUFDQSxTQUFLSCxRQUFMLENBQWNLLFFBQWQsQ0FBdUIsV0FBdkI7QUFDQSxTQUFLUixTQUFMLENBQWVTLFdBQWYsQ0FBMkIsV0FBM0I7QUFDQSxTQUFLUixjQUFMLENBQW9CTyxRQUFwQixDQUE2QixXQUE3QjtBQUNBLFNBQUtOLFlBQUwsQ0FBa0JNLFFBQWxCLENBQTJCLFdBQTNCLEVBTE8sQ0FPUDs7QUFDQVgsSUFBQUEsQ0FBQyxDQUFDYSxRQUFRLENBQUNDLElBQVYsQ0FBRCxDQUFpQkMsR0FBakIsQ0FBcUI7QUFDbkJDLE1BQUFBLFFBQVEsRUFBRSxVQURTO0FBRW5CQyxNQUFBQSxRQUFRLEVBQUU7QUFGUyxLQUFyQixFQVJPLENBYVA7O0FBQ0FDLElBQUFBLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQkMsVUFBcEIsQ0FBK0IsVUFBL0I7QUFDRDtBQXhCVyxDQUFkO2VBMkJlYixLIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgJGxvYWRpbmdJbWcgPSAkKCcubG9naW4td3JhcHBlciAubG9naW4tZm9ybSBidXR0b24uc3VibWl0IC5sb2FkaW5nJyk7XG5jb25zdCAkbG9naW5Gb3JtID0gJCgnLmxvZ2luLXdyYXBwZXIgZm9ybScpO1xuY29uc3QgJGxvZ2luV3JhcHBlciA9ICQoJy5sb2dpbi13cmFwcGVyJyk7XG5jb25zdCAkaG9tZXBhZ2UgPSAkKCcjaG9tZXBhZ2UnKTtcbmNvbnN0ICRzaWdudXBXcmFwcGVyID0gJCgnI3NpZ251cC13cmFwcGVyJyk7XG5jb25zdCAkdmlld1dyYXBwZXIgPSAkKCcudmlld2VyLXdyYXBwZXInKTtcbmNvbnN0ICRvdmVybGF5ID0gJCgnLmxvYWRpbmctb3ZlcmxheScpO1xuXG5jb25zdCBMb2dpbiA9IHtcbiAgJGxvYWRpbmdJbWcsXG4gICRsb2dpbkZvcm0sXG4gICRsb2dpbldyYXBwZXIsXG4gICR2aWV3V3JhcHBlcixcbiAgJG92ZXJsYXksXG4gICRob21lcGFnZSxcbiAgJHNpZ251cFdyYXBwZXIsXG4gIHVzZXJuYW1lOiB1bmRlZmluZWQsXG4gIGxvZ291dCgpIHtcbiAgICB0aGlzLnVzZXJuYW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgIHRoaXMuJGhvbWVwYWdlLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgICB0aGlzLiRzaWdudXBXcmFwcGVyLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICB0aGlzLiR2aWV3V3JhcHBlci5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG5cbiAgICAvLyBSZXNldCBhbnkgYm9keSBDU1MgaW1wb3NlZCBieSB0aGUgdmlld2VyXG4gICAgJChkb2N1bWVudC5ib2R5KS5jc3Moe1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nXG4gICAgfSk7XG5cbiAgICAvLyBSZW1vdmUgdGhpcyB1c2VybmFtZSBmcm9tIGxvY2Fsc3RvcmFnZVxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcm5hbWUnKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9naW47Il19
},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _login = _interopRequireWildcard(require("../login/login"));

var _modal = _interopRequireDefault(require("../modal/modal"));

var _modal2 = _interopRequireDefault(require("../errorModal/modal"));

var _viewer = _interopRequireDefault(require("../viewer/viewer"));

var _db = require("../db/db");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var _default = {
  $menuWrapper: $('.menu-wrapper'),
  $overlay: $('.loading-overlay'),
  submit: function submit() {
    this.closeMenu();
    Commands.save();
  },
  nextCase: function nextCase() {
    this.closeMenu();

    _viewer.default.getNextCase();
  },
  logout: function logout() {
    this.closeMenu();

    _login.default.logout();
  },
  closeMenu: function closeMenu() {
    var _this = this;

    this.$overlay.addClass('invisible');
    this.$menuWrapper.removeClass('opened');
    setTimeout(function () {
      _this.$menuWrapper.addClass('invisible');
    }, 1200);
  },
  init: function init() {
    var _this2 = this;

    _modal.default.init();

    _modal2.default.init();

    this.$menuWrapper.on('click', 'a[data-menu]', function (event) {
      var $element = $(event.currentTarget);
      var menu = $element.attr('data-menu');
      event.preventDefault();

      if (menu) {
        _this2[menu]();
      }
    });
    this.$overlay.on('click', function (event) {
      if (_this2.$menuWrapper.hasClass('opened')) {
        _this2.closeMenu();
      }
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lbnUuanMiXSwibmFtZXMiOlsiJG1lbnVXcmFwcGVyIiwiJCIsIiRvdmVybGF5Iiwic3VibWl0IiwiY2xvc2VNZW51IiwiQ29tbWFuZHMiLCJzYXZlIiwibmV4dENhc2UiLCJWaWV3ZXIiLCJnZXROZXh0Q2FzZSIsImxvZ291dCIsIkxvZ2luIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInNldFRpbWVvdXQiLCJpbml0IiwiTW9kYWwiLCJFcnJvck1vZGFsIiwib24iLCJldmVudCIsIiRlbGVtZW50IiwiY3VycmVudFRhcmdldCIsIm1lbnUiLCJhdHRyIiwicHJldmVudERlZmF1bHQiLCJoYXNDbGFzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7ZUFHZTtBQUNiQSxFQUFBQSxZQUFZLEVBQUVDLENBQUMsQ0FBQyxlQUFELENBREY7QUFFYkMsRUFBQUEsUUFBUSxFQUFFRCxDQUFDLENBQUMsa0JBQUQsQ0FGRTtBQUliRSxFQUFBQSxNQUphLG9CQUlKO0FBQ1AsU0FBS0MsU0FBTDtBQUNBQyxJQUFBQSxRQUFRLENBQUNDLElBQVQ7QUFDRCxHQVBZO0FBUWJDLEVBQUFBLFFBUmEsc0JBUUY7QUFDVCxTQUFLSCxTQUFMOztBQUNBSSxvQkFBT0MsV0FBUDtBQUNELEdBWFk7QUFZYkMsRUFBQUEsTUFaYSxvQkFZTDtBQUNOLFNBQUtOLFNBQUw7O0FBQ0FPLG1CQUFNRCxNQUFOO0FBQ0QsR0FmWTtBQWdCYk4sRUFBQUEsU0FoQmEsdUJBZ0JEO0FBQUE7O0FBQ1YsU0FBS0YsUUFBTCxDQUFjVSxRQUFkLENBQXVCLFdBQXZCO0FBQ0EsU0FBS1osWUFBTCxDQUFrQmEsV0FBbEIsQ0FBOEIsUUFBOUI7QUFFQUMsSUFBQUEsVUFBVSxDQUFDLFlBQU07QUFDZixNQUFBLEtBQUksQ0FBQ2QsWUFBTCxDQUFrQlksUUFBbEIsQ0FBMkIsV0FBM0I7QUFDRCxLQUZTLEVBRVAsSUFGTyxDQUFWO0FBR0QsR0F2Qlk7QUF3QmJHLEVBQUFBLElBeEJhLGtCQXdCTjtBQUFBOztBQUNMQyxtQkFBTUQsSUFBTjs7QUFDQUUsb0JBQVdGLElBQVg7O0FBRUEsU0FBS2YsWUFBTCxDQUFrQmtCLEVBQWxCLENBQXFCLE9BQXJCLEVBQThCLGNBQTlCLEVBQThDLFVBQUNDLEtBQUQsRUFBVztBQUN2RCxVQUFNQyxRQUFRLEdBQUduQixDQUFDLENBQUNrQixLQUFLLENBQUNFLGFBQVAsQ0FBbEI7QUFDQSxVQUFNQyxJQUFJLEdBQUdGLFFBQVEsQ0FBQ0csSUFBVCxDQUFjLFdBQWQsQ0FBYjtBQUVBSixNQUFBQSxLQUFLLENBQUNLLGNBQU47O0FBRUEsVUFBSUYsSUFBSixFQUFVO0FBQ1IsUUFBQSxNQUFJLENBQUNBLElBQUQsQ0FBSjtBQUNEO0FBQ0YsS0FURDtBQVdBLFNBQUtwQixRQUFMLENBQWNnQixFQUFkLENBQWlCLE9BQWpCLEVBQTBCLFVBQUNDLEtBQUQsRUFBVztBQUNuQyxVQUFJLE1BQUksQ0FBQ25CLFlBQUwsQ0FBa0J5QixRQUFsQixDQUEyQixRQUEzQixDQUFKLEVBQTBDO0FBQ3hDLFFBQUEsTUFBSSxDQUFDckIsU0FBTDtBQUNEO0FBQ0YsS0FKRDtBQUtEO0FBNUNZLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9naW4gZnJvbSAnLi4vbG9naW4vbG9naW4nO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uL21vZGFsL21vZGFsJztcbmltcG9ydCBFcnJvck1vZGFsIGZyb20gJy4uL2Vycm9yTW9kYWwvbW9kYWwnO1xuaW1wb3J0IFZpZXdlciBmcm9tICcuLi92aWV3ZXIvdmlld2VyJztcbmltcG9ydCB7bWVhc3VyZW1lbnRzREIsIGdldFVVSUR9IGZyb20gJy4uL2RiL2RiJztcbmltcG9ydCB7dXNlcm5hbWV9IGZyb20gJy4uL2xvZ2luL2xvZ2luJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAkbWVudVdyYXBwZXI6ICQoJy5tZW51LXdyYXBwZXInKSxcbiAgJG92ZXJsYXk6ICQoJy5sb2FkaW5nLW92ZXJsYXknKSxcblxuICBzdWJtaXQoKSB7XG4gICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICBDb21tYW5kcy5zYXZlKCk7XG4gIH0sXG4gIG5leHRDYXNlKCkge1xuICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgVmlld2VyLmdldE5leHRDYXNlKCk7XG4gIH0sXG4gIGxvZ291dCgpe1xuICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgTG9naW4ubG9nb3V0KCk7XG4gIH0sXG4gIGNsb3NlTWVudSgpIHtcbiAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICB0aGlzLiRtZW51V3JhcHBlci5yZW1vdmVDbGFzcygnb3BlbmVkJyk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuJG1lbnVXcmFwcGVyLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICB9LCAxMjAwKTtcbiAgfSxcbiAgaW5pdCgpIHtcbiAgICBNb2RhbC5pbml0KCk7XG4gICAgRXJyb3JNb2RhbC5pbml0KCk7XG5cbiAgICB0aGlzLiRtZW51V3JhcHBlci5vbignY2xpY2snLCAnYVtkYXRhLW1lbnVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCAkZWxlbWVudCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICBjb25zdCBtZW51ID0gJGVsZW1lbnQuYXR0cignZGF0YS1tZW51Jyk7XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChtZW51KSB7XG4gICAgICAgIHRoaXNbbWVudV0oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJG92ZXJsYXkub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy4kbWVudVdyYXBwZXIuaGFzQ2xhc3MoJ29wZW5lZCcpKSB7XG4gICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==
},{"../db/db":20,"../errorModal/modal":21,"../login/login":23,"../modal/modal":25,"../viewer/viewer":32}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _login = _interopRequireDefault(require("../login/login"));

var _viewer = _interopRequireDefault(require("../viewer/viewer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  $modal: $('.modal'),
  $overlay: $('.loading-overlay'),
  logout: function logout() {
    this.$modal.removeClass('show');
    this.$overlay.addClass('invisible');

    _login.default.logout();
  },
  show: function show() {
    this.$modal.addClass('show');
    this.$overlay.removeClass('invisible');
  },
  hide: function hide() {
    this.$modal.removeClass('show');
    this.$overlay.addClass('invisible');
  },
  init: function init() {
    var _this = this;

    this.$modal.find('.logout').on('click', function () {
      return _this.logout();
    });
    this.$modal.find('.next-case').on('click', function () {
      return _this.nextCase();
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGFsLmpzIl0sIm5hbWVzIjpbIiRtb2RhbCIsIiQiLCIkb3ZlcmxheSIsImxvZ291dCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJMb2dpbiIsInNob3ciLCJoaWRlIiwiaW5pdCIsImZpbmQiLCJvbiIsIm5leHRDYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7Ozs7ZUFFZTtBQUNiQSxFQUFBQSxNQUFNLEVBQUVDLENBQUMsQ0FBQyxRQUFELENBREk7QUFFYkMsRUFBQUEsUUFBUSxFQUFFRCxDQUFDLENBQUMsa0JBQUQsQ0FGRTtBQUdiRSxFQUFBQSxNQUhhLG9CQUdKO0FBQ1AsU0FBS0gsTUFBTCxDQUFZSSxXQUFaLENBQXdCLE1BQXhCO0FBQ0EsU0FBS0YsUUFBTCxDQUFjRyxRQUFkLENBQXVCLFdBQXZCOztBQUVBQyxtQkFBTUgsTUFBTjtBQUNELEdBUlk7QUFTYkksRUFBQUEsSUFUYSxrQkFTTjtBQUNMLFNBQUtQLE1BQUwsQ0FBWUssUUFBWixDQUFxQixNQUFyQjtBQUNBLFNBQUtILFFBQUwsQ0FBY0UsV0FBZCxDQUEwQixXQUExQjtBQUNELEdBWlk7QUFhYkksRUFBQUEsSUFiYSxrQkFhTjtBQUNMLFNBQUtSLE1BQUwsQ0FBWUksV0FBWixDQUF3QixNQUF4QjtBQUNBLFNBQUtGLFFBQUwsQ0FBY0csUUFBZCxDQUF1QixXQUF2QjtBQUNELEdBaEJZO0FBaUJiSSxFQUFBQSxJQWpCYSxrQkFpQk47QUFBQTs7QUFDTCxTQUFLVCxNQUFMLENBQVlVLElBQVosQ0FBaUIsU0FBakIsRUFBNEJDLEVBQTVCLENBQStCLE9BQS9CLEVBQXdDO0FBQUEsYUFBTSxLQUFJLENBQUNSLE1BQUwsRUFBTjtBQUFBLEtBQXhDO0FBQ0EsU0FBS0gsTUFBTCxDQUFZVSxJQUFaLENBQWlCLFlBQWpCLEVBQStCQyxFQUEvQixDQUFrQyxPQUFsQyxFQUEyQztBQUFBLGFBQU0sS0FBSSxDQUFDQyxRQUFMLEVBQU47QUFBQSxLQUEzQztBQUNEO0FBcEJZLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9naW4gZnJvbSAnLi4vbG9naW4vbG9naW4nO1xuaW1wb3J0IFZpZXdlciBmcm9tICcuLi92aWV3ZXIvdmlld2VyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAkbW9kYWw6ICQoJy5tb2RhbCcpLFxuICAkb3ZlcmxheTogJCgnLmxvYWRpbmctb3ZlcmxheScpLFxuICBsb2dvdXQoKSB7XG4gICAgdGhpcy4kbW9kYWwucmVtb3ZlQ2xhc3MoJ3Nob3cnKTtcbiAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpbnZpc2libGUnKTtcblxuICAgIExvZ2luLmxvZ291dCgpO1xuICB9LFxuICBzaG93KCkge1xuICAgIHRoaXMuJG1vZGFsLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgdGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcygnaW52aXNpYmxlJyk7XG4gIH0sXG4gIGhpZGUoKSB7XG4gICAgdGhpcy4kbW9kYWwucmVtb3ZlQ2xhc3MoJ3Nob3cnKTtcbiAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgfSxcbiAgaW5pdCgpIHtcbiAgICB0aGlzLiRtb2RhbC5maW5kKCcubG9nb3V0Jykub24oJ2NsaWNrJywgKCkgPT4gdGhpcy5sb2dvdXQoKSk7XG4gICAgdGhpcy4kbW9kYWwuZmluZCgnLm5leHQtY2FzZScpLm9uKCdjbGljaycsICgpID0+IHRoaXMubmV4dENhc2UoKSk7XG4gIH1cbn1cbiJdfQ==
},{"../login/login":23,"../viewer/viewer":32}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _db = require("../db/db");

var _viewer = _interopRequireDefault(require("../viewer/viewer"));

var _login = _interopRequireDefault(require("../login/login"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Signup =
/*#__PURE__*/
function () {
  function Signup() {
    _classCallCheck(this, Signup);
  }

  _createClass(Signup, [{
    key: "getRandomUsername",
    value: function getRandomUsername() {
      var numOfAdjectives = 0;
      var numOfAnimals = 0;
      var name;
      return _db.adjectivesDB.info().then(function (doc) {
        numOfAdjectives = doc.doc_count; // console.log('numOfAdjectives', numOfAdjectives);

        var rand = Math.floor(numOfAdjectives * Math.random());
        return _db.adjectivesDB.get(rand);
      }).then(function (doc) {
        // console.log(doc.name);
        name = doc.name;
        return _db.animalsDB.info();
      }).then(function (doc) {
        numOfAnimals = doc.doc_count; // console.log('numOfAnimals', numOfAnimals);

        var rand = Math.floor(numOfAnimals * Math.random());
        return _db.animalsDB.get(rand);
      }).then(function (doc) {
        return name + "_".concat(doc.name);
      }).catch(function (err) {
        throw err;
      });
    }
  }, {
    key: "getRandomUsernames",
    value: function getRandomUsernames() {
      var _this = this;

      var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var names = [];
      console.log('num:', num);

      var next = function next() {
        return _this.getRandomUsername().then(function (name) {
          var accept = true;
          names.forEach(function (n) {
            if (n === name) {
              accept = false;
            }
          });

          if (accept) {
            return _db.annotatorsDB.get(name).then(function (user) {
              console.log('username', name, 'already exist in the database');
              return next();
            }).catch(function (err) {
              names.push(name);

              if (names.length !== num) {
                return next();
              }
            });
          } else {
            return next();
          }
        });
      };

      return next().then(function () {
        return names;
      });
    }
  }, {
    key: "createUser",
    value: function createUser(id, data) {
      return new Promise(function (resolve, reject) {
        $.ajax({
          url: "".concat(annotatorURL, "/").concat(id),
          type: 'PUT',
          dataType: 'json',
          data: data,
          success: function success(res) {
            // $loadingImg.addClass('invisible');
            // $signupWrapper.addClass('invisible');
            // Viewer.initViewer();
            resolve(res);
          },
          error: function error(err) {
            console.log(err);
            reject(err);
          }
        });
      });
    }
  }, {
    key: "init",
    value: function init() {
      console.log('Signup.init() is called');
      var $loading = $('.sign form button.submit loading');
      var $signup = $('.sign');
      var $overlay = $('.loading-overlay');
      $overlay.removeClass('invisible').addClass('loading');
      this.getRandomUsernames(4).then(function (names) {
        // console.log('usernames:', names);
        $overlay.removeClass('loading').addClass('invisible');
        $signup.removeClass('invisible');
        $('#signup-name-select').append("<option value=".concat(names[0], ">").concat(names[0], "</option>"));
        $('#signup-name-select').append("<option value=".concat(names[1], ">").concat(names[1], "</option>"));
        $('#signup-name-select').append("<option value=".concat(names[2], ">").concat(names[2], "</option>"));
        $('#signup-name-select').append("<option value=".concat(names[3], ">").concat(names[3], "</option>"));
      });
      var radiologist = $('input[name="is-radiologist"]');
      $(radiologist).change(function () {
        var isChecked = radiologist.is(':checked'); // console.log('isChecked:', isChecked);

        if (isChecked) {
          var isRadiologist = $('input[name="is-radiologist"]:checked').val() === 'yes'; // console.log('isRadiologist:', isRadiologist);

          if (isRadiologist) {
            if (!$('.speciality').hasClass('invisible')) {
              $('.speciality').addClass('invisible');
            }

            $('.years-of-experience').removeClass('invisible');
          } else {
            if (!$('.years-of-experience').hasClass('invisible')) {
              $('.years-of-experience').addClass('invisible');
            }

            $('.speciality').removeClass('invisible');
          }
        }
      }); // $('input[name="years-of-experience"]').focus(function() {
      //   console.log('years of exp');
      //   if(!$('.sign .error').hasClass('invisible')){
      //     $('.sign .error').text('');
      //     $('.sign .error').addClass('invisible');
      //   }
      // });

      $('.sign form').off('submit').on('submit', function (event) {
        event.preventDefault();
        $loading.removeClass('invisible'); // $('.sign .error').addClass('invisible');

        var username = $('#signup-name-select option:selected').text();
        _login.default.username = username; // console.log('signup Login:', Login);
        // const username = $('input[name="username"]').val();
        // const password = $('input[name="password"]').val();
        // const confirmPassword = $('input[name="confirm-password"]').val();

        var isRadiologist = $('input[name="is-radiologist"]:checked').val() === 'yes'; // const isChecked = $('input:radio[name="is-radiologist"]').is(':checked');
        // const isRadiologist2 = $('#radiologist-no').val();

        var yearsOfExperience;
        var speciality;
        var anatomyChoices = [];

        if (isRadiologist) {
          yearsOfExperience = $('#signup-years-of-experience option:selected').val();
        } else {
          speciality = $('#signup-speciality option:selected').val();
        }

        $("#anatomy-choices input:checkbox[name=anatomy-choice]:checked").each(function () {
          anatomyChoices.push($(this).val());
        });
        var email = $('#signup-email').val();
        console.log('email:', email); // if(isRadiologist && isNaN(yearsOfExperience)){
        //     $('.sign .error').removeClass('invisible');
        //     $('.sign .error').text('"Years of exprience" must be a number');
        //
        //     $('input[name="years-of-experience"]').val('');
        //
        //     $('#signup-button').blur();
        //
        //     $loadingImg.addClass('invisible');
        //
        //     return false;
        // }
        // var values = $(this).serializeArray();
        // console.log('values', values);
        // if(password !== confirmPassword){
        //   $('.sign .error').removeClass('invisible');
        //   $('.sign .error').text('Passwords don\'t match');
        //
        //   const password = $('#signup-password').val('');
        //   const confirmPassword = $('#signup-confirm-password').val('');
        //
        //   $('#signup-button').blur();
        //
        //   $loadingImg.addClass('invisible');
        //
        // }

        var createDate = Date.now();
        var data = {
          _id: username,
          username: username,
          // password,
          isRadiologist: isRadiologist,
          anatomyChoices: anatomyChoices,
          createDate: createDate
        };
        window.localStorage.setItem('username', username);

        if (speciality) {
          data.speciality = speciality;
        }

        if (yearsOfExperience) {
          data.yearsOfExperience = yearsOfExperience;
        }

        if (email) {
          data.email = email;
        }

        if (anatomyChoices && anatomyChoices.length > 0) {
          data.anatomyChoices = anatomyChoices;
        }

        _db.annotatorsDB.put(data).then(function (res) {
          _login.default.user = data;
          console.log('Login.user is: ', _login.default.user);
          $('#username-bottom-left').text(_login.default.username);
          $loading.addClass('invisible');
          $signup.addClass('invisible');

          _viewer.default.initViewer();
        });
      });
    }
  }]);

  return Signup;
}();

var _default = Signup;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNpZ251cC5qcyJdLCJuYW1lcyI6WyJTaWdudXAiLCJudW1PZkFkamVjdGl2ZXMiLCJudW1PZkFuaW1hbHMiLCJuYW1lIiwiYWRqZWN0aXZlc0RCIiwiaW5mbyIsInRoZW4iLCJkb2MiLCJkb2NfY291bnQiLCJyYW5kIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZ2V0IiwiYW5pbWFsc0RCIiwiY2F0Y2giLCJlcnIiLCJudW0iLCJuYW1lcyIsImNvbnNvbGUiLCJsb2ciLCJuZXh0IiwiZ2V0UmFuZG9tVXNlcm5hbWUiLCJhY2NlcHQiLCJmb3JFYWNoIiwibiIsImFubm90YXRvcnNEQiIsInVzZXIiLCJwdXNoIiwibGVuZ3RoIiwiaWQiLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCIkIiwiYWpheCIsInVybCIsImFubm90YXRvclVSTCIsInR5cGUiLCJkYXRhVHlwZSIsInN1Y2Nlc3MiLCJyZXMiLCJlcnJvciIsIiRsb2FkaW5nIiwiJHNpZ251cCIsIiRvdmVybGF5IiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsImdldFJhbmRvbVVzZXJuYW1lcyIsImFwcGVuZCIsInJhZGlvbG9naXN0IiwiY2hhbmdlIiwiaXNDaGVja2VkIiwiaXMiLCJpc1JhZGlvbG9naXN0IiwidmFsIiwiaGFzQ2xhc3MiLCJvZmYiLCJvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJ1c2VybmFtZSIsInRleHQiLCJMb2dpbiIsInllYXJzT2ZFeHBlcmllbmNlIiwic3BlY2lhbGl0eSIsImFuYXRvbXlDaG9pY2VzIiwiZWFjaCIsImVtYWlsIiwiY3JlYXRlRGF0ZSIsIkRhdGUiLCJub3ciLCJfaWQiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicHV0IiwiVmlld2VyIiwiaW5pdFZpZXdlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0lBRU1BLE07OztBQUVKLG9CQUFlO0FBQUE7QUFFZDs7Ozt3Q0FFb0I7QUFDbkIsVUFBSUMsZUFBZSxHQUFHLENBQXRCO0FBQ0EsVUFBSUMsWUFBWSxHQUFHLENBQW5CO0FBQ0EsVUFBSUMsSUFBSjtBQUVBLGFBQU9DLGlCQUFhQyxJQUFiLEdBQW9CQyxJQUFwQixDQUF5QixVQUFDQyxHQUFELEVBQVM7QUFDdkNOLFFBQUFBLGVBQWUsR0FBR00sR0FBRyxDQUFDQyxTQUF0QixDQUR1QyxDQUV2Qzs7QUFDQSxZQUFNQyxJQUFJLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXVixlQUFlLEdBQUNTLElBQUksQ0FBQ0UsTUFBTCxFQUEzQixDQUFiO0FBQ0EsZUFBT1IsaUJBQWFTLEdBQWIsQ0FBaUJKLElBQWpCLENBQVA7QUFDRCxPQUxNLEVBS0pILElBTEksQ0FLQyxVQUFDQyxHQUFELEVBQVM7QUFDZjtBQUNBSixRQUFBQSxJQUFJLEdBQUdJLEdBQUcsQ0FBQ0osSUFBWDtBQUNBLGVBQU9XLGNBQVVULElBQVYsRUFBUDtBQUNELE9BVE0sRUFTSkMsSUFUSSxDQVNDLFVBQUNDLEdBQUQsRUFBUztBQUNmTCxRQUFBQSxZQUFZLEdBQUdLLEdBQUcsQ0FBQ0MsU0FBbkIsQ0FEZSxDQUVmOztBQUNBLFlBQU1DLElBQUksR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdULFlBQVksR0FBQ1EsSUFBSSxDQUFDRSxNQUFMLEVBQXhCLENBQWI7QUFDQSxlQUFPRSxjQUFVRCxHQUFWLENBQWNKLElBQWQsQ0FBUDtBQUNELE9BZE0sRUFjSkgsSUFkSSxDQWNDLFVBQUNDLEdBQUQsRUFBUztBQUNmLGVBQU9KLElBQUksY0FBT0ksR0FBRyxDQUFDSixJQUFYLENBQVg7QUFDRCxPQWhCTSxFQWdCSlksS0FoQkksQ0FnQkUsVUFBQ0MsR0FBRCxFQUFTO0FBQ2hCLGNBQU1BLEdBQU47QUFDRCxPQWxCTSxDQUFQO0FBbUJEOzs7eUNBRTBCO0FBQUE7O0FBQUEsVUFBUEMsR0FBTyx1RUFBSCxDQUFHO0FBQ3pCLFVBQU1DLEtBQUssR0FBRyxFQUFkO0FBQ0FDLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLE1BQVosRUFBb0JILEdBQXBCOztBQUVBLFVBQU1JLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQU07QUFDakIsZUFBTyxLQUFJLENBQUNDLGlCQUFMLEdBQXlCaEIsSUFBekIsQ0FBOEIsVUFBQ0gsSUFBRCxFQUFVO0FBQzdDLGNBQUlvQixNQUFNLEdBQUcsSUFBYjtBQUNBTCxVQUFBQSxLQUFLLENBQUNNLE9BQU4sQ0FBYyxVQUFDQyxDQUFELEVBQU87QUFDbkIsZ0JBQUdBLENBQUMsS0FBS3RCLElBQVQsRUFBYztBQUNab0IsY0FBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDRDtBQUNGLFdBSkQ7O0FBTUEsY0FBR0EsTUFBSCxFQUFVO0FBQ1IsbUJBQU9HLGlCQUFhYixHQUFiLENBQWlCVixJQUFqQixFQUF1QkcsSUFBdkIsQ0FBNEIsVUFBQ3FCLElBQUQsRUFBVTtBQUMzQ1IsY0FBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksVUFBWixFQUF3QmpCLElBQXhCLEVBQThCLCtCQUE5QjtBQUVBLHFCQUFPa0IsSUFBSSxFQUFYO0FBQ0QsYUFKTSxFQUlKTixLQUpJLENBSUUsVUFBQ0MsR0FBRCxFQUFTO0FBQ2hCRSxjQUFBQSxLQUFLLENBQUNVLElBQU4sQ0FBV3pCLElBQVg7O0FBRUEsa0JBQUdlLEtBQUssQ0FBQ1csTUFBTixLQUFpQlosR0FBcEIsRUFBd0I7QUFDdEIsdUJBQU9JLElBQUksRUFBWDtBQUNEO0FBQ0YsYUFWTSxDQUFQO0FBV0QsV0FaRCxNQVlLO0FBQ0gsbUJBQU9BLElBQUksRUFBWDtBQUNEO0FBQ0YsU0F2Qk0sQ0FBUDtBQXdCRCxPQXpCRDs7QUEyQkEsYUFBT0EsSUFBSSxHQUFHZixJQUFQLENBQVksWUFBTTtBQUN2QixlQUFPWSxLQUFQO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7OzsrQkFFV1ksRSxFQUFJQyxJLEVBQU07QUFDcEIsYUFBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDQyxRQUFBQSxDQUFDLENBQUNDLElBQUYsQ0FBTztBQUNMQyxVQUFBQSxHQUFHLFlBQUtDLFlBQUwsY0FBcUJSLEVBQXJCLENBREU7QUFFTFMsVUFBQUEsSUFBSSxFQUFFLEtBRkQ7QUFHTEMsVUFBQUEsUUFBUSxFQUFFLE1BSEw7QUFJTFQsVUFBQUEsSUFBSSxFQUFFQSxJQUpEO0FBS0xVLFVBQUFBLE9BQU8sRUFBRSxpQkFBU0MsR0FBVCxFQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBVCxZQUFBQSxPQUFPLENBQUNTLEdBQUQsQ0FBUDtBQUNELFdBVkk7QUFXTEMsVUFBQUEsS0FBSyxFQUFFLGVBQVMzQixHQUFULEVBQWE7QUFDbEJHLFlBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZSixHQUFaO0FBQ0FrQixZQUFBQSxNQUFNLENBQUNsQixHQUFELENBQU47QUFDRDtBQWRJLFNBQVA7QUFnQkQsT0FqQk0sQ0FBUDtBQWtCRDs7OzJCQUVPO0FBQ05HLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLHlCQUFaO0FBQ0EsVUFBSXdCLFFBQVEsR0FBR1QsQ0FBQyxDQUFDLGtDQUFELENBQWhCO0FBQ0EsVUFBSVUsT0FBTyxHQUFHVixDQUFDLENBQUMsT0FBRCxDQUFmO0FBQ0EsVUFBSVcsUUFBUSxHQUFHWCxDQUFDLENBQUMsa0JBQUQsQ0FBaEI7QUFFQVcsTUFBQUEsUUFBUSxDQUFDQyxXQUFULENBQXFCLFdBQXJCLEVBQWtDQyxRQUFsQyxDQUEyQyxTQUEzQztBQUVBLFdBQUtDLGtCQUFMLENBQXdCLENBQXhCLEVBQTJCM0MsSUFBM0IsQ0FBZ0MsVUFBQ1ksS0FBRCxFQUFXO0FBQ3pDO0FBQ0E0QixRQUFBQSxRQUFRLENBQUNDLFdBQVQsQ0FBcUIsU0FBckIsRUFBZ0NDLFFBQWhDLENBQXlDLFdBQXpDO0FBQ0FILFFBQUFBLE9BQU8sQ0FBQ0UsV0FBUixDQUFvQixXQUFwQjtBQUVBWixRQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QmUsTUFBekIseUJBQWlEaEMsS0FBSyxDQUFDLENBQUQsQ0FBdEQsY0FBNkRBLEtBQUssQ0FBQyxDQUFELENBQWxFO0FBQ0FpQixRQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QmUsTUFBekIseUJBQWlEaEMsS0FBSyxDQUFDLENBQUQsQ0FBdEQsY0FBNkRBLEtBQUssQ0FBQyxDQUFELENBQWxFO0FBQ0FpQixRQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QmUsTUFBekIseUJBQWlEaEMsS0FBSyxDQUFDLENBQUQsQ0FBdEQsY0FBNkRBLEtBQUssQ0FBQyxDQUFELENBQWxFO0FBQ0FpQixRQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QmUsTUFBekIseUJBQWlEaEMsS0FBSyxDQUFDLENBQUQsQ0FBdEQsY0FBNkRBLEtBQUssQ0FBQyxDQUFELENBQWxFO0FBQ0QsT0FURDtBQVdBLFVBQU1pQyxXQUFXLEdBQUdoQixDQUFDLENBQUMsOEJBQUQsQ0FBckI7QUFDQUEsTUFBQUEsQ0FBQyxDQUFDZ0IsV0FBRCxDQUFELENBQWVDLE1BQWYsQ0FBc0IsWUFBTTtBQUMxQixZQUFNQyxTQUFTLEdBQUdGLFdBQVcsQ0FBQ0csRUFBWixDQUFlLFVBQWYsQ0FBbEIsQ0FEMEIsQ0FFMUI7O0FBQ0EsWUFBR0QsU0FBSCxFQUFjO0FBQ1osY0FBTUUsYUFBYSxHQUFJcEIsQ0FBQyxDQUFDLHNDQUFELENBQUQsQ0FBMENxQixHQUExQyxPQUFvRCxLQUEzRSxDQURZLENBRVo7O0FBQ0EsY0FBR0QsYUFBSCxFQUFpQjtBQUNmLGdCQUFHLENBQUNwQixDQUFDLENBQUMsYUFBRCxDQUFELENBQWlCc0IsUUFBakIsQ0FBMEIsV0FBMUIsQ0FBSixFQUEyQztBQUN6Q3RCLGNBQUFBLENBQUMsQ0FBQyxhQUFELENBQUQsQ0FBaUJhLFFBQWpCLENBQTBCLFdBQTFCO0FBQ0Q7O0FBQ0RiLFlBQUFBLENBQUMsQ0FBQyxzQkFBRCxDQUFELENBQTBCWSxXQUExQixDQUFzQyxXQUF0QztBQUNELFdBTEQsTUFLSztBQUNILGdCQUFHLENBQUNaLENBQUMsQ0FBQyxzQkFBRCxDQUFELENBQTBCc0IsUUFBMUIsQ0FBbUMsV0FBbkMsQ0FBSixFQUFvRDtBQUNsRHRCLGNBQUFBLENBQUMsQ0FBQyxzQkFBRCxDQUFELENBQTBCYSxRQUExQixDQUFtQyxXQUFuQztBQUNEOztBQUNEYixZQUFBQSxDQUFDLENBQUMsYUFBRCxDQUFELENBQWlCWSxXQUFqQixDQUE2QixXQUE3QjtBQUNEO0FBQ0Y7QUFDRixPQWxCRCxFQXBCTSxDQXlDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQVosTUFBQUEsQ0FBQyxDQUFDLFlBQUQsQ0FBRCxDQUFnQnVCLEdBQWhCLENBQW9CLFFBQXBCLEVBQThCQyxFQUE5QixDQUFpQyxRQUFqQyxFQUEyQyxVQUFVQyxLQUFWLEVBQWlCO0FBQzFEQSxRQUFBQSxLQUFLLENBQUNDLGNBQU47QUFFQWpCLFFBQUFBLFFBQVEsQ0FBQ0csV0FBVCxDQUFxQixXQUFyQixFQUgwRCxDQUkxRDs7QUFFQSxZQUFNZSxRQUFRLEdBQUczQixDQUFDLENBQUMscUNBQUQsQ0FBRCxDQUF5QzRCLElBQXpDLEVBQWpCO0FBQ0FDLHVCQUFNRixRQUFOLEdBQWlCQSxRQUFqQixDQVAwRCxDQVExRDtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxZQUFNUCxhQUFhLEdBQUlwQixDQUFDLENBQUMsc0NBQUQsQ0FBRCxDQUEwQ3FCLEdBQTFDLE9BQW9ELEtBQTNFLENBWjBELENBYTFEO0FBQ0E7O0FBQ0EsWUFBSVMsaUJBQUo7QUFDQSxZQUFJQyxVQUFKO0FBQ0EsWUFBSUMsY0FBYyxHQUFHLEVBQXJCOztBQUVBLFlBQUdaLGFBQUgsRUFBaUI7QUFDZlUsVUFBQUEsaUJBQWlCLEdBQUc5QixDQUFDLENBQUMsNkNBQUQsQ0FBRCxDQUFpRHFCLEdBQWpELEVBQXBCO0FBQ0QsU0FGRCxNQUVLO0FBQ0hVLFVBQUFBLFVBQVUsR0FBRy9CLENBQUMsQ0FBQyxvQ0FBRCxDQUFELENBQXdDcUIsR0FBeEMsRUFBYjtBQUNEOztBQUVEckIsUUFBQUEsQ0FBQyxDQUFDLDhEQUFELENBQUQsQ0FBa0VpQyxJQUFsRSxDQUF1RSxZQUFVO0FBQzdFRCxVQUFBQSxjQUFjLENBQUN2QyxJQUFmLENBQW9CTyxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFxQixHQUFSLEVBQXBCO0FBQ0gsU0FGRDtBQUlBLFlBQU1hLEtBQUssR0FBR2xDLENBQUMsQ0FBQyxlQUFELENBQUQsQ0FBbUJxQixHQUFuQixFQUFkO0FBQ0FyQyxRQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxRQUFaLEVBQXNCaUQsS0FBdEIsRUE5QjBELENBZ0MxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFlBQUlDLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLEVBQWpCO0FBQ0EsWUFBTXpDLElBQUksR0FBRztBQUNYMEMsVUFBQUEsR0FBRyxFQUFFWCxRQURNO0FBRVhBLFVBQUFBLFFBQVEsRUFBUkEsUUFGVztBQUdYO0FBQ0FQLFVBQUFBLGFBQWEsRUFBYkEsYUFKVztBQUtYWSxVQUFBQSxjQUFjLEVBQWRBLGNBTFc7QUFNWEcsVUFBQUEsVUFBVSxFQUFWQTtBQU5XLFNBQWI7QUFRQUksUUFBQUEsTUFBTSxDQUFDQyxZQUFQLENBQW9CQyxPQUFwQixDQUE0QixVQUE1QixFQUF3Q2QsUUFBeEM7O0FBRUEsWUFBR0ksVUFBSCxFQUFjO0FBQ1puQyxVQUFBQSxJQUFJLENBQUNtQyxVQUFMLEdBQWtCQSxVQUFsQjtBQUNEOztBQUVELFlBQUdELGlCQUFILEVBQXFCO0FBQ25CbEMsVUFBQUEsSUFBSSxDQUFDa0MsaUJBQUwsR0FBeUJBLGlCQUF6QjtBQUNEOztBQUVELFlBQUdJLEtBQUgsRUFBUztBQUNQdEMsVUFBQUEsSUFBSSxDQUFDc0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0Q7O0FBRUQsWUFBSUYsY0FBYyxJQUFJQSxjQUFjLENBQUN0QyxNQUFmLEdBQXdCLENBQTlDLEVBQWlEO0FBQy9DRSxVQUFBQSxJQUFJLENBQUNvQyxjQUFMLEdBQXNCQSxjQUF0QjtBQUNEOztBQUVEekMseUJBQWFtRCxHQUFiLENBQWlCOUMsSUFBakIsRUFBdUJ6QixJQUF2QixDQUE0QixVQUFDb0MsR0FBRCxFQUFTO0FBQ25Dc0IseUJBQU1yQyxJQUFOLEdBQWFJLElBQWI7QUFDQVosVUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksaUJBQVosRUFBK0I0QyxlQUFNckMsSUFBckM7QUFDQVEsVUFBQUEsQ0FBQyxDQUFDLHVCQUFELENBQUQsQ0FBMkI0QixJQUEzQixDQUFnQ0MsZUFBTUYsUUFBdEM7QUFDQWxCLFVBQUFBLFFBQVEsQ0FBQ0ksUUFBVCxDQUFrQixXQUFsQjtBQUNBSCxVQUFBQSxPQUFPLENBQUNHLFFBQVIsQ0FBaUIsV0FBakI7O0FBRUE4QiwwQkFBT0MsVUFBUDtBQUNELFNBUkQ7QUFTRCxPQWhHRDtBQWlHRDs7Ozs7O2VBR1kvRSxNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthZGplY3RpdmVzREIsIGFuaW1hbHNEQiwgYW5ub3RhdG9yc0RCLCBhbm5vdGF0b3JzVVJMfSBmcm9tICcuLi9kYi9kYic7XG5pbXBvcnQgVmlld2VyIGZyb20gJy4uL3ZpZXdlci92aWV3ZXInO1xuaW1wb3J0IExvZ2luIGZyb20gJy4uL2xvZ2luL2xvZ2luJztcblxuY2xhc3MgU2lnbnVwIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG5cbiAgfVxuXG4gIGdldFJhbmRvbVVzZXJuYW1lICgpIHtcbiAgICBsZXQgbnVtT2ZBZGplY3RpdmVzID0gMDtcbiAgICBsZXQgbnVtT2ZBbmltYWxzID0gMDtcbiAgICBsZXQgbmFtZTtcblxuICAgIHJldHVybiBhZGplY3RpdmVzREIuaW5mbygpLnRoZW4oKGRvYykgPT4ge1xuICAgICAgbnVtT2ZBZGplY3RpdmVzID0gZG9jLmRvY19jb3VudDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdudW1PZkFkamVjdGl2ZXMnLCBudW1PZkFkamVjdGl2ZXMpO1xuICAgICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IobnVtT2ZBZGplY3RpdmVzKk1hdGgucmFuZG9tKCkpO1xuICAgICAgcmV0dXJuIGFkamVjdGl2ZXNEQi5nZXQocmFuZCk7XG4gICAgfSkudGhlbigoZG9jKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gICAgICBuYW1lID0gZG9jLm5hbWU7XG4gICAgICByZXR1cm4gYW5pbWFsc0RCLmluZm8oKTtcbiAgICB9KS50aGVuKChkb2MpID0+IHtcbiAgICAgIG51bU9mQW5pbWFscyA9IGRvYy5kb2NfY291bnQ7XG4gICAgICAvLyBjb25zb2xlLmxvZygnbnVtT2ZBbmltYWxzJywgbnVtT2ZBbmltYWxzKTtcbiAgICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKG51bU9mQW5pbWFscypNYXRoLnJhbmRvbSgpKTtcbiAgICAgIHJldHVybiBhbmltYWxzREIuZ2V0KHJhbmQpO1xuICAgIH0pLnRoZW4oKGRvYykgPT4ge1xuICAgICAgcmV0dXJuIG5hbWUgKyBgXyR7ZG9jLm5hbWV9YDtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cblxuICBnZXRSYW5kb21Vc2VybmFtZXMgKG51bT0wKSB7XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBjb25zb2xlLmxvZygnbnVtOicsIG51bSk7XG5cbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZG9tVXNlcm5hbWUoKS50aGVuKChuYW1lKSA9PiB7XG4gICAgICAgIGxldCBhY2NlcHQgPSB0cnVlO1xuICAgICAgICBuYW1lcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgICAgaWYobiA9PT0gbmFtZSl7XG4gICAgICAgICAgICBhY2NlcHQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGFjY2VwdCl7XG4gICAgICAgICAgcmV0dXJuIGFubm90YXRvcnNEQi5nZXQobmFtZSkudGhlbigodXNlcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VzZXJuYW1lJywgbmFtZSwgJ2FscmVhZHkgZXhpc3QgaW4gdGhlIGRhdGFiYXNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lKTtcblxuICAgICAgICAgICAgaWYobmFtZXMubGVuZ3RoICE9PSBudW0pe1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlVXNlciAoaWQsIGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiBgJHthbm5vdGF0b3JVUkx9LyR7aWR9YCxcbiAgICAgICAgdHlwZTogJ1BVVCcsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgLy8gJGxvYWRpbmdJbWcuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgICAgIC8vICRzaWdudXBXcmFwcGVyLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgICAvLyBWaWV3ZXIuaW5pdFZpZXdlcigpO1xuICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0ICgpIHtcbiAgICBjb25zb2xlLmxvZygnU2lnbnVwLmluaXQoKSBpcyBjYWxsZWQnKTtcbiAgICB2YXIgJGxvYWRpbmcgPSAkKCcuc2lnbiBmb3JtIGJ1dHRvbi5zdWJtaXQgbG9hZGluZycpO1xuICAgIHZhciAkc2lnbnVwID0gJCgnLnNpZ24nKTtcbiAgICB2YXIgJG92ZXJsYXkgPSAkKCcubG9hZGluZy1vdmVybGF5Jyk7XG5cbiAgICAkb3ZlcmxheS5yZW1vdmVDbGFzcygnaW52aXNpYmxlJykuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblxuICAgIHRoaXMuZ2V0UmFuZG9tVXNlcm5hbWVzKDQpLnRoZW4oKG5hbWVzKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZygndXNlcm5hbWVzOicsIG5hbWVzKTtcbiAgICAgICRvdmVybGF5LnJlbW92ZUNsYXNzKCdsb2FkaW5nJykuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgJHNpZ251cC5yZW1vdmVDbGFzcygnaW52aXNpYmxlJyk7XG5cbiAgICAgICQoJyNzaWdudXAtbmFtZS1zZWxlY3QnKS5hcHBlbmQoYDxvcHRpb24gdmFsdWU9JHtuYW1lc1swXX0+JHtuYW1lc1swXX08L29wdGlvbj5gKTtcbiAgICAgICQoJyNzaWdudXAtbmFtZS1zZWxlY3QnKS5hcHBlbmQoYDxvcHRpb24gdmFsdWU9JHtuYW1lc1sxXX0+JHtuYW1lc1sxXX08L29wdGlvbj5gKTtcbiAgICAgICQoJyNzaWdudXAtbmFtZS1zZWxlY3QnKS5hcHBlbmQoYDxvcHRpb24gdmFsdWU9JHtuYW1lc1syXX0+JHtuYW1lc1syXX08L29wdGlvbj5gKTtcbiAgICAgICQoJyNzaWdudXAtbmFtZS1zZWxlY3QnKS5hcHBlbmQoYDxvcHRpb24gdmFsdWU9JHtuYW1lc1szXX0+JHtuYW1lc1szXX08L29wdGlvbj5gKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJhZGlvbG9naXN0ID0gJCgnaW5wdXRbbmFtZT1cImlzLXJhZGlvbG9naXN0XCJdJyk7XG4gICAgJChyYWRpb2xvZ2lzdCkuY2hhbmdlKCgpID0+IHtcbiAgICAgIGNvbnN0IGlzQ2hlY2tlZCA9IHJhZGlvbG9naXN0LmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2lzQ2hlY2tlZDonLCBpc0NoZWNrZWQpO1xuICAgICAgaWYoaXNDaGVja2VkKSB7XG4gICAgICAgIGNvbnN0IGlzUmFkaW9sb2dpc3QgPSAoJCgnaW5wdXRbbmFtZT1cImlzLXJhZGlvbG9naXN0XCJdOmNoZWNrZWQnKS52YWwoKSA9PT0gJ3llcycpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXNSYWRpb2xvZ2lzdDonLCBpc1JhZGlvbG9naXN0KTtcbiAgICAgICAgaWYoaXNSYWRpb2xvZ2lzdCl7XG4gICAgICAgICAgaWYoISQoJy5zcGVjaWFsaXR5JykuaGFzQ2xhc3MoJ2ludmlzaWJsZScpKXtcbiAgICAgICAgICAgICQoJy5zcGVjaWFsaXR5JykuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkKCcueWVhcnMtb2YtZXhwZXJpZW5jZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgaWYoISQoJy55ZWFycy1vZi1leHBlcmllbmNlJykuaGFzQ2xhc3MoJ2ludmlzaWJsZScpKXtcbiAgICAgICAgICAgICQoJy55ZWFycy1vZi1leHBlcmllbmNlJykuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkKCcuc3BlY2lhbGl0eScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyAkKCdpbnB1dFtuYW1lPVwieWVhcnMtb2YtZXhwZXJpZW5jZVwiXScpLmZvY3VzKGZ1bmN0aW9uKCkge1xuICAgIC8vICAgY29uc29sZS5sb2coJ3llYXJzIG9mIGV4cCcpO1xuICAgIC8vICAgaWYoISQoJy5zaWduIC5lcnJvcicpLmhhc0NsYXNzKCdpbnZpc2libGUnKSl7XG4gICAgLy8gICAgICQoJy5zaWduIC5lcnJvcicpLnRleHQoJycpO1xuICAgIC8vICAgICAkKCcuc2lnbiAuZXJyb3InKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG5cbiAgICAkKCcuc2lnbiBmb3JtJykub2ZmKCdzdWJtaXQnKS5vbignc3VibWl0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAkbG9hZGluZy5yZW1vdmVDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICAvLyAkKCcuc2lnbiAuZXJyb3InKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG5cbiAgICAgIGNvbnN0IHVzZXJuYW1lID0gJCgnI3NpZ251cC1uYW1lLXNlbGVjdCBvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCk7XG4gICAgICBMb2dpbi51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3NpZ251cCBMb2dpbjonLCBMb2dpbik7XG4gICAgICAvLyBjb25zdCB1c2VybmFtZSA9ICQoJ2lucHV0W25hbWU9XCJ1c2VybmFtZVwiXScpLnZhbCgpO1xuICAgICAgLy8gY29uc3QgcGFzc3dvcmQgPSAkKCdpbnB1dFtuYW1lPVwicGFzc3dvcmRcIl0nKS52YWwoKTtcbiAgICAgIC8vIGNvbnN0IGNvbmZpcm1QYXNzd29yZCA9ICQoJ2lucHV0W25hbWU9XCJjb25maXJtLXBhc3N3b3JkXCJdJykudmFsKCk7XG4gICAgICBjb25zdCBpc1JhZGlvbG9naXN0ID0gKCQoJ2lucHV0W25hbWU9XCJpcy1yYWRpb2xvZ2lzdFwiXTpjaGVja2VkJykudmFsKCkgPT09ICd5ZXMnKTtcbiAgICAgIC8vIGNvbnN0IGlzQ2hlY2tlZCA9ICQoJ2lucHV0OnJhZGlvW25hbWU9XCJpcy1yYWRpb2xvZ2lzdFwiXScpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgLy8gY29uc3QgaXNSYWRpb2xvZ2lzdDIgPSAkKCcjcmFkaW9sb2dpc3Qtbm8nKS52YWwoKTtcbiAgICAgIGxldCB5ZWFyc09mRXhwZXJpZW5jZTtcbiAgICAgIGxldCBzcGVjaWFsaXR5O1xuICAgICAgbGV0IGFuYXRvbXlDaG9pY2VzID0gW107XG5cbiAgICAgIGlmKGlzUmFkaW9sb2dpc3Qpe1xuICAgICAgICB5ZWFyc09mRXhwZXJpZW5jZSA9ICQoJyNzaWdudXAteWVhcnMtb2YtZXhwZXJpZW5jZSBvcHRpb246c2VsZWN0ZWQnKS52YWwoKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzcGVjaWFsaXR5ID0gJCgnI3NpZ251cC1zcGVjaWFsaXR5IG9wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xuICAgICAgfVxuXG4gICAgICAkKFwiI2FuYXRvbXktY2hvaWNlcyBpbnB1dDpjaGVja2JveFtuYW1lPWFuYXRvbXktY2hvaWNlXTpjaGVja2VkXCIpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICBhbmF0b215Q2hvaWNlcy5wdXNoKCQodGhpcykudmFsKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVtYWlsID0gJCgnI3NpZ251cC1lbWFpbCcpLnZhbCgpO1xuICAgICAgY29uc29sZS5sb2coJ2VtYWlsOicsIGVtYWlsKTtcblxuICAgICAgLy8gaWYoaXNSYWRpb2xvZ2lzdCAmJiBpc05hTih5ZWFyc09mRXhwZXJpZW5jZSkpe1xuICAgICAgLy8gICAgICQoJy5zaWduIC5lcnJvcicpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgIC8vICAgICAkKCcuc2lnbiAuZXJyb3InKS50ZXh0KCdcIlllYXJzIG9mIGV4cHJpZW5jZVwiIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgJCgnaW5wdXRbbmFtZT1cInllYXJzLW9mLWV4cGVyaWVuY2VcIl0nKS52YWwoJycpO1xuICAgICAgLy9cbiAgICAgIC8vICAgICAkKCcjc2lnbnVwLWJ1dHRvbicpLmJsdXIoKTtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgJGxvYWRpbmdJbWcuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgLy9cbiAgICAgIC8vICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHZhciB2YWx1ZXMgPSAkKHRoaXMpLnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygndmFsdWVzJywgdmFsdWVzKTtcblxuICAgICAgLy8gaWYocGFzc3dvcmQgIT09IGNvbmZpcm1QYXNzd29yZCl7XG4gICAgICAvLyAgICQoJy5zaWduIC5lcnJvcicpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgIC8vICAgJCgnLnNpZ24gLmVycm9yJykudGV4dCgnUGFzc3dvcmRzIGRvblxcJ3QgbWF0Y2gnKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIGNvbnN0IHBhc3N3b3JkID0gJCgnI3NpZ251cC1wYXNzd29yZCcpLnZhbCgnJyk7XG4gICAgICAvLyAgIGNvbnN0IGNvbmZpcm1QYXNzd29yZCA9ICQoJyNzaWdudXAtY29uZmlybS1wYXNzd29yZCcpLnZhbCgnJyk7XG4gICAgICAvL1xuICAgICAgLy8gICAkKCcjc2lnbnVwLWJ1dHRvbicpLmJsdXIoKTtcbiAgICAgIC8vXG4gICAgICAvLyAgICRsb2FkaW5nSW1nLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgIC8vXG4gICAgICAvLyB9XG4gICAgICB2YXIgY3JlYXRlRGF0ZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBfaWQ6IHVzZXJuYW1lLFxuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgLy8gcGFzc3dvcmQsXG4gICAgICAgIGlzUmFkaW9sb2dpc3QsXG4gICAgICAgIGFuYXRvbXlDaG9pY2VzLFxuICAgICAgICBjcmVhdGVEYXRlXG4gICAgICB9XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJuYW1lJywgdXNlcm5hbWUpO1xuXG4gICAgICBpZihzcGVjaWFsaXR5KXtcbiAgICAgICAgZGF0YS5zcGVjaWFsaXR5ID0gc3BlY2lhbGl0eTtcbiAgICAgIH1cblxuICAgICAgaWYoeWVhcnNPZkV4cGVyaWVuY2Upe1xuICAgICAgICBkYXRhLnllYXJzT2ZFeHBlcmllbmNlID0geWVhcnNPZkV4cGVyaWVuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmKGVtYWlsKXtcbiAgICAgICAgZGF0YS5lbWFpbCA9IGVtYWlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5hdG9teUNob2ljZXMgJiYgYW5hdG9teUNob2ljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkYXRhLmFuYXRvbXlDaG9pY2VzID0gYW5hdG9teUNob2ljZXM7XG4gICAgICB9XG5cbiAgICAgIGFubm90YXRvcnNEQi5wdXQoZGF0YSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIExvZ2luLnVzZXIgPSBkYXRhO1xuICAgICAgICBjb25zb2xlLmxvZygnTG9naW4udXNlciBpczogJywgTG9naW4udXNlcik7XG4gICAgICAgICQoJyN1c2VybmFtZS1ib3R0b20tbGVmdCcpLnRleHQoTG9naW4udXNlcm5hbWUpO1xuICAgICAgICAkbG9hZGluZy5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICAgICRzaWdudXAuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuXG4gICAgICAgIFZpZXdlci5pbml0Vmlld2VyKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaWdudXA7XG4iXX0=
},{"../db/db":20,"../login/login":23,"../viewer/viewer":32}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _menu = _interopRequireDefault(require("../menu/menu.js"));

var _viewer = _interopRequireDefault(require("../viewer/viewer.js"));

var _modal = _interopRequireDefault(require("../errorModal/modal.js"));

var _db = require("../db/db.js");

var _login = _interopRequireDefault(require("../login/login"));

var cornerstone = _interopRequireWildcard(require("cornerstone-core"));

var cornerstoneTools = _interopRequireWildcard(require("cornerstone-tools"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultWlPresets = {
  SoftTissue: {
    wc: 40,
    ww: 400
  },
  Lung: {
    wc: -600,
    ww: 1500
  },
  Liver: {
    wc: 90,
    ww: 150
  }
}; // helper from https://stackoverflow.com/questions/12168909/blob-from-dataurl

function dataURItoBlob(dataURI) {
  // convert base64 to raw binary data held in a string
  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
  var byteString = atob(dataURI.split(',')[1]); // separate out the mime component

  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; // write the bytes of the string to an ArrayBuffer

  var ab = new ArrayBuffer(byteString.length); // create a view into the buffer

  var ia = new Uint8Array(ab); // set the bytes of the buffer to the correct values

  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  } // write the ArrayBuffer to a blob, and you're done


  var blob = new Blob([ab], {
    type: mimeString
  });
  return blob;
}

var _default = {
  isMenuOpened: false,
  commandSelector: '.viewer-tools',
  $overlay: $('.loading-overlay'),
  $loadingText: $('.loading-overlay .content .submit-text'),
  $commandMenu: $('.commands-wrapper'),
  clearAll: function clearAll() {
    // Remove all imageId-specific measurements associated with this element
    cornerstoneTools.globalImageIdSpecificToolStateManager.restoreToolState({}); // Reset the viewport parameters (i.e. VOI LUT, scale, translation)

    cornerstone.reset(this.element);
  },
  skip: function skip() {
    var _this = this;

    this.$overlay.removeClass('invisible').addClass('loading');
    var stack = cornerstoneTools.getToolState(this.element, 'stack');
    (0, _db.getUUID)().then(function (uuid) {
      var sliceIndex = stack.data[0].currentImageIdIndex;
      var doc = {
        '_id': uuid,
        'skip': true,
        'annotator': _login.default.username,
        'seriesUID': window.rsnaCrowdQuantSeriesUID,
        'instanceUID': window.rsnaCrowdQuantCaseStudy.instanceUIDs[sliceIndex],
        'instanceURL': window.rsnaCrowdQuantCaseStudy.urls[sliceIndex],
        'sliceIndex': sliceIndex,
        'date': Math.floor(Date.now() / 1000),
        'userAgent': navigator.userAgent
      };
      return _db.measurementsDB.put(doc);
    });

    _viewer.default.getNextCase().then(function () {
      _this.$overlay.removeClass('loading').addClass('invisible');
    });
  },
  setWL: function setWL(windowWidth, windowCenter) {
    var viewport = cornerstone.getViewport(this.element);
    viewport.voi.windowWidth = windowWidth;
    viewport.voi.windowCenter = windowCenter;
    cornerstone.updateImage(this.element);
  },
  setWLPreset: function setWLPreset(presetName) {
    var preset = defaultWlPresets[presetName];
    this.setWL(preset.ww, preset.wc);
  },
  setWLPresetLung: function setWLPresetLung() {
    this.setWLPreset('Lung');
  },
  setWLPresetLiver: function setWLPresetLiver() {
    this.setWLPreset('Liver');
  },
  setWLPresetSoftTissue: function setWLPresetSoftTissue() {
    this.setWLPreset('SoftTissue');
  },
  toggleMoreMenu: function toggleMoreMenu() {
    var _this2 = this;

    if (this.isMenuOpened) {
      this.$commandMenu.removeClass('open');
      setTimeout(function () {
        _this2.$commandMenu.removeClass('border');
      }, 1100);
    } else {
      this.$commandMenu.addClass('open border');
    }

    this.isMenuOpened = !this.isMenuOpened;
  },
  save: function save() {
    var _this3 = this;

    this.$overlay.removeClass('invisible').addClass('loading');
    this.$loadingText.text('Submitting your measurement...'); // Retrieve the tool state manager for this element

    var toolStateManager = cornerstoneTools.globalImageIdSpecificToolStateManager; // Dump all of its tool state into an Object

    var toolState = toolStateManager.saveToolState(); // Get the stack tool data

    var stackData = cornerstoneTools.getToolState(this.element, 'stack');
    var stack = stackData.data[0]; // Retrieve the length data from this Object

    var lengthData = [];
    Object.keys(toolState).forEach(function (imageId) {
      if (!toolState[imageId]['length'] || !toolState[imageId]['length'].data.length) {
        return;
      }

      lengthData.push({
        imageIndex: stack.imageIds.indexOf(imageId),
        data: toolState[imageId].length
      });
    });

    if (!lengthData.length) {
      // console.log('ErrorModal', ErrorModal);
      _modal.default.show();

      this.$loadingText.text('');
      this.$overlay.removeClass('loading').addClass('invisible');
      return;
    }

    if (lengthData.length > 1) {
      throw new Error('Only one length measurement should be in the lengthData');
    }

    var savingPromise = new Promise(function (resolve, reject) {
      console.time('getUUID');
      (0, _db.getUUID)().then(function (uuid) {
        console.timeEnd('getUUID');
        console.time('PUT to Measurement DB');
        var measurement = lengthData[0];
        var lengthMeasurement = measurement.data.data[0];
        cornerstoneTools.scrollToIndex(_this3.element, measurement.imageIndex);
        var doc = {
          '_id': uuid,
          'length': lengthMeasurement.length,
          'start_x': lengthMeasurement.handles.start.x,
          'start_y': lengthMeasurement.handles.start.y,
          'end_x': lengthMeasurement.handles.end.x,
          'end_y': lengthMeasurement.handles.end.y,
          'windowWidth': lengthMeasurement.windowWidth,
          'windowCenter': lengthMeasurement.windowCenter,
          'scale': lengthMeasurement.scale,
          'translation_x': lengthMeasurement.translation.x,
          'translation_y': lengthMeasurement.translation.y,
          'annotator': _login.default.username,
          'seriesUID': window.rsnaCrowdQuantSeriesUID,
          'instanceUID': window.rsnaCrowdQuantCaseStudy.instanceUIDs[measurement.imageIndex],
          'instanceURL': window.rsnaCrowdQuantCaseStudy.urls[measurement.imageIndex],
          'sliceIndex': measurement.imageIndex,
          'date': Math.floor(Date.now() / 1000),
          'userAgent': navigator.userAgent
        };
        return _db.measurementsDB.put(doc);
      }).then(function (response) {
        console.timeEnd('PUT to Measurement DB');
        console.time('PUT putAttachment');
        var canvas = document.querySelector('#cornerstoneViewport canvas');
        var imageBlob = dataURItoBlob(canvas.toDataURL());
        return _db.measurementsDB.putAttachment(response.id, 'screenshot.png', response.rev, imageBlob, 'image/png');
      }).then(function () {
        console.timeEnd('PUT putAttachment');
        resolve();
      }).catch(function (error) {
        reject(error);
      });
    });

    _viewer.default.getNextCase().then(function () {
      _this3.$loadingText.text('');

      _this3.$overlay.removeClass('loading').addClass('invisible');
    });

    return savingPromise;
  },
  logout: function logout() {
    _login.default.logout();
  },
  initCommands: function initCommands() {
    var _this4 = this;

    $(this.commandSelector).off('click');
    $(this.commandSelector).on('click', 'div[data-command]', function (event) {
      event.preventDefault();
      event.stopPropagation();
      var $element = $(event.currentTarget);
      var tool = $element.attr('data-command');

      _this4[tool]();

      $element.addClass('active');
      setTimeout(function () {
        $element.removeClass('active');
      }, 300);
    });
    $(document).off('click');
    $(document).on('click', function (event) {
      if (_this4.isMenuOpened) {
        _this4.toggleMoreMenu();
      }
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbW1hbmRzLmpzIl0sIm5hbWVzIjpbImRlZmF1bHRXbFByZXNldHMiLCJTb2Z0VGlzc3VlIiwid2MiLCJ3dyIsIkx1bmciLCJMaXZlciIsImRhdGFVUkl0b0Jsb2IiLCJkYXRhVVJJIiwiYnl0ZVN0cmluZyIsImF0b2IiLCJzcGxpdCIsIm1pbWVTdHJpbmciLCJhYiIsIkFycmF5QnVmZmVyIiwibGVuZ3RoIiwiaWEiLCJVaW50OEFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJpc01lbnVPcGVuZWQiLCJjb21tYW5kU2VsZWN0b3IiLCIkb3ZlcmxheSIsIiQiLCIkbG9hZGluZ1RleHQiLCIkY29tbWFuZE1lbnUiLCJjbGVhckFsbCIsImNvcm5lcnN0b25lVG9vbHMiLCJnbG9iYWxJbWFnZUlkU3BlY2lmaWNUb29sU3RhdGVNYW5hZ2VyIiwicmVzdG9yZVRvb2xTdGF0ZSIsImNvcm5lcnN0b25lIiwicmVzZXQiLCJlbGVtZW50Iiwic2tpcCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJzdGFjayIsImdldFRvb2xTdGF0ZSIsInRoZW4iLCJ1dWlkIiwic2xpY2VJbmRleCIsImRhdGEiLCJjdXJyZW50SW1hZ2VJZEluZGV4IiwiZG9jIiwiTG9naW4iLCJ1c2VybmFtZSIsIndpbmRvdyIsInJzbmFDcm93ZFF1YW50U2VyaWVzVUlEIiwicnNuYUNyb3dkUXVhbnRDYXNlU3R1ZHkiLCJpbnN0YW5jZVVJRHMiLCJ1cmxzIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1lYXN1cmVtZW50c0RCIiwicHV0IiwiVmlld2VyIiwiZ2V0TmV4dENhc2UiLCJzZXRXTCIsIndpbmRvd1dpZHRoIiwid2luZG93Q2VudGVyIiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInZvaSIsInVwZGF0ZUltYWdlIiwic2V0V0xQcmVzZXQiLCJwcmVzZXROYW1lIiwicHJlc2V0Iiwic2V0V0xQcmVzZXRMdW5nIiwic2V0V0xQcmVzZXRMaXZlciIsInNldFdMUHJlc2V0U29mdFRpc3N1ZSIsInRvZ2dsZU1vcmVNZW51Iiwic2V0VGltZW91dCIsInNhdmUiLCJ0ZXh0IiwidG9vbFN0YXRlTWFuYWdlciIsInRvb2xTdGF0ZSIsInNhdmVUb29sU3RhdGUiLCJzdGFja0RhdGEiLCJsZW5ndGhEYXRhIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJpbWFnZUlkIiwicHVzaCIsImltYWdlSW5kZXgiLCJpbWFnZUlkcyIsImluZGV4T2YiLCJFcnJvck1vZGFsIiwic2hvdyIsIkVycm9yIiwic2F2aW5nUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29uc29sZSIsInRpbWUiLCJ0aW1lRW5kIiwibWVhc3VyZW1lbnQiLCJsZW5ndGhNZWFzdXJlbWVudCIsInNjcm9sbFRvSW5kZXgiLCJoYW5kbGVzIiwic3RhcnQiLCJ4IiwieSIsImVuZCIsInNjYWxlIiwidHJhbnNsYXRpb24iLCJyZXNwb25zZSIsImNhbnZhcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImltYWdlQmxvYiIsInRvRGF0YVVSTCIsInB1dEF0dGFjaG1lbnQiLCJpZCIsInJldiIsImNhdGNoIiwiZXJyb3IiLCJsb2dvdXQiLCJpbml0Q29tbWFuZHMiLCJvZmYiLCJvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCIkZWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJ0b29sIiwiYXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxnQkFBZ0IsR0FBRztBQUNyQkMsRUFBQUEsVUFBVSxFQUFFO0FBQ1JDLElBQUFBLEVBQUUsRUFBRSxFQURJO0FBRVJDLElBQUFBLEVBQUUsRUFBRTtBQUZJLEdBRFM7QUFLckJDLEVBQUFBLElBQUksRUFBRTtBQUNGRixJQUFBQSxFQUFFLEVBQUUsQ0FBQyxHQURIO0FBRUZDLElBQUFBLEVBQUUsRUFBRTtBQUZGLEdBTGU7QUFTckJFLEVBQUFBLEtBQUssRUFBRTtBQUNISCxJQUFBQSxFQUFFLEVBQUUsRUFERDtBQUVIQyxJQUFBQSxFQUFFLEVBQUU7QUFGRDtBQVRjLENBQXpCLEMsQ0FlQTs7QUFDQSxTQUFTRyxhQUFULENBQXVCQyxPQUF2QixFQUFnQztBQUM5QjtBQUNBO0FBQ0EsTUFBSUMsVUFBVSxHQUFHQyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsQ0FBRCxDQUFyQixDQUg4QixDQUk5Qjs7QUFDQSxNQUFJQyxVQUFVLEdBQUdKLE9BQU8sQ0FBQ0csS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0JBLEtBQXRCLENBQTRCLEdBQTVCLEVBQWlDLENBQWpDLEVBQW9DQSxLQUFwQyxDQUEwQyxHQUExQyxFQUErQyxDQUEvQyxDQUFqQixDQUw4QixDQU05Qjs7QUFDQSxNQUFJRSxFQUFFLEdBQUcsSUFBSUMsV0FBSixDQUFnQkwsVUFBVSxDQUFDTSxNQUEzQixDQUFULENBUDhCLENBUTlCOztBQUNBLE1BQUlDLEVBQUUsR0FBRyxJQUFJQyxVQUFKLENBQWVKLEVBQWYsQ0FBVCxDQVQ4QixDQVU5Qjs7QUFDQSxPQUFLLElBQUlLLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdULFVBQVUsQ0FBQ00sTUFBL0IsRUFBdUNHLENBQUMsRUFBeEMsRUFBNEM7QUFDMUNGLElBQUFBLEVBQUUsQ0FBQ0UsQ0FBRCxDQUFGLEdBQVFULFVBQVUsQ0FBQ1UsVUFBWCxDQUFzQkQsQ0FBdEIsQ0FBUjtBQUNELEdBYjZCLENBYzlCOzs7QUFDQSxNQUFJRSxJQUFJLEdBQUcsSUFBSUMsSUFBSixDQUFTLENBQUNSLEVBQUQsQ0FBVCxFQUFlO0FBQUNTLElBQUFBLElBQUksRUFBRVY7QUFBUCxHQUFmLENBQVg7QUFDQSxTQUFPUSxJQUFQO0FBQ0Q7O2VBRWM7QUFDYkcsRUFBQUEsWUFBWSxFQUFFLEtBREQ7QUFFYkMsRUFBQUEsZUFBZSxFQUFFLGVBRko7QUFHYkMsRUFBQUEsUUFBUSxFQUFFQyxDQUFDLENBQUMsa0JBQUQsQ0FIRTtBQUliQyxFQUFBQSxZQUFZLEVBQUVELENBQUMsQ0FBQyx3Q0FBRCxDQUpGO0FBS2JFLEVBQUFBLFlBQVksRUFBRUYsQ0FBQyxDQUFDLG1CQUFELENBTEY7QUFPYkcsRUFBQUEsUUFQYSxzQkFPRjtBQUNUO0FBQ0FDLElBQUFBLGdCQUFnQixDQUFDQyxxQ0FBakIsQ0FBdURDLGdCQUF2RCxDQUF3RSxFQUF4RSxFQUZTLENBSVQ7O0FBQ0FDLElBQUFBLFdBQVcsQ0FBQ0MsS0FBWixDQUFrQixLQUFLQyxPQUF2QjtBQUNELEdBYlk7QUFlYkMsRUFBQUEsSUFBSSxFQUFFLGdCQUFXO0FBQUE7O0FBQ2YsU0FBS1gsUUFBTCxDQUFjWSxXQUFkLENBQTBCLFdBQTFCLEVBQXVDQyxRQUF2QyxDQUFnRCxTQUFoRDtBQUVBLFFBQU1DLEtBQUssR0FBR1QsZ0JBQWdCLENBQUNVLFlBQWpCLENBQThCLEtBQUtMLE9BQW5DLEVBQTRDLE9BQTVDLENBQWQ7QUFFQSx1QkFBVU0sSUFBVixDQUFlLFVBQUNDLElBQUQsRUFBVTtBQUN2QixVQUFNQyxVQUFVLEdBQUdKLEtBQUssQ0FBQ0ssSUFBTixDQUFXLENBQVgsRUFBY0MsbUJBQWpDO0FBQ0EsVUFBTUMsR0FBRyxHQUFHO0FBQ1YsZUFBT0osSUFERztBQUVWLGdCQUFRLElBRkU7QUFHVixxQkFBYUssZUFBTUMsUUFIVDtBQUlWLHFCQUFhQyxNQUFNLENBQUNDLHVCQUpWO0FBS1YsdUJBQWVELE1BQU0sQ0FBQ0UsdUJBQVAsQ0FBK0JDLFlBQS9CLENBQTRDVCxVQUE1QyxDQUxMO0FBTVYsdUJBQWVNLE1BQU0sQ0FBQ0UsdUJBQVAsQ0FBK0JFLElBQS9CLENBQW9DVixVQUFwQyxDQU5MO0FBT1Ysc0JBQWNBLFVBUEo7QUFRVixnQkFBUVcsSUFBSSxDQUFDQyxLQUFMLENBQVdDLElBQUksQ0FBQ0MsR0FBTCxLQUFhLElBQXhCLENBUkU7QUFTVixxQkFBYUMsU0FBUyxDQUFDQztBQVRiLE9BQVo7QUFXQSxhQUFPQyxtQkFBZUMsR0FBZixDQUFtQmYsR0FBbkIsQ0FBUDtBQUNELEtBZEQ7O0FBZ0JBZ0Isb0JBQU9DLFdBQVAsR0FBcUJ0QixJQUFyQixDQUEwQixZQUFNO0FBQzlCLE1BQUEsS0FBSSxDQUFDaEIsUUFBTCxDQUFjWSxXQUFkLENBQTBCLFNBQTFCLEVBQXFDQyxRQUFyQyxDQUE4QyxXQUE5QztBQUNELEtBRkQ7QUFHRCxHQXZDWTtBQXlDYjBCLEVBQUFBLEtBQUssRUFBRSxlQUFVQyxXQUFWLEVBQXVCQyxZQUF2QixFQUFxQztBQUMxQyxRQUFNQyxRQUFRLEdBQUdsQyxXQUFXLENBQUNtQyxXQUFaLENBQXdCLEtBQUtqQyxPQUE3QixDQUFqQjtBQUVBZ0MsSUFBQUEsUUFBUSxDQUFDRSxHQUFULENBQWFKLFdBQWIsR0FBMkJBLFdBQTNCO0FBQ0FFLElBQUFBLFFBQVEsQ0FBQ0UsR0FBVCxDQUFhSCxZQUFiLEdBQTRCQSxZQUE1QjtBQUVBakMsSUFBQUEsV0FBVyxDQUFDcUMsV0FBWixDQUF3QixLQUFLbkMsT0FBN0I7QUFDRCxHQWhEWTtBQWtEYm9DLEVBQUFBLFdBQVcsRUFBRSxxQkFBU0MsVUFBVCxFQUFxQjtBQUNoQyxRQUFNQyxNQUFNLEdBQUd4RSxnQkFBZ0IsQ0FBQ3VFLFVBQUQsQ0FBL0I7QUFDQSxTQUFLUixLQUFMLENBQVdTLE1BQU0sQ0FBQ3JFLEVBQWxCLEVBQXNCcUUsTUFBTSxDQUFDdEUsRUFBN0I7QUFDRCxHQXJEWTtBQXVEYnVFLEVBQUFBLGVBQWUsRUFBRSwyQkFBVztBQUMxQixTQUFLSCxXQUFMLENBQWlCLE1BQWpCO0FBQ0QsR0F6RFk7QUEyRGJJLEVBQUFBLGdCQUFnQixFQUFFLDRCQUFXO0FBQzNCLFNBQUtKLFdBQUwsQ0FBaUIsT0FBakI7QUFDRCxHQTdEWTtBQStEYkssRUFBQUEscUJBQXFCLEVBQUUsaUNBQVc7QUFDaEMsU0FBS0wsV0FBTCxDQUFpQixZQUFqQjtBQUNELEdBakVZO0FBbUViTSxFQUFBQSxjQUFjLEVBQUUsMEJBQVk7QUFBQTs7QUFDMUIsUUFBSSxLQUFLdEQsWUFBVCxFQUF1QjtBQUNyQixXQUFLSyxZQUFMLENBQWtCUyxXQUFsQixDQUE4QixNQUE5QjtBQUNBeUMsTUFBQUEsVUFBVSxDQUFDLFlBQU07QUFDZixRQUFBLE1BQUksQ0FBQ2xELFlBQUwsQ0FBa0JTLFdBQWxCLENBQThCLFFBQTlCO0FBQ0QsT0FGUyxFQUVQLElBRk8sQ0FBVjtBQUdELEtBTEQsTUFLTztBQUNMLFdBQUtULFlBQUwsQ0FBa0JVLFFBQWxCLENBQTJCLGFBQTNCO0FBQ0Q7O0FBRUQsU0FBS2YsWUFBTCxHQUFvQixDQUFDLEtBQUtBLFlBQTFCO0FBQ0QsR0E5RVk7QUFnRmJ3RCxFQUFBQSxJQUFJLEVBQUUsZ0JBQVk7QUFBQTs7QUFDaEIsU0FBS3RELFFBQUwsQ0FBY1ksV0FBZCxDQUEwQixXQUExQixFQUF1Q0MsUUFBdkMsQ0FBZ0QsU0FBaEQ7QUFDQSxTQUFLWCxZQUFMLENBQWtCcUQsSUFBbEIsQ0FBdUIsZ0NBQXZCLEVBRmdCLENBSWhCOztBQUNBLFFBQU1DLGdCQUFnQixHQUFHbkQsZ0JBQWdCLENBQUNDLHFDQUExQyxDQUxnQixDQU9oQjs7QUFDQSxRQUFNbUQsU0FBUyxHQUFHRCxnQkFBZ0IsQ0FBQ0UsYUFBakIsRUFBbEIsQ0FSZ0IsQ0FVaEI7O0FBQ0EsUUFBTUMsU0FBUyxHQUFHdEQsZ0JBQWdCLENBQUNVLFlBQWpCLENBQThCLEtBQUtMLE9BQW5DLEVBQTRDLE9BQTVDLENBQWxCO0FBQ0EsUUFBTUksS0FBSyxHQUFHNkMsU0FBUyxDQUFDeEMsSUFBVixDQUFlLENBQWYsQ0FBZCxDQVpnQixDQWNoQjs7QUFDQSxRQUFJeUMsVUFBVSxHQUFHLEVBQWpCO0FBQ0FDLElBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTCxTQUFaLEVBQXVCTSxPQUF2QixDQUErQixVQUFBQyxPQUFPLEVBQUk7QUFDeEMsVUFBSSxDQUFDUCxTQUFTLENBQUNPLE9BQUQsQ0FBVCxDQUFtQixRQUFuQixDQUFELElBQWlDLENBQUNQLFNBQVMsQ0FBQ08sT0FBRCxDQUFULENBQW1CLFFBQW5CLEVBQTZCN0MsSUFBN0IsQ0FBa0M3QixNQUF4RSxFQUFnRjtBQUM5RTtBQUNEOztBQUVEc0UsTUFBQUEsVUFBVSxDQUFDSyxJQUFYLENBQWdCO0FBQ2RDLFFBQUFBLFVBQVUsRUFBRXBELEtBQUssQ0FBQ3FELFFBQU4sQ0FBZUMsT0FBZixDQUF1QkosT0FBdkIsQ0FERTtBQUVkN0MsUUFBQUEsSUFBSSxFQUFFc0MsU0FBUyxDQUFDTyxPQUFELENBQVQsQ0FBbUIxRTtBQUZYLE9BQWhCO0FBSUQsS0FURDs7QUFXQSxRQUFJLENBQUNzRSxVQUFVLENBQUN0RSxNQUFoQixFQUF1QjtBQUNyQjtBQUNBK0UscUJBQVdDLElBQVg7O0FBQ0EsV0FBS3BFLFlBQUwsQ0FBa0JxRCxJQUFsQixDQUF1QixFQUF2QjtBQUNBLFdBQUt2RCxRQUFMLENBQWNZLFdBQWQsQ0FBMEIsU0FBMUIsRUFBcUNDLFFBQXJDLENBQThDLFdBQTlDO0FBQ0E7QUFDRDs7QUFFRCxRQUFJK0MsVUFBVSxDQUFDdEUsTUFBWCxHQUFvQixDQUF4QixFQUEyQjtBQUN6QixZQUFNLElBQUlpRixLQUFKLENBQVUseURBQVYsQ0FBTjtBQUNEOztBQUVELFFBQU1DLGFBQWEsR0FBRyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3JEQyxNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxTQUFiO0FBQ0EseUJBQVU3RCxJQUFWLENBQWUsVUFBQ0MsSUFBRCxFQUFVO0FBQ3ZCMkQsUUFBQUEsT0FBTyxDQUFDRSxPQUFSLENBQWdCLFNBQWhCO0FBQ0FGLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHVCQUFiO0FBQ0EsWUFBTUUsV0FBVyxHQUFHbkIsVUFBVSxDQUFDLENBQUQsQ0FBOUI7QUFDQSxZQUFNb0IsaUJBQWlCLEdBQUdELFdBQVcsQ0FBQzVELElBQVosQ0FBaUJBLElBQWpCLENBQXNCLENBQXRCLENBQTFCO0FBRUFkLFFBQUFBLGdCQUFnQixDQUFDNEUsYUFBakIsQ0FBK0IsTUFBSSxDQUFDdkUsT0FBcEMsRUFBNkNxRSxXQUFXLENBQUNiLFVBQXpEO0FBRUEsWUFBTTdDLEdBQUcsR0FBRztBQUNWLGlCQUFPSixJQURHO0FBRVYsb0JBQVUrRCxpQkFBaUIsQ0FBQzFGLE1BRmxCO0FBR1YscUJBQVcwRixpQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEJDLEtBQTFCLENBQWdDQyxDQUhqQztBQUlWLHFCQUFXSixpQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEJDLEtBQTFCLENBQWdDRSxDQUpqQztBQUtWLG1CQUFTTCxpQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEJJLEdBQTFCLENBQThCRixDQUw3QjtBQU1WLG1CQUFTSixpQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEJJLEdBQTFCLENBQThCRCxDQU43QjtBQU9WLHlCQUFlTCxpQkFBaUIsQ0FBQ3hDLFdBUHZCO0FBUVYsMEJBQWdCd0MsaUJBQWlCLENBQUN2QyxZQVJ4QjtBQVNWLG1CQUFTdUMsaUJBQWlCLENBQUNPLEtBVGpCO0FBVVYsMkJBQWlCUCxpQkFBaUIsQ0FBQ1EsV0FBbEIsQ0FBOEJKLENBVnJDO0FBV1YsMkJBQWlCSixpQkFBaUIsQ0FBQ1EsV0FBbEIsQ0FBOEJILENBWHJDO0FBWVYsdUJBQWEvRCxlQUFNQyxRQVpUO0FBYVYsdUJBQWFDLE1BQU0sQ0FBQ0MsdUJBYlY7QUFjVix5QkFBZUQsTUFBTSxDQUFDRSx1QkFBUCxDQUErQkMsWUFBL0IsQ0FBNENvRCxXQUFXLENBQUNiLFVBQXhELENBZEw7QUFlVix5QkFBZTFDLE1BQU0sQ0FBQ0UsdUJBQVAsQ0FBK0JFLElBQS9CLENBQW9DbUQsV0FBVyxDQUFDYixVQUFoRCxDQWZMO0FBZ0JWLHdCQUFjYSxXQUFXLENBQUNiLFVBaEJoQjtBQWlCVixrQkFBUXJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUNDLEdBQUwsS0FBYSxJQUF4QixDQWpCRTtBQWtCVix1QkFBYUMsU0FBUyxDQUFDQztBQWxCYixTQUFaO0FBcUJBLGVBQU9DLG1CQUFlQyxHQUFmLENBQW1CZixHQUFuQixDQUFQO0FBQ0QsT0E5QkQsRUE4QkdMLElBOUJILENBOEJRLFVBQUN5RSxRQUFELEVBQWM7QUFDcEJiLFFBQUFBLE9BQU8sQ0FBQ0UsT0FBUixDQUFnQix1QkFBaEI7QUFDQUYsUUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsbUJBQWI7QUFDQSxZQUFNYSxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1Qiw2QkFBdkIsQ0FBZjtBQUNBLFlBQU1DLFNBQVMsR0FBRy9HLGFBQWEsQ0FBQzRHLE1BQU0sQ0FBQ0ksU0FBUCxFQUFELENBQS9CO0FBQ0EsZUFBTzNELG1CQUFlNEQsYUFBZixDQUE2Qk4sUUFBUSxDQUFDTyxFQUF0QyxFQUEwQyxnQkFBMUMsRUFBNERQLFFBQVEsQ0FBQ1EsR0FBckUsRUFBMEVKLFNBQTFFLEVBQXFGLFdBQXJGLENBQVA7QUFDRCxPQXBDRCxFQW9DRzdFLElBcENILENBb0NRLFlBQU07QUFDWjRELFFBQUFBLE9BQU8sQ0FBQ0UsT0FBUixDQUFnQixtQkFBaEI7QUFDQUosUUFBQUEsT0FBTztBQUNSLE9BdkNELEVBdUNHd0IsS0F2Q0gsQ0F1Q1MsVUFBQ0MsS0FBRCxFQUFXO0FBQ2xCeEIsUUFBQUEsTUFBTSxDQUFDd0IsS0FBRCxDQUFOO0FBQ0QsT0F6Q0Q7QUEwQ0QsS0E1Q3FCLENBQXRCOztBQThDQTlELG9CQUFPQyxXQUFQLEdBQXFCdEIsSUFBckIsQ0FBMEIsWUFBTTtBQUM5QixNQUFBLE1BQUksQ0FBQ2QsWUFBTCxDQUFrQnFELElBQWxCLENBQXVCLEVBQXZCOztBQUNBLE1BQUEsTUFBSSxDQUFDdkQsUUFBTCxDQUFjWSxXQUFkLENBQTBCLFNBQTFCLEVBQXFDQyxRQUFyQyxDQUE4QyxXQUE5QztBQUNELEtBSEQ7O0FBS0EsV0FBTzJELGFBQVA7QUFDRCxHQTNLWTtBQTZLYjRCLEVBQUFBLE1BN0thLG9CQTZLSjtBQUNQOUUsbUJBQU04RSxNQUFOO0FBQ0QsR0EvS1k7QUFpTGJDLEVBQUFBLFlBakxhLDBCQWlMRTtBQUFBOztBQUNicEcsSUFBQUEsQ0FBQyxDQUFDLEtBQUtGLGVBQU4sQ0FBRCxDQUF3QnVHLEdBQXhCLENBQTRCLE9BQTVCO0FBQ0FyRyxJQUFBQSxDQUFDLENBQUMsS0FBS0YsZUFBTixDQUFELENBQXdCd0csRUFBeEIsQ0FBMkIsT0FBM0IsRUFBb0MsbUJBQXBDLEVBQXlELFVBQUFDLEtBQUssRUFBSTtBQUNoRUEsTUFBQUEsS0FBSyxDQUFDQyxjQUFOO0FBQ0FELE1BQUFBLEtBQUssQ0FBQ0UsZUFBTjtBQUVBLFVBQU1DLFFBQVEsR0FBRzFHLENBQUMsQ0FBQ3VHLEtBQUssQ0FBQ0ksYUFBUCxDQUFsQjtBQUNBLFVBQU1DLElBQUksR0FBR0YsUUFBUSxDQUFDRyxJQUFULENBQWMsY0FBZCxDQUFiOztBQUVBLE1BQUEsTUFBSSxDQUFDRCxJQUFELENBQUo7O0FBRUFGLE1BQUFBLFFBQVEsQ0FBQzlGLFFBQVQsQ0FBa0IsUUFBbEI7QUFFQXdDLE1BQUFBLFVBQVUsQ0FBQyxZQUFXO0FBQ3BCc0QsUUFBQUEsUUFBUSxDQUFDL0YsV0FBVCxDQUFxQixRQUFyQjtBQUNELE9BRlMsRUFFUCxHQUZPLENBQVY7QUFHRCxLQWREO0FBZ0JBWCxJQUFBQSxDQUFDLENBQUMwRixRQUFELENBQUQsQ0FBWVcsR0FBWixDQUFnQixPQUFoQjtBQUNBckcsSUFBQUEsQ0FBQyxDQUFDMEYsUUFBRCxDQUFELENBQVlZLEVBQVosQ0FBZSxPQUFmLEVBQXdCLFVBQUFDLEtBQUssRUFBSTtBQUMvQixVQUFJLE1BQUksQ0FBQzFHLFlBQVQsRUFBdUI7QUFDckIsUUFBQSxNQUFJLENBQUNzRCxjQUFMO0FBQ0Q7QUFDRixLQUpEO0FBS0Q7QUF6TVksQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNZW51IGZyb20gJy4uL21lbnUvbWVudS5qcyc7XG5pbXBvcnQgVmlld2VyIGZyb20gJy4uL3ZpZXdlci92aWV3ZXIuanMnO1xuaW1wb3J0IEVycm9yTW9kYWwgZnJvbSAnLi4vZXJyb3JNb2RhbC9tb2RhbC5qcyc7XG5pbXBvcnQge21lYXN1cmVtZW50c0RCLCBnZXRVVUlEfSBmcm9tICcuLi9kYi9kYi5qcyc7XG5pbXBvcnQgTG9naW4gZnJvbSAnLi4vbG9naW4vbG9naW4nO1xuXG5pbXBvcnQgKiBhcyBjb3JuZXJzdG9uZSBmcm9tICdjb3JuZXJzdG9uZS1jb3JlJztcbmltcG9ydCAqIGFzIGNvcm5lcnN0b25lVG9vbHMgZnJvbSAnY29ybmVyc3RvbmUtdG9vbHMnO1xuXG5jb25zdCBkZWZhdWx0V2xQcmVzZXRzID0ge1xuICAgIFNvZnRUaXNzdWU6IHtcbiAgICAgICAgd2M6IDQwLFxuICAgICAgICB3dzogNDAwXG4gICAgfSxcbiAgICBMdW5nOiB7XG4gICAgICAgIHdjOiAtNjAwLFxuICAgICAgICB3dzogMTUwMFxuICAgIH0sXG4gICAgTGl2ZXI6IHtcbiAgICAgICAgd2M6IDkwLFxuICAgICAgICB3dzogMTUwXG4gICAgfVxufTtcblxuLy8gaGVscGVyIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIxNjg5MDkvYmxvYi1mcm9tLWRhdGF1cmxcbmZ1bmN0aW9uIGRhdGFVUkl0b0Jsb2IoZGF0YVVSSSkge1xuICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZ1xuICAvLyBkb2Vzbid0IGhhbmRsZSBVUkxFbmNvZGVkIERhdGFVUklzIC0gc2VlIFNPIGFuc3dlciAjNjg1MDI3NiBmb3IgY29kZSB0aGF0IGRvZXMgdGhpc1xuICB2YXIgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSSS5zcGxpdCgnLCcpWzFdKTtcbiAgLy8gc2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudFxuICB2YXIgbWltZVN0cmluZyA9IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cbiAgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcbiAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgLy8gY3JlYXRlIGEgdmlldyBpbnRvIHRoZSBidWZmZXJcbiAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAvLyBzZXQgdGhlIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gdGhlIGNvcnJlY3QgdmFsdWVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIC8vIHdyaXRlIHRoZSBBcnJheUJ1ZmZlciB0byBhIGJsb2IsIGFuZCB5b3UncmUgZG9uZVxuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFthYl0sIHt0eXBlOiBtaW1lU3RyaW5nfSk7XG4gIHJldHVybiBibG9iO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzTWVudU9wZW5lZDogZmFsc2UsXG4gIGNvbW1hbmRTZWxlY3RvcjogJy52aWV3ZXItdG9vbHMnLFxuICAkb3ZlcmxheTogJCgnLmxvYWRpbmctb3ZlcmxheScpLFxuICAkbG9hZGluZ1RleHQ6ICQoJy5sb2FkaW5nLW92ZXJsYXkgLmNvbnRlbnQgLnN1Ym1pdC10ZXh0JyksXG4gICRjb21tYW5kTWVudTogJCgnLmNvbW1hbmRzLXdyYXBwZXInKSxcblxuICBjbGVhckFsbCgpIHtcbiAgICAvLyBSZW1vdmUgYWxsIGltYWdlSWQtc3BlY2lmaWMgbWVhc3VyZW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVsZW1lbnRcbiAgICBjb3JuZXJzdG9uZVRvb2xzLmdsb2JhbEltYWdlSWRTcGVjaWZpY1Rvb2xTdGF0ZU1hbmFnZXIucmVzdG9yZVRvb2xTdGF0ZSh7fSk7XG5cbiAgICAvLyBSZXNldCB0aGUgdmlld3BvcnQgcGFyYW1ldGVycyAoaS5lLiBWT0kgTFVULCBzY2FsZSwgdHJhbnNsYXRpb24pXG4gICAgY29ybmVyc3RvbmUucmVzZXQodGhpcy5lbGVtZW50KTtcbiAgfSxcblxuICBza2lwOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKS5hZGRDbGFzcygnbG9hZGluZycpO1xuXG4gICAgY29uc3Qgc3RhY2sgPSBjb3JuZXJzdG9uZVRvb2xzLmdldFRvb2xTdGF0ZSh0aGlzLmVsZW1lbnQsICdzdGFjaycpO1xuXG4gICAgZ2V0VVVJRCgpLnRoZW4oKHV1aWQpID0+IHtcbiAgICAgIGNvbnN0IHNsaWNlSW5kZXggPSBzdGFjay5kYXRhWzBdLmN1cnJlbnRJbWFnZUlkSW5kZXg7XG4gICAgICBjb25zdCBkb2MgPSB7XG4gICAgICAgICdfaWQnOiB1dWlkLFxuICAgICAgICAnc2tpcCc6IHRydWUsXG4gICAgICAgICdhbm5vdGF0b3InOiBMb2dpbi51c2VybmFtZSxcbiAgICAgICAgJ3Nlcmllc1VJRCc6IHdpbmRvdy5yc25hQ3Jvd2RRdWFudFNlcmllc1VJRCxcbiAgICAgICAgJ2luc3RhbmNlVUlEJzogd2luZG93LnJzbmFDcm93ZFF1YW50Q2FzZVN0dWR5Lmluc3RhbmNlVUlEc1tzbGljZUluZGV4XSxcbiAgICAgICAgJ2luc3RhbmNlVVJMJzogd2luZG93LnJzbmFDcm93ZFF1YW50Q2FzZVN0dWR5LnVybHNbc2xpY2VJbmRleF0sXG4gICAgICAgICdzbGljZUluZGV4Jzogc2xpY2VJbmRleCxcbiAgICAgICAgJ2RhdGUnOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgJ3VzZXJBZ2VudCc6IG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgIH07XG4gICAgICByZXR1cm4gbWVhc3VyZW1lbnRzREIucHV0KGRvYyk7XG4gICAgfSk7XG5cbiAgICBWaWV3ZXIuZ2V0TmV4dENhc2UoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2V0V0w6IGZ1bmN0aW9uICh3aW5kb3dXaWR0aCwgd2luZG93Q2VudGVyKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBjb3JuZXJzdG9uZS5nZXRWaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xuXG4gICAgdmlld3BvcnQudm9pLndpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XG4gICAgdmlld3BvcnQudm9pLndpbmRvd0NlbnRlciA9IHdpbmRvd0NlbnRlcjtcblxuICAgIGNvcm5lcnN0b25lLnVwZGF0ZUltYWdlKHRoaXMuZWxlbWVudCk7XG4gIH0sXG5cbiAgc2V0V0xQcmVzZXQ6IGZ1bmN0aW9uKHByZXNldE5hbWUpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBkZWZhdWx0V2xQcmVzZXRzW3ByZXNldE5hbWVdXG4gICAgdGhpcy5zZXRXTChwcmVzZXQud3csIHByZXNldC53Yyk7XG4gIH0sXG5cbiAgc2V0V0xQcmVzZXRMdW5nOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFdMUHJlc2V0KCdMdW5nJyk7XG4gIH0sXG5cbiAgc2V0V0xQcmVzZXRMaXZlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRXTFByZXNldCgnTGl2ZXInKTtcbiAgfSxcblxuICBzZXRXTFByZXNldFNvZnRUaXNzdWU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0V0xQcmVzZXQoJ1NvZnRUaXNzdWUnKTtcbiAgfSxcblxuICB0b2dnbGVNb3JlTWVudTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzTWVudU9wZW5lZCkge1xuICAgICAgdGhpcy4kY29tbWFuZE1lbnUucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiRjb21tYW5kTWVudS5yZW1vdmVDbGFzcygnYm9yZGVyJyk7XG4gICAgICB9LCAxMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kY29tbWFuZE1lbnUuYWRkQ2xhc3MoJ29wZW4gYm9yZGVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pc01lbnVPcGVuZWQgPSAhdGhpcy5pc01lbnVPcGVuZWQ7XG4gIH0sXG5cbiAgc2F2ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpLmFkZENsYXNzKCdsb2FkaW5nJyk7XG4gICAgdGhpcy4kbG9hZGluZ1RleHQudGV4dCgnU3VibWl0dGluZyB5b3VyIG1lYXN1cmVtZW50Li4uJyk7XG5cbiAgICAvLyBSZXRyaWV2ZSB0aGUgdG9vbCBzdGF0ZSBtYW5hZ2VyIGZvciB0aGlzIGVsZW1lbnRcbiAgICBjb25zdCB0b29sU3RhdGVNYW5hZ2VyID0gY29ybmVyc3RvbmVUb29scy5nbG9iYWxJbWFnZUlkU3BlY2lmaWNUb29sU3RhdGVNYW5hZ2VyO1xuXG4gICAgLy8gRHVtcCBhbGwgb2YgaXRzIHRvb2wgc3RhdGUgaW50byBhbiBPYmplY3RcbiAgICBjb25zdCB0b29sU3RhdGUgPSB0b29sU3RhdGVNYW5hZ2VyLnNhdmVUb29sU3RhdGUoKTtcblxuICAgIC8vIEdldCB0aGUgc3RhY2sgdG9vbCBkYXRhXG4gICAgY29uc3Qgc3RhY2tEYXRhID0gY29ybmVyc3RvbmVUb29scy5nZXRUb29sU3RhdGUodGhpcy5lbGVtZW50LCAnc3RhY2snKTtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrRGF0YS5kYXRhWzBdO1xuXG4gICAgLy8gUmV0cmlldmUgdGhlIGxlbmd0aCBkYXRhIGZyb20gdGhpcyBPYmplY3RcbiAgICBsZXQgbGVuZ3RoRGF0YSA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRvb2xTdGF0ZSkuZm9yRWFjaChpbWFnZUlkID0+IHtcbiAgICAgIGlmICghdG9vbFN0YXRlW2ltYWdlSWRdWydsZW5ndGgnXSB8fCAhdG9vbFN0YXRlW2ltYWdlSWRdWydsZW5ndGgnXS5kYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aERhdGEucHVzaCh7XG4gICAgICAgIGltYWdlSW5kZXg6IHN0YWNrLmltYWdlSWRzLmluZGV4T2YoaW1hZ2VJZCksXG4gICAgICAgIGRhdGE6IHRvb2xTdGF0ZVtpbWFnZUlkXS5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCFsZW5ndGhEYXRhLmxlbmd0aCl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnRXJyb3JNb2RhbCcsIEVycm9yTW9kYWwpO1xuICAgICAgRXJyb3JNb2RhbC5zaG93KCk7XG4gICAgICB0aGlzLiRsb2FkaW5nVGV4dC50ZXh0KCcnKTtcbiAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aERhdGEubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBsZW5ndGggbWVhc3VyZW1lbnQgc2hvdWxkIGJlIGluIHRoZSBsZW5ndGhEYXRhJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2F2aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnNvbGUudGltZSgnZ2V0VVVJRCcpO1xuICAgICAgZ2V0VVVJRCgpLnRoZW4oKHV1aWQpID0+IHtcbiAgICAgICAgY29uc29sZS50aW1lRW5kKCdnZXRVVUlEJyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnUFVUIHRvIE1lYXN1cmVtZW50IERCJyk7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbGVuZ3RoRGF0YVswXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoTWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudC5kYXRhLmRhdGFbMF07XG5cbiAgICAgICAgY29ybmVyc3RvbmVUb29scy5zY3JvbGxUb0luZGV4KHRoaXMuZWxlbWVudCwgbWVhc3VyZW1lbnQuaW1hZ2VJbmRleCk7XG5cbiAgICAgICAgY29uc3QgZG9jID0ge1xuICAgICAgICAgICdfaWQnOiB1dWlkLFxuICAgICAgICAgICdsZW5ndGgnOiBsZW5ndGhNZWFzdXJlbWVudC5sZW5ndGgsXG4gICAgICAgICAgJ3N0YXJ0X3gnOiBsZW5ndGhNZWFzdXJlbWVudC5oYW5kbGVzLnN0YXJ0LngsXG4gICAgICAgICAgJ3N0YXJ0X3knOiBsZW5ndGhNZWFzdXJlbWVudC5oYW5kbGVzLnN0YXJ0LnksXG4gICAgICAgICAgJ2VuZF94JzogbGVuZ3RoTWVhc3VyZW1lbnQuaGFuZGxlcy5lbmQueCxcbiAgICAgICAgICAnZW5kX3knOiBsZW5ndGhNZWFzdXJlbWVudC5oYW5kbGVzLmVuZC55LFxuICAgICAgICAgICd3aW5kb3dXaWR0aCc6IGxlbmd0aE1lYXN1cmVtZW50LndpbmRvd1dpZHRoLFxuICAgICAgICAgICd3aW5kb3dDZW50ZXInOiBsZW5ndGhNZWFzdXJlbWVudC53aW5kb3dDZW50ZXIsXG4gICAgICAgICAgJ3NjYWxlJzogbGVuZ3RoTWVhc3VyZW1lbnQuc2NhbGUsXG4gICAgICAgICAgJ3RyYW5zbGF0aW9uX3gnOiBsZW5ndGhNZWFzdXJlbWVudC50cmFuc2xhdGlvbi54LFxuICAgICAgICAgICd0cmFuc2xhdGlvbl95JzogbGVuZ3RoTWVhc3VyZW1lbnQudHJhbnNsYXRpb24ueSxcbiAgICAgICAgICAnYW5ub3RhdG9yJzogTG9naW4udXNlcm5hbWUsXG4gICAgICAgICAgJ3Nlcmllc1VJRCc6IHdpbmRvdy5yc25hQ3Jvd2RRdWFudFNlcmllc1VJRCxcbiAgICAgICAgICAnaW5zdGFuY2VVSUQnOiB3aW5kb3cucnNuYUNyb3dkUXVhbnRDYXNlU3R1ZHkuaW5zdGFuY2VVSURzW21lYXN1cmVtZW50LmltYWdlSW5kZXhdLFxuICAgICAgICAgICdpbnN0YW5jZVVSTCc6IHdpbmRvdy5yc25hQ3Jvd2RRdWFudENhc2VTdHVkeS51cmxzW21lYXN1cmVtZW50LmltYWdlSW5kZXhdLFxuICAgICAgICAgICdzbGljZUluZGV4JzogbWVhc3VyZW1lbnQuaW1hZ2VJbmRleCxcbiAgICAgICAgICAnZGF0ZSc6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICd1c2VyQWdlbnQnOiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c0RCLnB1dChkb2MpO1xuICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc29sZS50aW1lRW5kKCdQVVQgdG8gTWVhc3VyZW1lbnQgREInKTtcbiAgICAgICAgY29uc29sZS50aW1lKCdQVVQgcHV0QXR0YWNobWVudCcpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29ybmVyc3RvbmVWaWV3cG9ydCBjYW52YXMnKTtcbiAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gZGF0YVVSSXRvQmxvYihjYW52YXMudG9EYXRhVVJMKCkpO1xuICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnRzREIucHV0QXR0YWNobWVudChyZXNwb25zZS5pZCwgJ3NjcmVlbnNob3QucG5nJywgcmVzcG9uc2UucmV2LCBpbWFnZUJsb2IsICdpbWFnZS9wbmcnKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ1BVVCBwdXRBdHRhY2htZW50Jyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIFZpZXdlci5nZXROZXh0Q2FzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy4kbG9hZGluZ1RleHQudGV4dCgnJyk7XG4gICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdsb2FkaW5nJykuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNhdmluZ1Byb21pc2U7XG4gIH0sXG5cbiAgbG9nb3V0KCkge1xuICAgIExvZ2luLmxvZ291dCgpO1xuICB9LFxuXG4gIGluaXRDb21tYW5kcygpIHtcbiAgICAkKHRoaXMuY29tbWFuZFNlbGVjdG9yKS5vZmYoJ2NsaWNrJyk7XG4gICAgJCh0aGlzLmNvbW1hbmRTZWxlY3Rvcikub24oJ2NsaWNrJywgJ2RpdltkYXRhLWNvbW1hbmRdJywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBjb25zdCAkZWxlbWVudCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICBjb25zdCB0b29sID0gJGVsZW1lbnQuYXR0cignZGF0YS1jb21tYW5kJyk7XG5cbiAgICAgIHRoaXNbdG9vbF0oKTtcblxuICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkZWxlbWVudC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9LCAzMDApO1xuICAgIH0pO1xuXG4gICAgJChkb2N1bWVudCkub2ZmKCdjbGljaycpO1xuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmlzTWVudU9wZW5lZCkge1xuICAgICAgICB0aGlzLnRvZ2dsZU1vcmVNZW51KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG4iXX0=
},{"../db/db.js":20,"../errorModal/modal.js":21,"../login/login":23,"../menu/menu.js":24,"../viewer/viewer.js":32,"cornerstone-core":2,"cornerstone-tools":4}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var mockUrl = 'http://localhost:4000/mock.json';
var _default = {
  getCase: function getCase() {
    return new Promise(function (resolve, reject) {
      var successHandler = function successHandler(response) {
        resolve(response);
      };

      var errorHandler = function errorHandler(error) {
        if (error) {
          console.error(error);
        }

        reject(error);
      };

      $.ajax(mockUrl).then(successHandler, errorHandler);
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbm5lY3Rvci5qcyJdLCJuYW1lcyI6WyJtb2NrVXJsIiwiZ2V0Q2FzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3VjY2Vzc0hhbmRsZXIiLCJyZXNwb25zZSIsImVycm9ySGFuZGxlciIsImVycm9yIiwiY29uc29sZSIsIiQiLCJhamF4IiwidGhlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBTUEsT0FBTyxHQUFHLGlDQUFoQjtlQUVlO0FBQ2JDLEVBQUFBLE9BRGEscUJBQ0g7QUFDUixXQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUM1QyxVQUFNQyxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQUNDLFFBQUQsRUFBYztBQUNuQ0gsUUFBQUEsT0FBTyxDQUFDRyxRQUFELENBQVA7QUFDRCxPQUZEOztBQUdBLFVBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUNDLEtBQUQsRUFBVztBQUM5QixZQUFJQSxLQUFKLEVBQVc7QUFDVEMsVUFBQUEsT0FBTyxDQUFDRCxLQUFSLENBQWNBLEtBQWQ7QUFDRDs7QUFFREosUUFBQUEsTUFBTSxDQUFDSSxLQUFELENBQU47QUFDRCxPQU5EOztBQVFBRSxNQUFBQSxDQUFDLENBQUNDLElBQUYsQ0FBT1gsT0FBUCxFQUFnQlksSUFBaEIsQ0FBcUJQLGNBQXJCLEVBQXFDRSxZQUFyQztBQUNELEtBYk0sQ0FBUDtBQWNEO0FBaEJZLEMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtb2NrVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6NDAwMC9tb2NrLmpzb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldENhc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICAkLmFqYXgobW9ja1VybCkudGhlbihzdWNjZXNzSGFuZGxlciwgZXJyb3JIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufTtcbiJdfQ==
},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(action, timeWindow) {
  var timeout;
  return function () {
    var _this = this,
        _arguments = arguments;

    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return action.apply(_this, _arguments);
    }, timeWindow);
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlYm91bmNlLmpzIl0sIm5hbWVzIjpbImFjdGlvbiIsInRpbWVXaW5kb3ciLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWUsa0JBQVVBLE1BQVYsRUFBa0JDLFVBQWxCLEVBQThCO0FBQzNDLE1BQUlDLE9BQUo7QUFFQSxTQUFPLFlBQVc7QUFBQTtBQUFBOztBQUNoQkMsSUFBQUEsWUFBWSxDQUFDRCxPQUFELENBQVo7QUFDQUEsSUFBQUEsT0FBTyxHQUFHRSxVQUFVLENBQUM7QUFBQSxhQUFNSixNQUFNLENBQUNLLEtBQVAsQ0FBYSxLQUFiLEVBQW1CQyxVQUFuQixDQUFOO0FBQUEsS0FBRCxFQUFzQ0wsVUFBdEMsQ0FBcEI7QUFDRCxHQUhEO0FBSUQiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYWN0aW9uLCB0aW1lV2luZG93KSB7XG4gIGxldCB0aW1lb3V0O1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRpbWVXaW5kb3cpO1xuICB9O1xufSJdfQ==
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _connector = _interopRequireDefault(require("./connector"));

var _login = _interopRequireDefault(require("../login/login"));

var _db = require("../db/db");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _default = {
  getCaseImages: function getCaseImages() {
    var $overlay = $('.loading-overlay');
    $overlay.addClass('loading');
    $overlay.removeClass('invisible');
    return this.getChronicleImageIDs().then(function (caseStudy) {
      if (!caseStudy || !caseStudy.urls) {
        throw new Error('No case study or no URLs provided');
      } // where to store the case id for access during save?
      // I don't understand the model hierarchy, so let's stick it on the window


      window.rsnaCrowdQuantSeriesUID = caseStudy.seriesUID;
      window.rsnaCrowdQuantCaseStudy = caseStudy;
      return caseStudy.urls.map(function (url) {
        return url.replace('http', 'wadouri');
      });
    });
  },
  currentSeriesIndex: undefined,
  seriesUID_A: undefined,
  getChronicleImageIDs: function getChronicleImageIDs() {
    var _this = this;

    var allCases; // this could be cached

    var userCases; // filtered to user's anatChoices

    return Promise.resolve('1.3.6.1.4.1.14519.5.2.1.3098.4963.202287948568406289093737485605').then(function (seriesUID) {
      if (!_this.currentSeriesIndex) {
        _this.currentSeriesIndex = 0;
      }

      _this.currentSeriesIndex++;
      console.log('series Index:', _this.currentSeriesIndex); //const key = data.rows[this.currentSeriesIndex].key;
      // if(currentSeriesIndex >= data.rows.length){
      //   currentSeriesIndex=0;
      // }

      _this.seriesUID_A = seriesUID;
      console.log('series UID:', seriesUID);

      if (seriesUID === undefined) {
        alert('Congratulations - you have looked at all the series');
        window.location.reload();
      }

      return _db.chronicleDB.query("instances/seriesInstances", {
        startkey: seriesUID,
        endkey: seriesUID + "\u9999",
        stale: 'update_after',
        reduce: false
      });
    }).then(function (data) {
      // console.log('instance data:', data);
      var instanceUIDs = [];
      data.rows.forEach(function (row) {
        var instanceUID = row.value[1];
        instanceUIDs.push(instanceUID);
      });
      console.time('Metadata Retrieval from Chronicle DB'); // TODO: Switch to some study or series-level call
      // It is quite slow to wait on metadata for every single image
      // each retrieved in separate calls

      return Promise.all(instanceUIDs.map(function (uid) {
        return _db.chronicleDB.get(uid);
      }));
    }).then(function (docs) {
      console.timeEnd('Metadata Retrieval from Chronicle DB');
      var instanceNumberTag = "00200013";
      var instanceUIDsByImageNumber = {};
      docs.forEach(function (doc) {
        var imageNumber = Number(doc.dataset[instanceNumberTag].Value);
        instanceUIDsByImageNumber[imageNumber] = doc._id;
      });
      var imageNumbers = Object.keys(instanceUIDsByImageNumber);
      imageNumbers.sort(function (a, b) {
        return a - b;
      });
      var instanceURLs = [];
      var instanceUIDs = [];
      imageNumbers.forEach(function (imageNumber) {
        var instanceUID = instanceUIDsByImageNumber[imageNumber];
        var instanceURL = "".concat(_db.chronicleURL, "/").concat(instanceUID, "/object.dcm");
        instanceURLs.push(instanceURL);
        instanceUIDs.push(instanceUID);
      });
      return {
        name: "default_case",
        seriesUID: _this.seriesUID_A,
        currentSeriesIndex: _this.currentSeriesIndex - 1,
        urls: instanceURLs,
        instanceUIDs: instanceUIDs
      };
    }).catch(function (err) {
      throw err;
    });
  },
  getNextSeriesForAnnotator: function getNextSeriesForAnnotator(annotatorID, cases) {
    // filter cases by annotator's anatomyChoices
    var measurementsPerSeries = {};
    var annotatorMeasuredSeries = {};
    var seriesUIDs = cases.map(function (c) {
      return c.key[0];
    }); // first, get list of all series (this should be factored out to be global and only queried once)
    // result.rows.forEach(row => {
    //   seriesUIDs.push(row.key[2][2]);
    // });
    // then get the list of all measurements per series and how many measurements
    // (not all series will have been measured)

    return _db.measurementsDB.query('by/seriesUIDNoSkip', {
      reduce: true,
      group: true,
      level: 'exact'
    }).then(function (result) {
      result.rows.forEach(function (row) {
        measurementsPerSeries[row.key] = row.value;
      });
      return _db.measurementsDB.query('by/annotators', {
        reduce: false,
        include_docs: true,
        start_key: annotatorID,
        end_key: annotatorID
      });
    }).then(function (result) {
      // todo- remove duplication! store on a utils object? or the Login?
      var categoryIdToLabelMap = {
        'TCGA-LUAD': 'Lung',
        'TCGA-LIHC': 'Liver',
        'TCGA_RN': 'Renal',
        'TCGA_OV': 'Ovarian'
      };
      result.rows.forEach(function (row) {
        annotatorMeasuredSeries[row.doc.seriesUID] = true;
      }); // now reconcile the data
      // - look through each available series
      // -- if nobody has measured it then use it
      // - if the user already measured it, ignore it
      // - otherwise find the least measured one

      var leastMeasured = {
        seriesUID: undefined,
        measurementCount: Number.MAX_SAFE_INTEGER
      };
      var caseDetails;

      var _loop = function _loop(seriesIndex) {
        var seriesUID = seriesUIDs[seriesIndex];

        if (!(seriesUID in measurementsPerSeries)) {
          caseDetails = cases.find(function (c) {
            return c.key[0] === seriesUID;
          }).key;
          console.log('Next Case Category:', caseDetails);
          $('#patient-id-upper-right').text(caseDetails[2]);
          $('#category-upper-right').text(categoryIdToLabelMap[caseDetails[1]]);
          return {
            v: seriesUID
          };
        }

        if (!(seriesUID in annotatorMeasuredSeries) && measurementsPerSeries[seriesUID] < leastMeasured.measurementCount) {
          leastMeasured.seriesUID = seriesUID;
          leastMeasured.measurementCount = measurementsPerSeries[seriesUID];
        }
      };

      for (var seriesIndex = 0; seriesIndex < seriesUIDs.length; seriesIndex++) {
        var _ret = _loop(seriesIndex);

        if (_typeof(_ret) === "object") return _ret.v;
      }

      caseDetails = cases.find(function (c) {
        return c.key[0] === leastMeasured.seriesUID;
      }).key;
      console.log('Next Case Category:', caseDetails);
      $('#patient-id-upper-right').text(caseDetails[2]);
      $('#category-upper-right').text(categoryIdToLabelMap[caseDetails[1]]);
      return leastMeasured.seriesUID;
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGVzLmpzIl0sIm5hbWVzIjpbImdldENhc2VJbWFnZXMiLCIkb3ZlcmxheSIsIiQiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiZ2V0Q2hyb25pY2xlSW1hZ2VJRHMiLCJ0aGVuIiwiY2FzZVN0dWR5IiwidXJscyIsIkVycm9yIiwid2luZG93IiwicnNuYUNyb3dkUXVhbnRTZXJpZXNVSUQiLCJzZXJpZXNVSUQiLCJyc25hQ3Jvd2RRdWFudENhc2VTdHVkeSIsIm1hcCIsInVybCIsInJlcGxhY2UiLCJjdXJyZW50U2VyaWVzSW5kZXgiLCJ1bmRlZmluZWQiLCJzZXJpZXNVSURfQSIsImFsbENhc2VzIiwidXNlckNhc2VzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjb25zb2xlIiwibG9nIiwiYWxlcnQiLCJsb2NhdGlvbiIsInJlbG9hZCIsImNocm9uaWNsZURCIiwicXVlcnkiLCJzdGFydGtleSIsImVuZGtleSIsInN0YWxlIiwicmVkdWNlIiwiZGF0YSIsImluc3RhbmNlVUlEcyIsInJvd3MiLCJmb3JFYWNoIiwicm93IiwiaW5zdGFuY2VVSUQiLCJ2YWx1ZSIsInB1c2giLCJ0aW1lIiwiYWxsIiwidWlkIiwiZ2V0IiwiZG9jcyIsInRpbWVFbmQiLCJpbnN0YW5jZU51bWJlclRhZyIsImluc3RhbmNlVUlEc0J5SW1hZ2VOdW1iZXIiLCJkb2MiLCJpbWFnZU51bWJlciIsIk51bWJlciIsImRhdGFzZXQiLCJWYWx1ZSIsIl9pZCIsImltYWdlTnVtYmVycyIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwiYSIsImIiLCJpbnN0YW5jZVVSTHMiLCJpbnN0YW5jZVVSTCIsImNocm9uaWNsZVVSTCIsIm5hbWUiLCJjYXRjaCIsImVyciIsImdldE5leHRTZXJpZXNGb3JBbm5vdGF0b3IiLCJhbm5vdGF0b3JJRCIsImNhc2VzIiwibWVhc3VyZW1lbnRzUGVyU2VyaWVzIiwiYW5ub3RhdG9yTWVhc3VyZWRTZXJpZXMiLCJzZXJpZXNVSURzIiwiYyIsImtleSIsIm1lYXN1cmVtZW50c0RCIiwiZ3JvdXAiLCJsZXZlbCIsInJlc3VsdCIsImluY2x1ZGVfZG9jcyIsInN0YXJ0X2tleSIsImVuZF9rZXkiLCJjYXRlZ29yeUlkVG9MYWJlbE1hcCIsImxlYXN0TWVhc3VyZWQiLCJtZWFzdXJlbWVudENvdW50IiwiTUFYX1NBRkVfSU5URUdFUiIsImNhc2VEZXRhaWxzIiwic2VyaWVzSW5kZXgiLCJmaW5kIiwidGV4dCIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7ZUFFZTtBQUNiQSxFQUFBQSxhQURhLDJCQUNHO0FBQ2QsUUFBTUMsUUFBUSxHQUFHQyxDQUFDLENBQUMsa0JBQUQsQ0FBbEI7QUFDQUQsSUFBQUEsUUFBUSxDQUFDRSxRQUFULENBQWtCLFNBQWxCO0FBQ0FGLElBQUFBLFFBQVEsQ0FBQ0csV0FBVCxDQUFxQixXQUFyQjtBQUVBLFdBQU8sS0FBS0Msb0JBQUwsR0FBNEJDLElBQTVCLENBQWlDLFVBQUNDLFNBQUQsRUFBZTtBQUNyRCxVQUFJLENBQUNBLFNBQUQsSUFBYyxDQUFDQSxTQUFTLENBQUNDLElBQTdCLEVBQW1DO0FBQ2pDLGNBQU0sSUFBSUMsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDRCxPQUhvRCxDQUtyRDtBQUNBOzs7QUFDQUMsTUFBQUEsTUFBTSxDQUFDQyx1QkFBUCxHQUFpQ0osU0FBUyxDQUFDSyxTQUEzQztBQUNBRixNQUFBQSxNQUFNLENBQUNHLHVCQUFQLEdBQWlDTixTQUFqQztBQUVBLGFBQU9BLFNBQVMsQ0FBQ0MsSUFBVixDQUFlTSxHQUFmLENBQW1CLFVBQUFDLEdBQUc7QUFBQSxlQUFJQSxHQUFHLENBQUNDLE9BQUosQ0FBWSxNQUFaLEVBQW9CLFNBQXBCLENBQUo7QUFBQSxPQUF0QixDQUFQO0FBQ0QsS0FYTSxDQUFQO0FBWUQsR0FsQlk7QUFvQmJDLEVBQUFBLGtCQUFrQixFQUFFQyxTQXBCUDtBQXFCYkMsRUFBQUEsV0FBVyxFQUFFRCxTQXJCQTtBQXVCYmIsRUFBQUEsb0JBdkJhLGtDQXVCVztBQUFBOztBQUV0QixRQUFJZSxRQUFKLENBRnNCLENBRVI7O0FBQ2QsUUFBSUMsU0FBSixDQUhzQixDQUdQOztBQUVmLFdBQU9DLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQixrRUFBaEIsRUFBb0ZqQixJQUFwRixDQUEwRixVQUFDTSxTQUFELEVBQWU7QUFFOUcsVUFBRyxDQUFDLEtBQUksQ0FBQ0ssa0JBQVQsRUFBNkI7QUFDM0IsUUFBQSxLQUFJLENBQUNBLGtCQUFMLEdBQTBCLENBQTFCO0FBQ0Q7O0FBQ0QsTUFBQSxLQUFJLENBQUNBLGtCQUFMO0FBQ0FPLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGVBQVosRUFBNkIsS0FBSSxDQUFDUixrQkFBbEMsRUFOOEcsQ0FROUc7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBQSxLQUFJLENBQUNFLFdBQUwsR0FBbUJQLFNBQW5CO0FBQ0FZLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGFBQVosRUFBMkJiLFNBQTNCOztBQUVBLFVBQUlBLFNBQVMsS0FBS00sU0FBbEIsRUFBNkI7QUFDM0JRLFFBQUFBLEtBQUssQ0FBQyxxREFBRCxDQUFMO0FBQ0FoQixRQUFBQSxNQUFNLENBQUNpQixRQUFQLENBQWdCQyxNQUFoQjtBQUNEOztBQUVELGFBQU9DLGdCQUFZQyxLQUFaLENBQWtCLDJCQUFsQixFQUErQztBQUNwREMsUUFBQUEsUUFBUSxFQUFHbkIsU0FEeUM7QUFFcERvQixRQUFBQSxNQUFNLEVBQUdwQixTQUFTLEdBQUcsUUFGK0I7QUFHcERxQixRQUFBQSxLQUFLLEVBQUcsY0FINEM7QUFJcERDLFFBQUFBLE1BQU0sRUFBRztBQUoyQyxPQUEvQyxDQUFQO0FBTUQsS0E1Qk0sRUE0Qko1QixJQTVCSSxDQTRCQyxVQUFDNkIsSUFBRCxFQUFVO0FBQ2hCO0FBQ0EsVUFBTUMsWUFBWSxHQUFHLEVBQXJCO0FBQ0FELE1BQUFBLElBQUksQ0FBQ0UsSUFBTCxDQUFVQyxPQUFWLENBQWtCLFVBQUNDLEdBQUQsRUFBUztBQUN6QixZQUFNQyxXQUFXLEdBQUdELEdBQUcsQ0FBQ0UsS0FBSixDQUFVLENBQVYsQ0FBcEI7QUFDQUwsUUFBQUEsWUFBWSxDQUFDTSxJQUFiLENBQWtCRixXQUFsQjtBQUNELE9BSEQ7QUFLQWhCLE1BQUFBLE9BQU8sQ0FBQ21CLElBQVIsQ0FBYSxzQ0FBYixFQVJnQixDQVNoQjtBQUNBO0FBQ0E7O0FBQ0EsYUFBT3JCLE9BQU8sQ0FBQ3NCLEdBQVIsQ0FBWVIsWUFBWSxDQUFDdEIsR0FBYixDQUFpQixVQUFDK0IsR0FBRCxFQUFTO0FBQzNDLGVBQU9oQixnQkFBWWlCLEdBQVosQ0FBZ0JELEdBQWhCLENBQVA7QUFDRCxPQUZrQixDQUFaLENBQVA7QUFHRCxLQTNDTSxFQTJDSnZDLElBM0NJLENBMkNDLFVBQUN5QyxJQUFELEVBQVU7QUFDaEJ2QixNQUFBQSxPQUFPLENBQUN3QixPQUFSLENBQWdCLHNDQUFoQjtBQUNBLFVBQU1DLGlCQUFpQixHQUFHLFVBQTFCO0FBQ0EsVUFBSUMseUJBQXlCLEdBQUcsRUFBaEM7QUFDQUgsTUFBQUEsSUFBSSxDQUFDVCxPQUFMLENBQWEsVUFBQ2EsR0FBRCxFQUFTO0FBQ3BCLFlBQU1DLFdBQVcsR0FBR0MsTUFBTSxDQUFDRixHQUFHLENBQUNHLE9BQUosQ0FBWUwsaUJBQVosRUFBK0JNLEtBQWhDLENBQTFCO0FBQ0FMLFFBQUFBLHlCQUF5QixDQUFDRSxXQUFELENBQXpCLEdBQXlDRCxHQUFHLENBQUNLLEdBQTdDO0FBQ0QsT0FIRDtBQUtBLFVBQU1DLFlBQVksR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlULHlCQUFaLENBQXJCO0FBQ0FPLE1BQUFBLFlBQVksQ0FBQ0csSUFBYixDQUFrQixVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxlQUFVRCxDQUFDLEdBQUdDLENBQWQ7QUFBQSxPQUFsQjtBQUVBLFVBQUlDLFlBQVksR0FBRyxFQUFuQjtBQUNBLFVBQUkzQixZQUFZLEdBQUcsRUFBbkI7QUFDQXFCLE1BQUFBLFlBQVksQ0FBQ25CLE9BQWIsQ0FBcUIsVUFBQ2MsV0FBRCxFQUFpQjtBQUNwQyxZQUFNWixXQUFXLEdBQUdVLHlCQUF5QixDQUFDRSxXQUFELENBQTdDO0FBQ0EsWUFBTVksV0FBVyxhQUFNQyxnQkFBTixjQUFzQnpCLFdBQXRCLGdCQUFqQjtBQUNBdUIsUUFBQUEsWUFBWSxDQUFDckIsSUFBYixDQUFrQnNCLFdBQWxCO0FBQ0E1QixRQUFBQSxZQUFZLENBQUNNLElBQWIsQ0FBa0JGLFdBQWxCO0FBQ0QsT0FMRDtBQU9BLGFBQU87QUFDTDBCLFFBQUFBLElBQUksRUFBRSxjQUREO0FBRUx0RCxRQUFBQSxTQUFTLEVBQUUsS0FBSSxDQUFDTyxXQUZYO0FBR0xGLFFBQUFBLGtCQUFrQixFQUFFLEtBQUksQ0FBQ0Esa0JBQUwsR0FBMEIsQ0FIekM7QUFJTFQsUUFBQUEsSUFBSSxFQUFFdUQsWUFKRDtBQUtMM0IsUUFBQUEsWUFBWSxFQUFaQTtBQUxLLE9BQVA7QUFPRCxLQXZFTSxFQXVFSitCLEtBdkVJLENBdUVFLFVBQUNDLEdBQUQsRUFBUztBQUNoQixZQUFNQSxHQUFOO0FBQ0QsS0F6RU0sQ0FBUDtBQTBFRCxHQXRHWTtBQXdHYkMsRUFBQUEseUJBeEdhLHFDQXdHYUMsV0F4R2IsRUF3RzBCQyxLQXhHMUIsRUF3R2lDO0FBRTVDO0FBR0EsUUFBSUMscUJBQXFCLEdBQUcsRUFBNUI7QUFDQSxRQUFJQyx1QkFBdUIsR0FBRyxFQUE5QjtBQUNBLFFBQUlDLFVBQVUsR0FBR0gsS0FBSyxDQUFDekQsR0FBTixDQUFVLFVBQUE2RCxDQUFDLEVBQUk7QUFBRSxhQUFPQSxDQUFDLENBQUNDLEdBQUYsQ0FBTSxDQUFOLENBQVA7QUFBaUIsS0FBbEMsQ0FBakIsQ0FQNEMsQ0FTNUM7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBLFdBQU9DLG1CQUFlL0MsS0FBZixDQUFxQixvQkFBckIsRUFBMkM7QUFDaERJLE1BQUFBLE1BQU0sRUFBRSxJQUR3QztBQUVoRDRDLE1BQUFBLEtBQUssRUFBRSxJQUZ5QztBQUdoREMsTUFBQUEsS0FBSyxFQUFFO0FBSHlDLEtBQTNDLEVBSUp6RSxJQUpJLENBSUMsVUFBVTBFLE1BQVYsRUFBa0I7QUFFeEJBLE1BQUFBLE1BQU0sQ0FBQzNDLElBQVAsQ0FBWUMsT0FBWixDQUFvQixVQUFBQyxHQUFHLEVBQUk7QUFDekJpQyxRQUFBQSxxQkFBcUIsQ0FBQ2pDLEdBQUcsQ0FBQ3FDLEdBQUwsQ0FBckIsR0FBaUNyQyxHQUFHLENBQUNFLEtBQXJDO0FBQ0QsT0FGRDtBQUlBLGFBQU9vQyxtQkFBZS9DLEtBQWYsQ0FBcUIsZUFBckIsRUFBc0M7QUFDM0NJLFFBQUFBLE1BQU0sRUFBRSxLQURtQztBQUUzQytDLFFBQUFBLFlBQVksRUFBRSxJQUY2QjtBQUczQ0MsUUFBQUEsU0FBUyxFQUFFWixXQUhnQztBQUkzQ2EsUUFBQUEsT0FBTyxFQUFFYjtBQUprQyxPQUF0QyxDQUFQO0FBTUQsS0FoQk0sRUFnQkpoRSxJQWhCSSxDQWdCQyxVQUFVMEUsTUFBVixFQUFrQjtBQUV4QjtBQUNBLFVBQUlJLG9CQUFvQixHQUFHO0FBQ3ZCLHFCQUFjLE1BRFM7QUFFdkIscUJBQWMsT0FGUztBQUd2QixtQkFBWSxPQUhXO0FBSXZCLG1CQUFZO0FBSlcsT0FBM0I7QUFPQUosTUFBQUEsTUFBTSxDQUFDM0MsSUFBUCxDQUFZQyxPQUFaLENBQW9CLFVBQUFDLEdBQUcsRUFBSTtBQUN6QmtDLFFBQUFBLHVCQUF1QixDQUFDbEMsR0FBRyxDQUFDWSxHQUFKLENBQVF2QyxTQUFULENBQXZCLEdBQTZDLElBQTdDO0FBQ0QsT0FGRCxFQVZ3QixDQWN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQUl5RSxhQUFhLEdBQUc7QUFBQ3pFLFFBQUFBLFNBQVMsRUFBRU0sU0FBWjtBQUF1Qm9FLFFBQUFBLGdCQUFnQixFQUFFakMsTUFBTSxDQUFDa0M7QUFBaEQsT0FBcEI7QUFDQSxVQUFJQyxXQUFKOztBQXBCd0IsaUNBc0JmQyxXQXRCZTtBQXVCdEIsWUFBSTdFLFNBQVMsR0FBRzhELFVBQVUsQ0FBQ2UsV0FBRCxDQUExQjs7QUFDQSxZQUFLLEVBQUc3RSxTQUFTLElBQUk0RCxxQkFBaEIsQ0FBTCxFQUE4QztBQUM1Q2dCLFVBQUFBLFdBQVcsR0FBSWpCLEtBQUssQ0FBQ21CLElBQU4sQ0FBVyxVQUFBZixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ0MsR0FBRixDQUFNLENBQU4sTUFBYWhFLFNBQWpCO0FBQUEsV0FBWixFQUF3Q2dFLEdBQXZEO0FBQ0FwRCxVQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxxQkFBWixFQUFtQytELFdBQW5DO0FBQ0F0RixVQUFBQSxDQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QnlGLElBQTdCLENBQWtDSCxXQUFXLENBQUMsQ0FBRCxDQUE3QztBQUNBdEYsVUFBQUEsQ0FBQyxDQUFDLHVCQUFELENBQUQsQ0FBMkJ5RixJQUEzQixDQUFnQ1Asb0JBQW9CLENBQUNJLFdBQVcsQ0FBQyxDQUFELENBQVosQ0FBcEQ7QUFDQTtBQUFBLGVBQU81RTtBQUFQO0FBRUQ7O0FBQ0QsWUFBTSxFQUFHQSxTQUFTLElBQUk2RCx1QkFBaEIsQ0FBRCxJQUNFRCxxQkFBcUIsQ0FBQzVELFNBQUQsQ0FBckIsR0FBbUN5RSxhQUFhLENBQUNDLGdCQUR4RCxFQUM0RTtBQUMxRUQsVUFBQUEsYUFBYSxDQUFDekUsU0FBZCxHQUEwQkEsU0FBMUI7QUFDQXlFLFVBQUFBLGFBQWEsQ0FBQ0MsZ0JBQWQsR0FBaUNkLHFCQUFxQixDQUFDNUQsU0FBRCxDQUF0RDtBQUNEO0FBcENxQjs7QUFzQnhCLFdBQUssSUFBSTZFLFdBQVcsR0FBRyxDQUF2QixFQUEwQkEsV0FBVyxHQUFHZixVQUFVLENBQUNrQixNQUFuRCxFQUEyREgsV0FBVyxFQUF0RSxFQUEwRTtBQUFBLHlCQUFqRUEsV0FBaUU7O0FBQUE7QUFlekU7O0FBQ0RELE1BQUFBLFdBQVcsR0FBSWpCLEtBQUssQ0FBQ21CLElBQU4sQ0FBVyxVQUFBZixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDQyxHQUFGLENBQU0sQ0FBTixNQUFhUyxhQUFhLENBQUN6RSxTQUEvQjtBQUFBLE9BQVosRUFBc0RnRSxHQUFyRTtBQUNBcEQsTUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVkscUJBQVosRUFBbUMrRCxXQUFuQztBQUNBdEYsTUFBQUEsQ0FBQyxDQUFDLHlCQUFELENBQUQsQ0FBNkJ5RixJQUE3QixDQUFrQ0gsV0FBVyxDQUFDLENBQUQsQ0FBN0M7QUFDQXRGLE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCeUYsSUFBM0IsQ0FBZ0NQLG9CQUFvQixDQUFDSSxXQUFXLENBQUMsQ0FBRCxDQUFaLENBQXBEO0FBQ0EsYUFBT0gsYUFBYSxDQUFDekUsU0FBckI7QUFDRCxLQTNETSxDQUFQO0FBNEREO0FBcExZLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29ubmVjdG9yIGZyb20gJy4vY29ubmVjdG9yJztcbmltcG9ydCBMb2dpbiBmcm9tICcuLi9sb2dpbi9sb2dpbic7XG5pbXBvcnQge2Nocm9uaWNsZVVSTCwgY2hyb25pY2xlREIsIG1lYXN1cmVtZW50c0RCfSBmcm9tICcuLi9kYi9kYic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0Q2FzZUltYWdlcygpIHtcbiAgICBjb25zdCAkb3ZlcmxheSA9ICQoJy5sb2FkaW5nLW92ZXJsYXknKTtcbiAgICAkb3ZlcmxheS5hZGRDbGFzcygnbG9hZGluZycpO1xuICAgICRvdmVybGF5LnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcblxuICAgIHJldHVybiB0aGlzLmdldENocm9uaWNsZUltYWdlSURzKCkudGhlbigoY2FzZVN0dWR5KSA9PiB7XG4gICAgICBpZiAoIWNhc2VTdHVkeSB8fCAhY2FzZVN0dWR5LnVybHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYXNlIHN0dWR5IG9yIG5vIFVSTHMgcHJvdmlkZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlcmUgdG8gc3RvcmUgdGhlIGNhc2UgaWQgZm9yIGFjY2VzcyBkdXJpbmcgc2F2ZT9cbiAgICAgIC8vIEkgZG9uJ3QgdW5kZXJzdGFuZCB0aGUgbW9kZWwgaGllcmFyY2h5LCBzbyBsZXQncyBzdGljayBpdCBvbiB0aGUgd2luZG93XG4gICAgICB3aW5kb3cucnNuYUNyb3dkUXVhbnRTZXJpZXNVSUQgPSBjYXNlU3R1ZHkuc2VyaWVzVUlEO1xuICAgICAgd2luZG93LnJzbmFDcm93ZFF1YW50Q2FzZVN0dWR5ID0gY2FzZVN0dWR5O1xuXG4gICAgICByZXR1cm4gY2FzZVN0dWR5LnVybHMubWFwKHVybCA9PiB1cmwucmVwbGFjZSgnaHR0cCcsICd3YWRvdXJpJykpO1xuICAgIH0pO1xuICB9LFxuXG4gIGN1cnJlbnRTZXJpZXNJbmRleDogdW5kZWZpbmVkLFxuICBzZXJpZXNVSURfQTogdW5kZWZpbmVkLFxuXG4gIGdldENocm9uaWNsZUltYWdlSURzICgpIHtcblxuICAgIHZhciBhbGxDYXNlczsgLy8gdGhpcyBjb3VsZCBiZSBjYWNoZWRcbiAgICB2YXIgdXNlckNhc2VzOyAvLyBmaWx0ZXJlZCB0byB1c2VyJ3MgYW5hdENob2ljZXNcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJzEuMy42LjEuNC4xLjE0NTE5LjUuMi4xLjMwOTguNDk2My4yMDIyODc5NDg1Njg0MDYyODkwOTM3Mzc0ODU2MDUnKS50aGVuICgoc2VyaWVzVUlEKSA9PiB7XG5cbiAgICAgIGlmKCF0aGlzLmN1cnJlbnRTZXJpZXNJbmRleCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpZXNJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnRTZXJpZXNJbmRleCsrO1xuICAgICAgY29uc29sZS5sb2coJ3NlcmllcyBJbmRleDonLCB0aGlzLmN1cnJlbnRTZXJpZXNJbmRleCk7XG5cbiAgICAgIC8vY29uc3Qga2V5ID0gZGF0YS5yb3dzW3RoaXMuY3VycmVudFNlcmllc0luZGV4XS5rZXk7XG5cbiAgICAgIC8vIGlmKGN1cnJlbnRTZXJpZXNJbmRleCA+PSBkYXRhLnJvd3MubGVuZ3RoKXtcbiAgICAgIC8vICAgY3VycmVudFNlcmllc0luZGV4PTA7XG4gICAgICAvLyB9XG5cbiAgICAgIHRoaXMuc2VyaWVzVUlEX0EgPSBzZXJpZXNVSUQ7XG4gICAgICBjb25zb2xlLmxvZygnc2VyaWVzIFVJRDonLCBzZXJpZXNVSUQpO1xuXG4gICAgICBpZiAoc2VyaWVzVUlEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxlcnQoJ0NvbmdyYXR1bGF0aW9ucyAtIHlvdSBoYXZlIGxvb2tlZCBhdCBhbGwgdGhlIHNlcmllcycpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaHJvbmljbGVEQi5xdWVyeShcImluc3RhbmNlcy9zZXJpZXNJbnN0YW5jZXNcIiwge1xuICAgICAgICBzdGFydGtleSA6IHNlcmllc1VJRCxcbiAgICAgICAgZW5ka2V5IDogc2VyaWVzVUlEICsgJ1xcdTk5OTknLFxuICAgICAgICBzdGFsZSA6ICd1cGRhdGVfYWZ0ZXInLFxuICAgICAgICByZWR1Y2UgOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnN0YW5jZSBkYXRhOicsIGRhdGEpO1xuICAgICAgY29uc3QgaW5zdGFuY2VVSURzID0gW107XG4gICAgICBkYXRhLnJvd3MuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlVUlEID0gcm93LnZhbHVlWzFdO1xuICAgICAgICBpbnN0YW5jZVVJRHMucHVzaChpbnN0YW5jZVVJRCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS50aW1lKCdNZXRhZGF0YSBSZXRyaWV2YWwgZnJvbSBDaHJvbmljbGUgREInKTtcbiAgICAgIC8vIFRPRE86IFN3aXRjaCB0byBzb21lIHN0dWR5IG9yIHNlcmllcy1sZXZlbCBjYWxsXG4gICAgICAvLyBJdCBpcyBxdWl0ZSBzbG93IHRvIHdhaXQgb24gbWV0YWRhdGEgZm9yIGV2ZXJ5IHNpbmdsZSBpbWFnZVxuICAgICAgLy8gZWFjaCByZXRyaWV2ZWQgaW4gc2VwYXJhdGUgY2FsbHNcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChpbnN0YW5jZVVJRHMubWFwKCh1aWQpID0+IHtcbiAgICAgICAgcmV0dXJuIGNocm9uaWNsZURCLmdldCh1aWQpO1xuICAgICAgfSkpO1xuICAgIH0pLnRoZW4oKGRvY3MpID0+IHtcbiAgICAgIGNvbnNvbGUudGltZUVuZCgnTWV0YWRhdGEgUmV0cmlldmFsIGZyb20gQ2hyb25pY2xlIERCJyk7XG4gICAgICBjb25zdCBpbnN0YW5jZU51bWJlclRhZyA9IFwiMDAyMDAwMTNcIjtcbiAgICAgIGxldCBpbnN0YW5jZVVJRHNCeUltYWdlTnVtYmVyID0ge307XG4gICAgICBkb2NzLmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZU51bWJlciA9IE51bWJlcihkb2MuZGF0YXNldFtpbnN0YW5jZU51bWJlclRhZ10uVmFsdWUpO1xuICAgICAgICBpbnN0YW5jZVVJRHNCeUltYWdlTnVtYmVyW2ltYWdlTnVtYmVyXSA9IGRvYy5faWQ7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW1hZ2VOdW1iZXJzID0gT2JqZWN0LmtleXMoaW5zdGFuY2VVSURzQnlJbWFnZU51bWJlcik7XG4gICAgICBpbWFnZU51bWJlcnMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gICAgICBsZXQgaW5zdGFuY2VVUkxzID0gW107XG4gICAgICBsZXQgaW5zdGFuY2VVSURzID0gW107XG4gICAgICBpbWFnZU51bWJlcnMuZm9yRWFjaCgoaW1hZ2VOdW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VVSUQgPSBpbnN0YW5jZVVJRHNCeUltYWdlTnVtYmVyW2ltYWdlTnVtYmVyXTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VVUkwgPSBgJHtjaHJvbmljbGVVUkx9LyR7aW5zdGFuY2VVSUR9L29iamVjdC5kY21gO1xuICAgICAgICBpbnN0YW5jZVVSTHMucHVzaChpbnN0YW5jZVVSTCk7XG4gICAgICAgIGluc3RhbmNlVUlEcy5wdXNoKGluc3RhbmNlVUlEKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBcImRlZmF1bHRfY2FzZVwiLFxuICAgICAgICBzZXJpZXNVSUQ6IHRoaXMuc2VyaWVzVUlEX0EsXG4gICAgICAgIGN1cnJlbnRTZXJpZXNJbmRleDogdGhpcy5jdXJyZW50U2VyaWVzSW5kZXggLSAxLFxuICAgICAgICB1cmxzOiBpbnN0YW5jZVVSTHMsXG4gICAgICAgIGluc3RhbmNlVUlEc1xuICAgICAgfTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0TmV4dFNlcmllc0ZvckFubm90YXRvcihhbm5vdGF0b3JJRCwgY2FzZXMpIHtcblxuICAgIC8vIGZpbHRlciBjYXNlcyBieSBhbm5vdGF0b3IncyBhbmF0b215Q2hvaWNlc1xuXG5cbiAgICBsZXQgbWVhc3VyZW1lbnRzUGVyU2VyaWVzID0ge307XG4gICAgbGV0IGFubm90YXRvck1lYXN1cmVkU2VyaWVzID0ge307XG4gICAgbGV0IHNlcmllc1VJRHMgPSBjYXNlcy5tYXAoYyA9PiB7IHJldHVybiBjLmtleVswXSB9KTtcblxuICAgIC8vIGZpcnN0LCBnZXQgbGlzdCBvZiBhbGwgc2VyaWVzICh0aGlzIHNob3VsZCBiZSBmYWN0b3JlZCBvdXQgdG8gYmUgZ2xvYmFsIGFuZCBvbmx5IHF1ZXJpZWQgb25jZSlcbiAgICAvLyByZXN1bHQucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgLy8gICBzZXJpZXNVSURzLnB1c2gocm93LmtleVsyXVsyXSk7XG4gICAgLy8gfSk7XG5cbiAgICAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBhbGwgbWVhc3VyZW1lbnRzIHBlciBzZXJpZXMgYW5kIGhvdyBtYW55IG1lYXN1cmVtZW50c1xuICAgIC8vIChub3QgYWxsIHNlcmllcyB3aWxsIGhhdmUgYmVlbiBtZWFzdXJlZClcbiAgICByZXR1cm4gbWVhc3VyZW1lbnRzREIucXVlcnkoJ2J5L3Nlcmllc1VJRE5vU2tpcCcsIHtcbiAgICAgIHJlZHVjZTogdHJ1ZSxcbiAgICAgIGdyb3VwOiB0cnVlLFxuICAgICAgbGV2ZWw6ICdleGFjdCdcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblxuICAgICAgcmVzdWx0LnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBtZWFzdXJlbWVudHNQZXJTZXJpZXNbcm93LmtleV0gPSByb3cudmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c0RCLnF1ZXJ5KCdieS9hbm5vdGF0b3JzJywge1xuICAgICAgICByZWR1Y2U6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlX2RvY3M6IHRydWUsXG4gICAgICAgIHN0YXJ0X2tleTogYW5ub3RhdG9ySUQsXG4gICAgICAgIGVuZF9rZXk6IGFubm90YXRvcklELFxuICAgICAgfSlcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblxuICAgICAgLy8gdG9kby0gcmVtb3ZlIGR1cGxpY2F0aW9uISBzdG9yZSBvbiBhIHV0aWxzIG9iamVjdD8gb3IgdGhlIExvZ2luP1xuICAgICAgbGV0IGNhdGVnb3J5SWRUb0xhYmVsTWFwID0ge1xuICAgICAgICAgICdUQ0dBLUxVQUQnIDogJ0x1bmcnLFxuICAgICAgICAgICdUQ0dBLUxJSEMnIDogJ0xpdmVyJyxcbiAgICAgICAgICAnVENHQV9STicgOiAnUmVuYWwnLFxuICAgICAgICAgICdUQ0dBX09WJyA6ICdPdmFyaWFuJ1xuICAgICAgfTtcblxuICAgICAgcmVzdWx0LnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBhbm5vdGF0b3JNZWFzdXJlZFNlcmllc1tyb3cuZG9jLnNlcmllc1VJRF0gPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG5vdyByZWNvbmNpbGUgdGhlIGRhdGFcbiAgICAgIC8vIC0gbG9vayB0aHJvdWdoIGVhY2ggYXZhaWxhYmxlIHNlcmllc1xuICAgICAgLy8gLS0gaWYgbm9ib2R5IGhhcyBtZWFzdXJlZCBpdCB0aGVuIHVzZSBpdFxuICAgICAgLy8gLSBpZiB0aGUgdXNlciBhbHJlYWR5IG1lYXN1cmVkIGl0LCBpZ25vcmUgaXRcbiAgICAgIC8vIC0gb3RoZXJ3aXNlIGZpbmQgdGhlIGxlYXN0IG1lYXN1cmVkIG9uZVxuICAgICAgbGV0IGxlYXN0TWVhc3VyZWQgPSB7c2VyaWVzVUlEOiB1bmRlZmluZWQsIG1lYXN1cmVtZW50Q291bnQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSfTtcbiAgICAgIGxldCBjYXNlRGV0YWlscztcblxuICAgICAgZm9yIChsZXQgc2VyaWVzSW5kZXggPSAwOyBzZXJpZXNJbmRleCA8IHNlcmllc1VJRHMubGVuZ3RoOyBzZXJpZXNJbmRleCsrKSB7XG4gICAgICAgIGxldCBzZXJpZXNVSUQgPSBzZXJpZXNVSURzW3Nlcmllc0luZGV4XTtcbiAgICAgICAgaWYgKCAhIChzZXJpZXNVSUQgaW4gbWVhc3VyZW1lbnRzUGVyU2VyaWVzKSApIHtcbiAgICAgICAgICBjYXNlRGV0YWlscyA9IChjYXNlcy5maW5kKGMgPT4gYy5rZXlbMF0gPT09IHNlcmllc1VJRCkua2V5KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTmV4dCBDYXNlIENhdGVnb3J5OicsIGNhc2VEZXRhaWxzKTtcbiAgICAgICAgICAkKCcjcGF0aWVudC1pZC11cHBlci1yaWdodCcpLnRleHQoY2FzZURldGFpbHNbMl0pO1xuICAgICAgICAgICQoJyNjYXRlZ29yeS11cHBlci1yaWdodCcpLnRleHQoY2F0ZWdvcnlJZFRvTGFiZWxNYXBbY2FzZURldGFpbHNbMV1dKTtcbiAgICAgICAgICByZXR1cm4gc2VyaWVzVUlEO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAoISAoc2VyaWVzVUlEIGluIGFubm90YXRvck1lYXN1cmVkU2VyaWVzKSkgJiZcbiAgICAgICAgICAgICAgKG1lYXN1cmVtZW50c1BlclNlcmllc1tzZXJpZXNVSURdIDwgbGVhc3RNZWFzdXJlZC5tZWFzdXJlbWVudENvdW50KSApIHtcbiAgICAgICAgICBsZWFzdE1lYXN1cmVkLnNlcmllc1VJRCA9IHNlcmllc1VJRDtcbiAgICAgICAgICBsZWFzdE1lYXN1cmVkLm1lYXN1cmVtZW50Q291bnQgPSBtZWFzdXJlbWVudHNQZXJTZXJpZXNbc2VyaWVzVUlEXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZURldGFpbHMgPSAoY2FzZXMuZmluZChjID0+IGMua2V5WzBdID09PSBsZWFzdE1lYXN1cmVkLnNlcmllc1VJRCkua2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXh0IENhc2UgQ2F0ZWdvcnk6JywgY2FzZURldGFpbHMpO1xuICAgICAgJCgnI3BhdGllbnQtaWQtdXBwZXItcmlnaHQnKS50ZXh0KGNhc2VEZXRhaWxzWzJdKTtcbiAgICAgICQoJyNjYXRlZ29yeS11cHBlci1yaWdodCcpLnRleHQoY2F0ZWdvcnlJZFRvTGFiZWxNYXBbY2FzZURldGFpbHNbMV1dKTtcbiAgICAgIHJldHVybiBsZWFzdE1lYXN1cmVkLnNlcmllc1VJRDtcbiAgICB9KVxuICB9XG59XG4iXX0=
},{"../db/db":20,"../login/login":23,"./connector":28}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var cornerstoneTools = _interopRequireWildcard(require("cornerstone-tools"));

var _debounce = _interopRequireDefault(require("./debounce"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var tools = _defineProperty({
  pan: {
    mouse: cornerstoneTools.pan,
    touch: cornerstoneTools.panTouchDrag
  },
  wwwc: {
    mouse: cornerstoneTools.wwwc,
    touch: cornerstoneTools.wwwcTouchDrag
  },
  stackScroll: {
    mouse: cornerstoneTools.stackScroll,
    touch: cornerstoneTools.stackScrollTouchDrag
  },
  length: {
    mouse: cornerstoneTools.length,
    touch: cornerstoneTools.lengthTouch
  },
  zoom: {
    mouse: cornerstoneTools.zoom,
    touch: cornerstoneTools.zoomTouchDrag
  }
}, "stackScroll", {
  mouse: cornerstoneTools.stackScroll,
  touch: cornerstoneTools.stackScrollTouchDrag
});

var _default = {
  active: undefined,
  toolsSelector: '.viewer-tools',
  $cornerstoneViewport: $('#cornerstoneViewport'),
  toggleTool: function toggleTool(toolToActivate) {
    console.log("toggleTool ".concat(toolToActivate));

    if (!toolToActivate) {
      return;
    }

    var element = this.element;

    if (this.active) {
      var previousMouseTool = tools[this.active].mouse;
      var previousTouchTool = tools[this.active].touch;
      previousMouseTool.deactivate(element, 1);
      previousTouchTool.deactivate(element);
    }

    var mouseTool = tools[toolToActivate].mouse;
    var touchTool = tools[toolToActivate].touch;

    if (toolToActivate === 'pan') {
      // If the user has selected the pan tool, activate it for both left and middle
      // 3 means left mouse button and middle mouse button
      cornerstoneTools.pan.activate(element, 3);
      cornerstoneTools.zoom.activate(element, 4);
    } else if (toolToActivate === 'zoom') {
      // If the user has selected the zoom tool, activate it for both left and right
      // 5 means left mouse button and right mouse button
      cornerstoneTools.zoom.activate(element, 5);
      cornerstoneTools.pan.activate(element, 2);
    } else {
      // Otherwise, active the tool on left mouse, pan on middle, and zoom on right
      mouseTool.activate(element, 1);
      cornerstoneTools.pan.activate(element, 2);
      cornerstoneTools.zoom.activate(element, 4);
    }

    touchTool.activate(element);
    this.active = toolToActivate; // Set the element to focused, so we can properly handle keyboard events

    $(this.element).attr('tabindex', 0).focus();
  },
  initStackTool: function initStackTool(imageIds) {
    var _this = this;

    var $slider = $('.imageSlider');
    var slider = $slider[0];
    var stack = {
      currentImageIdIndex: 0,
      imageIds: imageIds
    }; // Init slider configurations

    slider.min = 0;
    slider.max = stack.imageIds.length - 1;
    slider.step = 1;
    slider.value = stack.currentImageIdIndex; // Clear any previous tool state

    cornerstoneTools.clearToolState(this.element, 'stack'); // Disable stack prefetch in case there are still queued requests

    cornerstoneTools.stackPrefetch.disable(this.element);
    cornerstoneTools.addStackStateManager(this.element, ['stack']);
    cornerstoneTools.addToolState(this.element, 'stack', stack);
    cornerstoneTools.stackPrefetch.enable(this.element);
    var element = this.element;
    var slideTimeoutTime = 5;
    var slideTimeout; // Adding input listener

    function selectImage(event) {
      // Note that we throttle requests to prevent the
      // user's ultrafast scrolling from firing requests too quickly.
      clearTimeout(slideTimeout);
      slideTimeout = setTimeout(function () {
        var newImageIdIndex = parseInt(event.currentTarget.value, 10);
        cornerstoneTools.scrollToIndex(element, newImageIdIndex);
      }, slideTimeoutTime);
    }

    $slider.off('input', selectImage);
    $slider.on('input', selectImage); // Setting the slider size

    var height = this.$cornerstoneViewport.height() - 60;
    $slider.css('width', "".concat(height, "px"));
    var debounceWindowResizeHandler = (0, _debounce.default)(function () {
      var height = _this.$cornerstoneViewport.height() - 60;
      $slider.css('width', "".concat(height, "px"));
    }, 150);
    $(window).off('resize', debounceWindowResizeHandler);
    $(window).on('resize', debounceWindowResizeHandler); // Listening to viewport stack image change, so the slider is synced

    var cornerstoneStackScrollHandler = function cornerstoneStackScrollHandler() {
      // Update the slider value
      slider.value = stack.currentImageIdIndex;
    };

    this.$cornerstoneViewport[0].removeEventListener('cornerstonestackscroll', cornerstoneStackScrollHandler);
    this.$cornerstoneViewport[0].addEventListener('cornerstonestackscroll', cornerstoneStackScrollHandler);
  },
  initInteractionTools: function initInteractionTools() {
    /*
    For touch devices, by default we activate:
    - Pinch to zoom
    - Two-finger Pan
    - Three (or more) finger Stack Scroll
     We also enable the Length tool so it is always visible
     */
    cornerstoneTools.zoomTouchPinch.activate(this.element);
    cornerstoneTools.panMultiTouch.activate(this.element);
    cornerstoneTools.panMultiTouch.setConfiguration({
      testPointers: function testPointers(eventData) {
        return eventData.numPointers === 2;
      }
    });
    cornerstoneTools.stackScrollMultiTouch.activate(this.element);
    cornerstoneTools.length.enable(this.element);
    /* For mouse devices, by default we turn on:
    - Stack scrolling by mouse wheel
    - Stack scrolling by keyboard up / down arrow keys
    - Pan with middle click
    - Zoom with right click
     */

    cornerstoneTools.stackScrollWheel.activate(this.element);
    cornerstoneTools.stackScrollKeyboard.activate(this.element);
    cornerstoneTools.pan.activate(this.element, 2);
    cornerstoneTools.zoom.activate(this.element, 4); // Set the tool font and font size
    // context.font = "[style] [variant] [weight] [size]/[line height] [font family]";

    var fontFamily = 'Roboto, OpenSans, HelveticaNeue-Light, Helvetica Neue Light, Helvetica Neue, Helvetica, Arial, Lucida Grande, sans-serif';
    cornerstoneTools.textStyle.setFont('15px ' + fontFamily); // Set the tool width

    cornerstoneTools.toolStyle.setToolWidth(2); // Set color for inactive tools

    cornerstoneTools.toolColors.setToolColor('rgb(255, 255, 0)'); // Set color for active tools

    cornerstoneTools.toolColors.setActiveColor('rgb(0, 255, 0)');
    cornerstoneTools.length.setConfiguration({
      shadow: true
    }); // Stop users from zooming in or out too far

    cornerstoneTools.zoom.setConfiguration({
      minScale: 0.3,
      maxScale: 10,
      preventZoomOutsideImage: true
    });
  },
  toolClickHandler: function toolClickHandler(event) {
    var $element = $(event.currentTarget);
    var tool = $element.attr('data-tool');
    $('.active').removeClass('active');
    this.toggleTool(tool);
    $element.addClass('active');
  },
  attachEvents: function attachEvents() {
    // Extract which tool we are using and activating it
    $(this.toolsSelector).off('click', 'div[data-tool]', this.toolClickHandler.bind(this));
    $(this.toolsSelector).on('click', 'div[data-tool]', this.toolClickHandler.bind(this)); // Limiting measurements to 1

    function handleMeasurementAdded(event) {
      // Only handle Length measurements
      var toolType = 'length';

      if (event.detail.toolType !== toolType) {
        return;
      } // Retrieve the current image


      var element = event.detail.element;
      var image = cornerstone.getImage(element);
      var viewport = cornerstone.getViewport(element);
      var currentImageId = image.imageId; // When a new measurement is added, retrieve the current tool state

      var toolStateManager = cornerstoneTools.globalImageIdSpecificToolStateManager;
      var toolState = toolStateManager.saveToolState(); // Loop through all of the images (toolState is keyed by imageId)

      Object.keys(toolState).forEach(function (imageId) {
        // Delete all length measurements on images that are not the
        // current image
        if (imageId !== currentImageId) {
          delete toolState[imageId][toolType];
        }
      }); // Retrieve all of the length measurements on the current image

      var lengthMeasurements = toolState[currentImageId][toolType].data; // If there is more than length measurement, remove the oldest one

      if (lengthMeasurements.length > 1) {
        lengthMeasurements.shift();
      } // Add some viewport details to the length measurement data


      lengthMeasurements[0].windowWidth = viewport.voi.windowWidth;
      lengthMeasurements[0].windowCenter = viewport.voi.windowCenter;
      lengthMeasurements[0].scale = viewport.scale;
      lengthMeasurements[0].translation = viewport.translation; // Re-save this data into the toolState object

      toolState[currentImageId][toolType].data = lengthMeasurements; // Restore toolState into the toolStateManager

      toolStateManager.restoreToolState(toolState); // Update the image

      cornerstone.updateImage(element);
    }

    this.element.removeEventListener('cornerstonetoolsmeasurementadded', handleMeasurementAdded);
    this.element.addEventListener('cornerstonetoolsmeasurementadded', handleMeasurementAdded);
  },
  initTools: function initTools(imageIds) {
    cornerstoneTools.mouseInput.enable(this.element);
    cornerstoneTools.touchInput.enable(this.element);
    cornerstoneTools.mouseWheelInput.enable(this.element);
    cornerstoneTools.keyboardInput.enable(this.element);
    this.initInteractionTools(); // If a previously active tool exists, re-enable it.
    // If not, use wwwc

    var toolToActivate = this.active || 'wwwc';
    this.toggleTool(toolToActivate); // Remove the 'active' highlight from the other tools

    $("".concat(this.toolsSelector, " .active")).removeClass('.active'); // Add it to our desired tool

    $("".concat(this.toolsSelector, " div[data-tool=").concat(toolToActivate, "]")).addClass('active');
    this.attachEvents();
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRvb2xzLmpzIl0sIm5hbWVzIjpbInRvb2xzIiwicGFuIiwibW91c2UiLCJjb3JuZXJzdG9uZVRvb2xzIiwidG91Y2giLCJwYW5Ub3VjaERyYWciLCJ3d3djIiwid3d3Y1RvdWNoRHJhZyIsInN0YWNrU2Nyb2xsIiwic3RhY2tTY3JvbGxUb3VjaERyYWciLCJsZW5ndGgiLCJsZW5ndGhUb3VjaCIsInpvb20iLCJ6b29tVG91Y2hEcmFnIiwiYWN0aXZlIiwidW5kZWZpbmVkIiwidG9vbHNTZWxlY3RvciIsIiRjb3JuZXJzdG9uZVZpZXdwb3J0IiwiJCIsInRvZ2dsZVRvb2wiLCJ0b29sVG9BY3RpdmF0ZSIsImNvbnNvbGUiLCJsb2ciLCJlbGVtZW50IiwicHJldmlvdXNNb3VzZVRvb2wiLCJwcmV2aW91c1RvdWNoVG9vbCIsImRlYWN0aXZhdGUiLCJtb3VzZVRvb2wiLCJ0b3VjaFRvb2wiLCJhY3RpdmF0ZSIsImF0dHIiLCJmb2N1cyIsImluaXRTdGFja1Rvb2wiLCJpbWFnZUlkcyIsIiRzbGlkZXIiLCJzbGlkZXIiLCJzdGFjayIsImN1cnJlbnRJbWFnZUlkSW5kZXgiLCJtaW4iLCJtYXgiLCJzdGVwIiwidmFsdWUiLCJjbGVhclRvb2xTdGF0ZSIsInN0YWNrUHJlZmV0Y2giLCJkaXNhYmxlIiwiYWRkU3RhY2tTdGF0ZU1hbmFnZXIiLCJhZGRUb29sU3RhdGUiLCJlbmFibGUiLCJzbGlkZVRpbWVvdXRUaW1lIiwic2xpZGVUaW1lb3V0Iiwic2VsZWN0SW1hZ2UiLCJldmVudCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJuZXdJbWFnZUlkSW5kZXgiLCJwYXJzZUludCIsImN1cnJlbnRUYXJnZXQiLCJzY3JvbGxUb0luZGV4Iiwib2ZmIiwib24iLCJoZWlnaHQiLCJjc3MiLCJkZWJvdW5jZVdpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJ3aW5kb3ciLCJjb3JuZXJzdG9uZVN0YWNrU2Nyb2xsSGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdEludGVyYWN0aW9uVG9vbHMiLCJ6b29tVG91Y2hQaW5jaCIsInBhbk11bHRpVG91Y2giLCJzZXRDb25maWd1cmF0aW9uIiwidGVzdFBvaW50ZXJzIiwiZXZlbnREYXRhIiwibnVtUG9pbnRlcnMiLCJzdGFja1Njcm9sbE11bHRpVG91Y2giLCJzdGFja1Njcm9sbFdoZWVsIiwic3RhY2tTY3JvbGxLZXlib2FyZCIsImZvbnRGYW1pbHkiLCJ0ZXh0U3R5bGUiLCJzZXRGb250IiwidG9vbFN0eWxlIiwic2V0VG9vbFdpZHRoIiwidG9vbENvbG9ycyIsInNldFRvb2xDb2xvciIsInNldEFjdGl2ZUNvbG9yIiwic2hhZG93IiwibWluU2NhbGUiLCJtYXhTY2FsZSIsInByZXZlbnRab29tT3V0c2lkZUltYWdlIiwidG9vbENsaWNrSGFuZGxlciIsIiRlbGVtZW50IiwidG9vbCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJhdHRhY2hFdmVudHMiLCJiaW5kIiwiaGFuZGxlTWVhc3VyZW1lbnRBZGRlZCIsInRvb2xUeXBlIiwiZGV0YWlsIiwiaW1hZ2UiLCJjb3JuZXJzdG9uZSIsImdldEltYWdlIiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsImN1cnJlbnRJbWFnZUlkIiwiaW1hZ2VJZCIsInRvb2xTdGF0ZU1hbmFnZXIiLCJnbG9iYWxJbWFnZUlkU3BlY2lmaWNUb29sU3RhdGVNYW5hZ2VyIiwidG9vbFN0YXRlIiwic2F2ZVRvb2xTdGF0ZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwibGVuZ3RoTWVhc3VyZW1lbnRzIiwiZGF0YSIsInNoaWZ0Iiwid2luZG93V2lkdGgiLCJ2b2kiLCJ3aW5kb3dDZW50ZXIiLCJzY2FsZSIsInRyYW5zbGF0aW9uIiwicmVzdG9yZVRvb2xTdGF0ZSIsInVwZGF0ZUltYWdlIiwiaW5pdFRvb2xzIiwibW91c2VJbnB1dCIsInRvdWNoSW5wdXQiLCJtb3VzZVdoZWVsSW5wdXQiLCJrZXlib2FyZElucHV0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7O0FBRUEsSUFBTUEsS0FBSztBQUNUQyxFQUFBQSxHQUFHLEVBQUU7QUFDSEMsSUFBQUEsS0FBSyxFQUFFQyxnQkFBZ0IsQ0FBQ0YsR0FEckI7QUFFSEcsSUFBQUEsS0FBSyxFQUFFRCxnQkFBZ0IsQ0FBQ0U7QUFGckIsR0FESTtBQUtUQyxFQUFBQSxJQUFJLEVBQUU7QUFDSkosSUFBQUEsS0FBSyxFQUFFQyxnQkFBZ0IsQ0FBQ0csSUFEcEI7QUFFSkYsSUFBQUEsS0FBSyxFQUFFRCxnQkFBZ0IsQ0FBQ0k7QUFGcEIsR0FMRztBQVNUQyxFQUFBQSxXQUFXLEVBQUU7QUFDWE4sSUFBQUEsS0FBSyxFQUFFQyxnQkFBZ0IsQ0FBQ0ssV0FEYjtBQUVYSixJQUFBQSxLQUFLLEVBQUVELGdCQUFnQixDQUFDTTtBQUZiLEdBVEo7QUFhVEMsRUFBQUEsTUFBTSxFQUFFO0FBQ05SLElBQUFBLEtBQUssRUFBRUMsZ0JBQWdCLENBQUNPLE1BRGxCO0FBRU5OLElBQUFBLEtBQUssRUFBRUQsZ0JBQWdCLENBQUNRO0FBRmxCLEdBYkM7QUFpQlRDLEVBQUFBLElBQUksRUFBRTtBQUNKVixJQUFBQSxLQUFLLEVBQUVDLGdCQUFnQixDQUFDUyxJQURwQjtBQUVKUixJQUFBQSxLQUFLLEVBQUVELGdCQUFnQixDQUFDVTtBQUZwQjtBQWpCRyxrQkFxQkk7QUFDWFgsRUFBQUEsS0FBSyxFQUFFQyxnQkFBZ0IsQ0FBQ0ssV0FEYjtBQUVYSixFQUFBQSxLQUFLLEVBQUVELGdCQUFnQixDQUFDTTtBQUZiLENBckJKLENBQVg7O2VBMkJlO0FBQ2JLLEVBQUFBLE1BQU0sRUFBRUMsU0FESztBQUViQyxFQUFBQSxhQUFhLEVBQUUsZUFGRjtBQUdiQyxFQUFBQSxvQkFBb0IsRUFBRUMsQ0FBQyxDQUFDLHNCQUFELENBSFY7QUFJYkMsRUFBQUEsVUFKYSxzQkFJRkMsY0FKRSxFQUljO0FBQ3pCQyxJQUFBQSxPQUFPLENBQUNDLEdBQVIsc0JBQTBCRixjQUExQjs7QUFDQSxRQUFJLENBQUNBLGNBQUwsRUFBcUI7QUFDbkI7QUFDRDs7QUFFRCxRQUFNRyxPQUFPLEdBQUcsS0FBS0EsT0FBckI7O0FBRUEsUUFBSSxLQUFLVCxNQUFULEVBQWlCO0FBQ2YsVUFBTVUsaUJBQWlCLEdBQUd4QixLQUFLLENBQUMsS0FBS2MsTUFBTixDQUFMLENBQW1CWixLQUE3QztBQUNBLFVBQU11QixpQkFBaUIsR0FBR3pCLEtBQUssQ0FBQyxLQUFLYyxNQUFOLENBQUwsQ0FBbUJWLEtBQTdDO0FBQ0FvQixNQUFBQSxpQkFBaUIsQ0FBQ0UsVUFBbEIsQ0FBNkJILE9BQTdCLEVBQXNDLENBQXRDO0FBQ0FFLE1BQUFBLGlCQUFpQixDQUFDQyxVQUFsQixDQUE2QkgsT0FBN0I7QUFDRDs7QUFFRCxRQUFNSSxTQUFTLEdBQUczQixLQUFLLENBQUNvQixjQUFELENBQUwsQ0FBc0JsQixLQUF4QztBQUNBLFFBQU0wQixTQUFTLEdBQUc1QixLQUFLLENBQUNvQixjQUFELENBQUwsQ0FBc0JoQixLQUF4Qzs7QUFFQSxRQUFJZ0IsY0FBYyxLQUFLLEtBQXZCLEVBQThCO0FBQzVCO0FBQ0E7QUFDQWpCLE1BQUFBLGdCQUFnQixDQUFDRixHQUFqQixDQUFxQjRCLFFBQXJCLENBQThCTixPQUE5QixFQUF1QyxDQUF2QztBQUNBcEIsTUFBQUEsZ0JBQWdCLENBQUNTLElBQWpCLENBQXNCaUIsUUFBdEIsQ0FBK0JOLE9BQS9CLEVBQXdDLENBQXhDO0FBQ0QsS0FMRCxNQUtPLElBQUlILGNBQWMsS0FBSyxNQUF2QixFQUErQjtBQUNwQztBQUNBO0FBQ0FqQixNQUFBQSxnQkFBZ0IsQ0FBQ1MsSUFBakIsQ0FBc0JpQixRQUF0QixDQUErQk4sT0FBL0IsRUFBd0MsQ0FBeEM7QUFDQXBCLE1BQUFBLGdCQUFnQixDQUFDRixHQUFqQixDQUFxQjRCLFFBQXJCLENBQThCTixPQUE5QixFQUF1QyxDQUF2QztBQUNELEtBTE0sTUFLQTtBQUNMO0FBQ0FJLE1BQUFBLFNBQVMsQ0FBQ0UsUUFBVixDQUFtQk4sT0FBbkIsRUFBNEIsQ0FBNUI7QUFDQXBCLE1BQUFBLGdCQUFnQixDQUFDRixHQUFqQixDQUFxQjRCLFFBQXJCLENBQThCTixPQUE5QixFQUF1QyxDQUF2QztBQUNBcEIsTUFBQUEsZ0JBQWdCLENBQUNTLElBQWpCLENBQXNCaUIsUUFBdEIsQ0FBK0JOLE9BQS9CLEVBQXdDLENBQXhDO0FBQ0Q7O0FBRURLLElBQUFBLFNBQVMsQ0FBQ0MsUUFBVixDQUFtQk4sT0FBbkI7QUFFQSxTQUFLVCxNQUFMLEdBQWNNLGNBQWQsQ0FyQ3lCLENBdUN6Qjs7QUFDQUYsSUFBQUEsQ0FBQyxDQUFDLEtBQUtLLE9BQU4sQ0FBRCxDQUFnQk8sSUFBaEIsQ0FBcUIsVUFBckIsRUFBaUMsQ0FBakMsRUFBb0NDLEtBQXBDO0FBQ0QsR0E3Q1k7QUErQ2JDLEVBQUFBLGFBL0NhLHlCQStDQ0MsUUEvQ0QsRUErQ1c7QUFBQTs7QUFDdEIsUUFBTUMsT0FBTyxHQUFHaEIsQ0FBQyxDQUFDLGNBQUQsQ0FBakI7QUFDQSxRQUFNaUIsTUFBTSxHQUFHRCxPQUFPLENBQUMsQ0FBRCxDQUF0QjtBQUNBLFFBQU1FLEtBQUssR0FBRztBQUNaQyxNQUFBQSxtQkFBbUIsRUFBRSxDQURUO0FBRVpKLE1BQUFBLFFBQVEsRUFBRUE7QUFGRSxLQUFkLENBSHNCLENBUXRCOztBQUNBRSxJQUFBQSxNQUFNLENBQUNHLEdBQVAsR0FBYSxDQUFiO0FBQ0FILElBQUFBLE1BQU0sQ0FBQ0ksR0FBUCxHQUFhSCxLQUFLLENBQUNILFFBQU4sQ0FBZXZCLE1BQWYsR0FBd0IsQ0FBckM7QUFDQXlCLElBQUFBLE1BQU0sQ0FBQ0ssSUFBUCxHQUFjLENBQWQ7QUFDQUwsSUFBQUEsTUFBTSxDQUFDTSxLQUFQLEdBQWVMLEtBQUssQ0FBQ0MsbUJBQXJCLENBWnNCLENBY3RCOztBQUNBbEMsSUFBQUEsZ0JBQWdCLENBQUN1QyxjQUFqQixDQUFnQyxLQUFLbkIsT0FBckMsRUFBOEMsT0FBOUMsRUFmc0IsQ0FpQnRCOztBQUNBcEIsSUFBQUEsZ0JBQWdCLENBQUN3QyxhQUFqQixDQUErQkMsT0FBL0IsQ0FBdUMsS0FBS3JCLE9BQTVDO0FBRUFwQixJQUFBQSxnQkFBZ0IsQ0FBQzBDLG9CQUFqQixDQUFzQyxLQUFLdEIsT0FBM0MsRUFBb0QsQ0FBQyxPQUFELENBQXBEO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQzJDLFlBQWpCLENBQThCLEtBQUt2QixPQUFuQyxFQUE0QyxPQUE1QyxFQUFxRGEsS0FBckQ7QUFDQWpDLElBQUFBLGdCQUFnQixDQUFDd0MsYUFBakIsQ0FBK0JJLE1BQS9CLENBQXNDLEtBQUt4QixPQUEzQztBQUVBLFFBQU1BLE9BQU8sR0FBRyxLQUFLQSxPQUFyQjtBQUNBLFFBQU15QixnQkFBZ0IsR0FBRyxDQUF6QjtBQUNBLFFBQUlDLFlBQUosQ0ExQnNCLENBNEJ0Qjs7QUFDQSxhQUFTQyxXQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUMxQjtBQUNBO0FBQ0FDLE1BQUFBLFlBQVksQ0FBQ0gsWUFBRCxDQUFaO0FBQ0FBLE1BQUFBLFlBQVksR0FBR0ksVUFBVSxDQUFDLFlBQU07QUFDOUIsWUFBTUMsZUFBZSxHQUFHQyxRQUFRLENBQUNKLEtBQUssQ0FBQ0ssYUFBTixDQUFvQmYsS0FBckIsRUFBNEIsRUFBNUIsQ0FBaEM7QUFDQXRDLFFBQUFBLGdCQUFnQixDQUFDc0QsYUFBakIsQ0FBK0JsQyxPQUEvQixFQUF3QytCLGVBQXhDO0FBQ0QsT0FId0IsRUFHdEJOLGdCQUhzQixDQUF6QjtBQUlEOztBQUVEZCxJQUFBQSxPQUFPLENBQUN3QixHQUFSLENBQVksT0FBWixFQUFxQlIsV0FBckI7QUFDQWhCLElBQUFBLE9BQU8sQ0FBQ3lCLEVBQVIsQ0FBVyxPQUFYLEVBQW9CVCxXQUFwQixFQXhDc0IsQ0EwQ3RCOztBQUNBLFFBQU1VLE1BQU0sR0FBRyxLQUFLM0Msb0JBQUwsQ0FBMEIyQyxNQUExQixLQUFxQyxFQUFwRDtBQUNBMUIsSUFBQUEsT0FBTyxDQUFDMkIsR0FBUixDQUFZLE9BQVosWUFBd0JELE1BQXhCO0FBRUEsUUFBTUUsMkJBQTJCLEdBQUcsdUJBQVMsWUFBTTtBQUNqRCxVQUFNRixNQUFNLEdBQUcsS0FBSSxDQUFDM0Msb0JBQUwsQ0FBMEIyQyxNQUExQixLQUFxQyxFQUFwRDtBQUNBMUIsTUFBQUEsT0FBTyxDQUFDMkIsR0FBUixDQUFZLE9BQVosWUFBd0JELE1BQXhCO0FBQ0QsS0FIbUMsRUFHakMsR0FIaUMsQ0FBcEM7QUFLQTFDLElBQUFBLENBQUMsQ0FBQzZDLE1BQUQsQ0FBRCxDQUFVTCxHQUFWLENBQWMsUUFBZCxFQUF3QkksMkJBQXhCO0FBQ0E1QyxJQUFBQSxDQUFDLENBQUM2QyxNQUFELENBQUQsQ0FBVUosRUFBVixDQUFhLFFBQWIsRUFBdUJHLDJCQUF2QixFQXBEc0IsQ0FzRHRCOztBQUNBLFFBQU1FLDZCQUE2QixHQUFHLFNBQWhDQSw2QkFBZ0MsR0FBWTtBQUNoRDtBQUNBN0IsTUFBQUEsTUFBTSxDQUFDTSxLQUFQLEdBQWVMLEtBQUssQ0FBQ0MsbUJBQXJCO0FBQ0QsS0FIRDs7QUFLQSxTQUFLcEIsb0JBQUwsQ0FBMEIsQ0FBMUIsRUFBNkJnRCxtQkFBN0IsQ0FBaUQsd0JBQWpELEVBQTJFRCw2QkFBM0U7QUFDQSxTQUFLL0Msb0JBQUwsQ0FBMEIsQ0FBMUIsRUFBNkJpRCxnQkFBN0IsQ0FBOEMsd0JBQTlDLEVBQXdFRiw2QkFBeEU7QUFDRCxHQTdHWTtBQStHYkcsRUFBQUEsb0JBL0dhLGtDQStHVTtBQUNyQjs7Ozs7OztBQVFBaEUsSUFBQUEsZ0JBQWdCLENBQUNpRSxjQUFqQixDQUFnQ3ZDLFFBQWhDLENBQXlDLEtBQUtOLE9BQTlDO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQ2tFLGFBQWpCLENBQStCeEMsUUFBL0IsQ0FBd0MsS0FBS04sT0FBN0M7QUFDQXBCLElBQUFBLGdCQUFnQixDQUFDa0UsYUFBakIsQ0FBK0JDLGdCQUEvQixDQUFnRDtBQUM1Q0MsTUFBQUEsWUFBWSxFQUFFLHNCQUFDQyxTQUFEO0FBQUEsZUFBZ0JBLFNBQVMsQ0FBQ0MsV0FBVixLQUEwQixDQUExQztBQUFBO0FBRDhCLEtBQWhEO0FBR0F0RSxJQUFBQSxnQkFBZ0IsQ0FBQ3VFLHFCQUFqQixDQUF1QzdDLFFBQXZDLENBQWdELEtBQUtOLE9BQXJEO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQ08sTUFBakIsQ0FBd0JxQyxNQUF4QixDQUErQixLQUFLeEIsT0FBcEM7QUFFQTs7Ozs7OztBQU1BcEIsSUFBQUEsZ0JBQWdCLENBQUN3RSxnQkFBakIsQ0FBa0M5QyxRQUFsQyxDQUEyQyxLQUFLTixPQUFoRDtBQUNBcEIsSUFBQUEsZ0JBQWdCLENBQUN5RSxtQkFBakIsQ0FBcUMvQyxRQUFyQyxDQUE4QyxLQUFLTixPQUFuRDtBQUNBcEIsSUFBQUEsZ0JBQWdCLENBQUNGLEdBQWpCLENBQXFCNEIsUUFBckIsQ0FBOEIsS0FBS04sT0FBbkMsRUFBNEMsQ0FBNUM7QUFDQXBCLElBQUFBLGdCQUFnQixDQUFDUyxJQUFqQixDQUFzQmlCLFFBQXRCLENBQStCLEtBQUtOLE9BQXBDLEVBQTZDLENBQTdDLEVBMUJxQixDQTRCckI7QUFDQTs7QUFDQSxRQUFNc0QsVUFBVSxHQUFHLDBIQUFuQjtBQUNBMUUsSUFBQUEsZ0JBQWdCLENBQUMyRSxTQUFqQixDQUEyQkMsT0FBM0IsQ0FBbUMsVUFBVUYsVUFBN0MsRUEvQnFCLENBaUNyQjs7QUFDQTFFLElBQUFBLGdCQUFnQixDQUFDNkUsU0FBakIsQ0FBMkJDLFlBQTNCLENBQXdDLENBQXhDLEVBbENxQixDQW9DckI7O0FBQ0E5RSxJQUFBQSxnQkFBZ0IsQ0FBQytFLFVBQWpCLENBQTRCQyxZQUE1QixDQUF5QyxrQkFBekMsRUFyQ3FCLENBdUNyQjs7QUFDQWhGLElBQUFBLGdCQUFnQixDQUFDK0UsVUFBakIsQ0FBNEJFLGNBQTVCLENBQTJDLGdCQUEzQztBQUVBakYsSUFBQUEsZ0JBQWdCLENBQUNPLE1BQWpCLENBQXdCNEQsZ0JBQXhCLENBQXlDO0FBQUNlLE1BQUFBLE1BQU0sRUFBRTtBQUFULEtBQXpDLEVBMUNxQixDQTRDckI7O0FBQ0FsRixJQUFBQSxnQkFBZ0IsQ0FBQ1MsSUFBakIsQ0FBc0IwRCxnQkFBdEIsQ0FBdUM7QUFDbkNnQixNQUFBQSxRQUFRLEVBQUUsR0FEeUI7QUFFbkNDLE1BQUFBLFFBQVEsRUFBRSxFQUZ5QjtBQUduQ0MsTUFBQUEsdUJBQXVCLEVBQUU7QUFIVSxLQUF2QztBQUtELEdBaktZO0FBbUtiQyxFQUFBQSxnQkFuS2EsNEJBbUtJdEMsS0FuS0osRUFtS1c7QUFDdEIsUUFBTXVDLFFBQVEsR0FBR3hFLENBQUMsQ0FBQ2lDLEtBQUssQ0FBQ0ssYUFBUCxDQUFsQjtBQUNBLFFBQU1tQyxJQUFJLEdBQUdELFFBQVEsQ0FBQzVELElBQVQsQ0FBYyxXQUFkLENBQWI7QUFFQVosSUFBQUEsQ0FBQyxDQUFDLFNBQUQsQ0FBRCxDQUFhMEUsV0FBYixDQUF5QixRQUF6QjtBQUVBLFNBQUt6RSxVQUFMLENBQWdCd0UsSUFBaEI7QUFFQUQsSUFBQUEsUUFBUSxDQUFDRyxRQUFULENBQWtCLFFBQWxCO0FBQ0QsR0E1S1k7QUE4S2JDLEVBQUFBLFlBOUthLDBCQThLRTtBQUNiO0FBQ0E1RSxJQUFBQSxDQUFDLENBQUMsS0FBS0YsYUFBTixDQUFELENBQXNCMEMsR0FBdEIsQ0FBMEIsT0FBMUIsRUFBbUMsZ0JBQW5DLEVBQXFELEtBQUsrQixnQkFBTCxDQUFzQk0sSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBckQ7QUFDQTdFLElBQUFBLENBQUMsQ0FBQyxLQUFLRixhQUFOLENBQUQsQ0FBc0IyQyxFQUF0QixDQUF5QixPQUF6QixFQUFrQyxnQkFBbEMsRUFBb0QsS0FBSzhCLGdCQUFMLENBQXNCTSxJQUF0QixDQUEyQixJQUEzQixDQUFwRCxFQUhhLENBS2I7O0FBQ0EsYUFBU0Msc0JBQVQsQ0FBaUM3QyxLQUFqQyxFQUF3QztBQUN0QztBQUNBLFVBQU04QyxRQUFRLEdBQUcsUUFBakI7O0FBQ0EsVUFBSTlDLEtBQUssQ0FBQytDLE1BQU4sQ0FBYUQsUUFBYixLQUEwQkEsUUFBOUIsRUFBd0M7QUFDdEM7QUFDRCxPQUxxQyxDQU90Qzs7O0FBQ0EsVUFBTTFFLE9BQU8sR0FBRzRCLEtBQUssQ0FBQytDLE1BQU4sQ0FBYTNFLE9BQTdCO0FBQ0EsVUFBTTRFLEtBQUssR0FBR0MsV0FBVyxDQUFDQyxRQUFaLENBQXFCOUUsT0FBckIsQ0FBZDtBQUNBLFVBQU0rRSxRQUFRLEdBQUdGLFdBQVcsQ0FBQ0csV0FBWixDQUF3QmhGLE9BQXhCLENBQWpCO0FBQ0EsVUFBTWlGLGNBQWMsR0FBR0wsS0FBSyxDQUFDTSxPQUE3QixDQVhzQyxDQWF0Qzs7QUFDQSxVQUFNQyxnQkFBZ0IsR0FBR3ZHLGdCQUFnQixDQUFDd0cscUNBQTFDO0FBQ0EsVUFBTUMsU0FBUyxHQUFHRixnQkFBZ0IsQ0FBQ0csYUFBakIsRUFBbEIsQ0Fmc0MsQ0FpQnRDOztBQUNBQyxNQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWUgsU0FBWixFQUF1QkksT0FBdkIsQ0FBK0IsVUFBQVAsT0FBTyxFQUFJO0FBQ3hDO0FBQ0E7QUFDQSxZQUFJQSxPQUFPLEtBQUtELGNBQWhCLEVBQWdDO0FBQzlCLGlCQUFPSSxTQUFTLENBQUNILE9BQUQsQ0FBVCxDQUFtQlIsUUFBbkIsQ0FBUDtBQUNEO0FBQ0YsT0FORCxFQWxCc0MsQ0EwQnRDOztBQUNBLFVBQU1nQixrQkFBa0IsR0FBR0wsU0FBUyxDQUFDSixjQUFELENBQVQsQ0FBMEJQLFFBQTFCLEVBQW9DaUIsSUFBL0QsQ0EzQnNDLENBNkJ0Qzs7QUFDQSxVQUFJRCxrQkFBa0IsQ0FBQ3ZHLE1BQW5CLEdBQTRCLENBQWhDLEVBQW1DO0FBQ2pDdUcsUUFBQUEsa0JBQWtCLENBQUNFLEtBQW5CO0FBQ0QsT0FoQ3FDLENBa0N0Qzs7O0FBQ0FGLE1BQUFBLGtCQUFrQixDQUFDLENBQUQsQ0FBbEIsQ0FBc0JHLFdBQXRCLEdBQW9DZCxRQUFRLENBQUNlLEdBQVQsQ0FBYUQsV0FBakQ7QUFDQUgsTUFBQUEsa0JBQWtCLENBQUMsQ0FBRCxDQUFsQixDQUFzQkssWUFBdEIsR0FBcUNoQixRQUFRLENBQUNlLEdBQVQsQ0FBYUMsWUFBbEQ7QUFDQUwsTUFBQUEsa0JBQWtCLENBQUMsQ0FBRCxDQUFsQixDQUFzQk0sS0FBdEIsR0FBOEJqQixRQUFRLENBQUNpQixLQUF2QztBQUNBTixNQUFBQSxrQkFBa0IsQ0FBQyxDQUFELENBQWxCLENBQXNCTyxXQUF0QixHQUFvQ2xCLFFBQVEsQ0FBQ2tCLFdBQTdDLENBdENzQyxDQXdDdEM7O0FBQ0FaLE1BQUFBLFNBQVMsQ0FBQ0osY0FBRCxDQUFULENBQTBCUCxRQUExQixFQUFvQ2lCLElBQXBDLEdBQTJDRCxrQkFBM0MsQ0F6Q3NDLENBMkN0Qzs7QUFDQVAsTUFBQUEsZ0JBQWdCLENBQUNlLGdCQUFqQixDQUFrQ2IsU0FBbEMsRUE1Q3NDLENBOEN0Qzs7QUFDQVIsTUFBQUEsV0FBVyxDQUFDc0IsV0FBWixDQUF3Qm5HLE9BQXhCO0FBQ0Q7O0FBRUQsU0FBS0EsT0FBTCxDQUFhMEMsbUJBQWIsQ0FBaUMsa0NBQWpDLEVBQXFFK0Isc0JBQXJFO0FBQ0EsU0FBS3pFLE9BQUwsQ0FBYTJDLGdCQUFiLENBQThCLGtDQUE5QixFQUFrRThCLHNCQUFsRTtBQUNELEdBeE9ZO0FBME9iMkIsRUFBQUEsU0ExT2EscUJBME9IMUYsUUExT0csRUEwT087QUFDbEI5QixJQUFBQSxnQkFBZ0IsQ0FBQ3lILFVBQWpCLENBQTRCN0UsTUFBNUIsQ0FBbUMsS0FBS3hCLE9BQXhDO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQzBILFVBQWpCLENBQTRCOUUsTUFBNUIsQ0FBbUMsS0FBS3hCLE9BQXhDO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQzJILGVBQWpCLENBQWlDL0UsTUFBakMsQ0FBd0MsS0FBS3hCLE9BQTdDO0FBQ0FwQixJQUFBQSxnQkFBZ0IsQ0FBQzRILGFBQWpCLENBQStCaEYsTUFBL0IsQ0FBc0MsS0FBS3hCLE9BQTNDO0FBRUEsU0FBSzRDLG9CQUFMLEdBTmtCLENBUWxCO0FBQ0E7O0FBQ0EsUUFBTS9DLGNBQWMsR0FBRyxLQUFLTixNQUFMLElBQWUsTUFBdEM7QUFDQSxTQUFLSyxVQUFMLENBQWdCQyxjQUFoQixFQVhrQixDQWFsQjs7QUFDQUYsSUFBQUEsQ0FBQyxXQUFJLEtBQUtGLGFBQVQsY0FBRCxDQUFtQzRFLFdBQW5DLENBQStDLFNBQS9DLEVBZGtCLENBZ0JsQjs7QUFDQTFFLElBQUFBLENBQUMsV0FBSSxLQUFLRixhQUFULDRCQUF3Q0ksY0FBeEMsT0FBRCxDQUE0RHlFLFFBQTVELENBQXFFLFFBQXJFO0FBRUEsU0FBS0MsWUFBTDtBQUNEO0FBOVBZLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb3JuZXJzdG9uZVRvb2xzIGZyb20gJ2Nvcm5lcnN0b25lLXRvb2xzJztcblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xuXG5jb25zdCB0b29scyA9IHtcbiAgcGFuOiB7XG4gICAgbW91c2U6IGNvcm5lcnN0b25lVG9vbHMucGFuLFxuICAgIHRvdWNoOiBjb3JuZXJzdG9uZVRvb2xzLnBhblRvdWNoRHJhZ1xuICB9LFxuICB3d3djOiB7XG4gICAgbW91c2U6IGNvcm5lcnN0b25lVG9vbHMud3d3YyxcbiAgICB0b3VjaDogY29ybmVyc3RvbmVUb29scy53d3djVG91Y2hEcmFnXG4gIH0sXG4gIHN0YWNrU2Nyb2xsOiB7XG4gICAgbW91c2U6IGNvcm5lcnN0b25lVG9vbHMuc3RhY2tTY3JvbGwsXG4gICAgdG91Y2g6IGNvcm5lcnN0b25lVG9vbHMuc3RhY2tTY3JvbGxUb3VjaERyYWdcbiAgfSxcbiAgbGVuZ3RoOiB7XG4gICAgbW91c2U6IGNvcm5lcnN0b25lVG9vbHMubGVuZ3RoLFxuICAgIHRvdWNoOiBjb3JuZXJzdG9uZVRvb2xzLmxlbmd0aFRvdWNoXG4gIH0sXG4gIHpvb206IHtcbiAgICBtb3VzZTogY29ybmVyc3RvbmVUb29scy56b29tLFxuICAgIHRvdWNoOiBjb3JuZXJzdG9uZVRvb2xzLnpvb21Ub3VjaERyYWdcbiAgfSxcbiAgc3RhY2tTY3JvbGw6IHtcbiAgICBtb3VzZTogY29ybmVyc3RvbmVUb29scy5zdGFja1Njcm9sbCxcbiAgICB0b3VjaDogY29ybmVyc3RvbmVUb29scy5zdGFja1Njcm9sbFRvdWNoRHJhZ1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFjdGl2ZTogdW5kZWZpbmVkLFxuICB0b29sc1NlbGVjdG9yOiAnLnZpZXdlci10b29scycsXG4gICRjb3JuZXJzdG9uZVZpZXdwb3J0OiAkKCcjY29ybmVyc3RvbmVWaWV3cG9ydCcpLFxuICB0b2dnbGVUb29sKHRvb2xUb0FjdGl2YXRlKSB7XG4gICAgY29uc29sZS5sb2coYHRvZ2dsZVRvb2wgJHt0b29sVG9BY3RpdmF0ZX1gKTtcbiAgICBpZiAoIXRvb2xUb0FjdGl2YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNNb3VzZVRvb2wgPSB0b29sc1t0aGlzLmFjdGl2ZV0ubW91c2U7XG4gICAgICBjb25zdCBwcmV2aW91c1RvdWNoVG9vbCA9IHRvb2xzW3RoaXMuYWN0aXZlXS50b3VjaDtcbiAgICAgIHByZXZpb3VzTW91c2VUb29sLmRlYWN0aXZhdGUoZWxlbWVudCwgMSk7XG4gICAgICBwcmV2aW91c1RvdWNoVG9vbC5kZWFjdGl2YXRlKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdXNlVG9vbCA9IHRvb2xzW3Rvb2xUb0FjdGl2YXRlXS5tb3VzZTtcbiAgICBjb25zdCB0b3VjaFRvb2wgPSB0b29sc1t0b29sVG9BY3RpdmF0ZV0udG91Y2g7XG5cbiAgICBpZiAodG9vbFRvQWN0aXZhdGUgPT09ICdwYW4nKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlIHBhbiB0b29sLCBhY3RpdmF0ZSBpdCBmb3IgYm90aCBsZWZ0IGFuZCBtaWRkbGVcbiAgICAgIC8vIDMgbWVhbnMgbGVmdCBtb3VzZSBidXR0b24gYW5kIG1pZGRsZSBtb3VzZSBidXR0b25cbiAgICAgIGNvcm5lcnN0b25lVG9vbHMucGFuLmFjdGl2YXRlKGVsZW1lbnQsIDMpO1xuICAgICAgY29ybmVyc3RvbmVUb29scy56b29tLmFjdGl2YXRlKGVsZW1lbnQsIDQpO1xuICAgIH0gZWxzZSBpZiAodG9vbFRvQWN0aXZhdGUgPT09ICd6b29tJykge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIHRoZSB6b29tIHRvb2wsIGFjdGl2YXRlIGl0IGZvciBib3RoIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAvLyA1IG1lYW5zIGxlZnQgbW91c2UgYnV0dG9uIGFuZCByaWdodCBtb3VzZSBidXR0b25cbiAgICAgIGNvcm5lcnN0b25lVG9vbHMuem9vbS5hY3RpdmF0ZShlbGVtZW50LCA1KTtcbiAgICAgIGNvcm5lcnN0b25lVG9vbHMucGFuLmFjdGl2YXRlKGVsZW1lbnQsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGFjdGl2ZSB0aGUgdG9vbCBvbiBsZWZ0IG1vdXNlLCBwYW4gb24gbWlkZGxlLCBhbmQgem9vbSBvbiByaWdodFxuICAgICAgbW91c2VUb29sLmFjdGl2YXRlKGVsZW1lbnQsIDEpO1xuICAgICAgY29ybmVyc3RvbmVUb29scy5wYW4uYWN0aXZhdGUoZWxlbWVudCwgMik7XG4gICAgICBjb3JuZXJzdG9uZVRvb2xzLnpvb20uYWN0aXZhdGUoZWxlbWVudCwgNCk7XG4gICAgfVxuXG4gICAgdG91Y2hUb29sLmFjdGl2YXRlKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5hY3RpdmUgPSB0b29sVG9BY3RpdmF0ZTtcblxuICAgIC8vIFNldCB0aGUgZWxlbWVudCB0byBmb2N1c2VkLCBzbyB3ZSBjYW4gcHJvcGVybHkgaGFuZGxlIGtleWJvYXJkIGV2ZW50c1xuICAgICQodGhpcy5lbGVtZW50KS5hdHRyKCd0YWJpbmRleCcsIDApLmZvY3VzKCk7XG4gIH0sXG5cbiAgaW5pdFN0YWNrVG9vbChpbWFnZUlkcykge1xuICAgIGNvbnN0ICRzbGlkZXIgPSAkKCcuaW1hZ2VTbGlkZXInKTtcbiAgICBjb25zdCBzbGlkZXIgPSAkc2xpZGVyWzBdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAgY3VycmVudEltYWdlSWRJbmRleDogMCxcbiAgICAgIGltYWdlSWRzOiBpbWFnZUlkc1xuICAgIH07XG5cbiAgICAvLyBJbml0IHNsaWRlciBjb25maWd1cmF0aW9uc1xuICAgIHNsaWRlci5taW4gPSAwO1xuICAgIHNsaWRlci5tYXggPSBzdGFjay5pbWFnZUlkcy5sZW5ndGggLSAxO1xuICAgIHNsaWRlci5zdGVwID0gMTtcbiAgICBzbGlkZXIudmFsdWUgPSBzdGFjay5jdXJyZW50SW1hZ2VJZEluZGV4O1xuXG4gICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIHRvb2wgc3RhdGVcbiAgICBjb3JuZXJzdG9uZVRvb2xzLmNsZWFyVG9vbFN0YXRlKHRoaXMuZWxlbWVudCwgJ3N0YWNrJyk7XG5cbiAgICAvLyBEaXNhYmxlIHN0YWNrIHByZWZldGNoIGluIGNhc2UgdGhlcmUgYXJlIHN0aWxsIHF1ZXVlZCByZXF1ZXN0c1xuICAgIGNvcm5lcnN0b25lVG9vbHMuc3RhY2tQcmVmZXRjaC5kaXNhYmxlKHRoaXMuZWxlbWVudCk7XG5cbiAgICBjb3JuZXJzdG9uZVRvb2xzLmFkZFN0YWNrU3RhdGVNYW5hZ2VyKHRoaXMuZWxlbWVudCwgWydzdGFjayddKTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLmFkZFRvb2xTdGF0ZSh0aGlzLmVsZW1lbnQsICdzdGFjaycsIHN0YWNrKTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnN0YWNrUHJlZmV0Y2guZW5hYmxlKHRoaXMuZWxlbWVudCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IHNsaWRlVGltZW91dFRpbWUgPSA1O1xuICAgIGxldCBzbGlkZVRpbWVvdXQ7XG5cbiAgICAvLyBBZGRpbmcgaW5wdXQgbGlzdGVuZXJcbiAgICBmdW5jdGlvbiBzZWxlY3RJbWFnZShldmVudCkge1xuICAgICAgLy8gTm90ZSB0aGF0IHdlIHRocm90dGxlIHJlcXVlc3RzIHRvIHByZXZlbnQgdGhlXG4gICAgICAvLyB1c2VyJ3MgdWx0cmFmYXN0IHNjcm9sbGluZyBmcm9tIGZpcmluZyByZXF1ZXN0cyB0b28gcXVpY2tseS5cbiAgICAgIGNsZWFyVGltZW91dChzbGlkZVRpbWVvdXQpO1xuICAgICAgc2xpZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0ltYWdlSWRJbmRleCA9IHBhcnNlSW50KGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsIDEwKTtcbiAgICAgICAgY29ybmVyc3RvbmVUb29scy5zY3JvbGxUb0luZGV4KGVsZW1lbnQsIG5ld0ltYWdlSWRJbmRleCk7XG4gICAgICB9LCBzbGlkZVRpbWVvdXRUaW1lKTtcbiAgICB9XG5cbiAgICAkc2xpZGVyLm9mZignaW5wdXQnLCBzZWxlY3RJbWFnZSk7XG4gICAgJHNsaWRlci5vbignaW5wdXQnLCBzZWxlY3RJbWFnZSk7XG5cbiAgICAvLyBTZXR0aW5nIHRoZSBzbGlkZXIgc2l6ZVxuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuJGNvcm5lcnN0b25lVmlld3BvcnQuaGVpZ2h0KCkgLSA2MDtcbiAgICAkc2xpZGVyLmNzcygnd2lkdGgnLCBgJHtoZWlnaHR9cHhgKTtcblxuICAgIGNvbnN0IGRlYm91bmNlV2luZG93UmVzaXplSGFuZGxlciA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuJGNvcm5lcnN0b25lVmlld3BvcnQuaGVpZ2h0KCkgLSA2MDtcbiAgICAgICRzbGlkZXIuY3NzKCd3aWR0aCcsIGAke2hlaWdodH1weGApXG4gICAgfSwgMTUwKTtcblxuICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScsIGRlYm91bmNlV2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBkZWJvdW5jZVdpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xuXG4gICAgLy8gTGlzdGVuaW5nIHRvIHZpZXdwb3J0IHN0YWNrIGltYWdlIGNoYW5nZSwgc28gdGhlIHNsaWRlciBpcyBzeW5jZWRcbiAgICBjb25zdCBjb3JuZXJzdG9uZVN0YWNrU2Nyb2xsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc2xpZGVyIHZhbHVlXG4gICAgICBzbGlkZXIudmFsdWUgPSBzdGFjay5jdXJyZW50SW1hZ2VJZEluZGV4O1xuICAgIH07XG5cbiAgICB0aGlzLiRjb3JuZXJzdG9uZVZpZXdwb3J0WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvcm5lcnN0b25lc3RhY2tzY3JvbGwnLCBjb3JuZXJzdG9uZVN0YWNrU2Nyb2xsSGFuZGxlcik7XG4gICAgdGhpcy4kY29ybmVyc3RvbmVWaWV3cG9ydFswXS5hZGRFdmVudExpc3RlbmVyKCdjb3JuZXJzdG9uZXN0YWNrc2Nyb2xsJywgY29ybmVyc3RvbmVTdGFja1Njcm9sbEhhbmRsZXIpO1xuICB9LFxuXG4gIGluaXRJbnRlcmFjdGlvblRvb2xzKCkge1xuICAgIC8qXG4gICAgRm9yIHRvdWNoIGRldmljZXMsIGJ5IGRlZmF1bHQgd2UgYWN0aXZhdGU6XG4gICAgLSBQaW5jaCB0byB6b29tXG4gICAgLSBUd28tZmluZ2VyIFBhblxuICAgIC0gVGhyZWUgKG9yIG1vcmUpIGZpbmdlciBTdGFjayBTY3JvbGxcblxuICAgIFdlIGFsc28gZW5hYmxlIHRoZSBMZW5ndGggdG9vbCBzbyBpdCBpcyBhbHdheXMgdmlzaWJsZVxuICAgICAqL1xuICAgIGNvcm5lcnN0b25lVG9vbHMuem9vbVRvdWNoUGluY2guYWN0aXZhdGUodGhpcy5lbGVtZW50KTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnBhbk11bHRpVG91Y2guYWN0aXZhdGUodGhpcy5lbGVtZW50KTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnBhbk11bHRpVG91Y2guc2V0Q29uZmlndXJhdGlvbih7XG4gICAgICAgIHRlc3RQb2ludGVyczogKGV2ZW50RGF0YSkgPT4gKGV2ZW50RGF0YS5udW1Qb2ludGVycyA9PT0gMilcbiAgICB9KTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnN0YWNrU2Nyb2xsTXVsdGlUb3VjaC5hY3RpdmF0ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGNvcm5lcnN0b25lVG9vbHMubGVuZ3RoLmVuYWJsZSh0aGlzLmVsZW1lbnQpO1xuXG4gICAgLyogRm9yIG1vdXNlIGRldmljZXMsIGJ5IGRlZmF1bHQgd2UgdHVybiBvbjpcbiAgICAtIFN0YWNrIHNjcm9sbGluZyBieSBtb3VzZSB3aGVlbFxuICAgIC0gU3RhY2sgc2Nyb2xsaW5nIGJ5IGtleWJvYXJkIHVwIC8gZG93biBhcnJvdyBrZXlzXG4gICAgLSBQYW4gd2l0aCBtaWRkbGUgY2xpY2tcbiAgICAtIFpvb20gd2l0aCByaWdodCBjbGlja1xuICAgICAqL1xuICAgIGNvcm5lcnN0b25lVG9vbHMuc3RhY2tTY3JvbGxXaGVlbC5hY3RpdmF0ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGNvcm5lcnN0b25lVG9vbHMuc3RhY2tTY3JvbGxLZXlib2FyZC5hY3RpdmF0ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGNvcm5lcnN0b25lVG9vbHMucGFuLmFjdGl2YXRlKHRoaXMuZWxlbWVudCwgMik7XG4gICAgY29ybmVyc3RvbmVUb29scy56b29tLmFjdGl2YXRlKHRoaXMuZWxlbWVudCwgNCk7XG5cbiAgICAvLyBTZXQgdGhlIHRvb2wgZm9udCBhbmQgZm9udCBzaXplXG4gICAgLy8gY29udGV4dC5mb250ID0gXCJbc3R5bGVdIFt2YXJpYW50XSBbd2VpZ2h0XSBbc2l6ZV0vW2xpbmUgaGVpZ2h0XSBbZm9udCBmYW1pbHldXCI7XG4gICAgY29uc3QgZm9udEZhbWlseSA9ICdSb2JvdG8sIE9wZW5TYW5zLCBIZWx2ZXRpY2FOZXVlLUxpZ2h0LCBIZWx2ZXRpY2EgTmV1ZSBMaWdodCwgSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgQXJpYWwsIEx1Y2lkYSBHcmFuZGUsIHNhbnMtc2VyaWYnO1xuICAgIGNvcm5lcnN0b25lVG9vbHMudGV4dFN0eWxlLnNldEZvbnQoJzE1cHggJyArIGZvbnRGYW1pbHkpO1xuXG4gICAgLy8gU2V0IHRoZSB0b29sIHdpZHRoXG4gICAgY29ybmVyc3RvbmVUb29scy50b29sU3R5bGUuc2V0VG9vbFdpZHRoKDIpO1xuXG4gICAgLy8gU2V0IGNvbG9yIGZvciBpbmFjdGl2ZSB0b29sc1xuICAgIGNvcm5lcnN0b25lVG9vbHMudG9vbENvbG9ycy5zZXRUb29sQ29sb3IoJ3JnYigyNTUsIDI1NSwgMCknKTtcblxuICAgIC8vIFNldCBjb2xvciBmb3IgYWN0aXZlIHRvb2xzXG4gICAgY29ybmVyc3RvbmVUb29scy50b29sQ29sb3JzLnNldEFjdGl2ZUNvbG9yKCdyZ2IoMCwgMjU1LCAwKScpO1xuXG4gICAgY29ybmVyc3RvbmVUb29scy5sZW5ndGguc2V0Q29uZmlndXJhdGlvbih7c2hhZG93OiB0cnVlfSk7XG5cbiAgICAvLyBTdG9wIHVzZXJzIGZyb20gem9vbWluZyBpbiBvciBvdXQgdG9vIGZhclxuICAgIGNvcm5lcnN0b25lVG9vbHMuem9vbS5zZXRDb25maWd1cmF0aW9uKHtcbiAgICAgICAgbWluU2NhbGU6IDAuMyxcbiAgICAgICAgbWF4U2NhbGU6IDEwLFxuICAgICAgICBwcmV2ZW50Wm9vbU91dHNpZGVJbWFnZTogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIHRvb2xDbGlja0hhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCAkZWxlbWVudCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgdG9vbCA9ICRlbGVtZW50LmF0dHIoJ2RhdGEtdG9vbCcpO1xuXG4gICAgJCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblxuICAgIHRoaXMudG9nZ2xlVG9vbCh0b29sKTtcblxuICAgICRlbGVtZW50LmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgfSxcblxuICBhdHRhY2hFdmVudHMoKSB7XG4gICAgLy8gRXh0cmFjdCB3aGljaCB0b29sIHdlIGFyZSB1c2luZyBhbmQgYWN0aXZhdGluZyBpdFxuICAgICQodGhpcy50b29sc1NlbGVjdG9yKS5vZmYoJ2NsaWNrJywgJ2RpdltkYXRhLXRvb2xdJywgdGhpcy50b29sQ2xpY2tIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICQodGhpcy50b29sc1NlbGVjdG9yKS5vbignY2xpY2snLCAnZGl2W2RhdGEtdG9vbF0nLCB0aGlzLnRvb2xDbGlja0hhbmRsZXIuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBMaW1pdGluZyBtZWFzdXJlbWVudHMgdG8gMVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lYXN1cmVtZW50QWRkZWQgKGV2ZW50KSB7XG4gICAgICAvLyBPbmx5IGhhbmRsZSBMZW5ndGggbWVhc3VyZW1lbnRzXG4gICAgICBjb25zdCB0b29sVHlwZSA9ICdsZW5ndGgnO1xuICAgICAgaWYgKGV2ZW50LmRldGFpbC50b29sVHlwZSAhPT0gdG9vbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXRyaWV2ZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmRldGFpbC5lbGVtZW50O1xuICAgICAgY29uc3QgaW1hZ2UgPSBjb3JuZXJzdG9uZS5nZXRJbWFnZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29ybmVyc3RvbmUuZ2V0Vmlld3BvcnQoZWxlbWVudCk7XG4gICAgICBjb25zdCBjdXJyZW50SW1hZ2VJZCA9IGltYWdlLmltYWdlSWQ7XG5cbiAgICAgIC8vIFdoZW4gYSBuZXcgbWVhc3VyZW1lbnQgaXMgYWRkZWQsIHJldHJpZXZlIHRoZSBjdXJyZW50IHRvb2wgc3RhdGVcbiAgICAgIGNvbnN0IHRvb2xTdGF0ZU1hbmFnZXIgPSBjb3JuZXJzdG9uZVRvb2xzLmdsb2JhbEltYWdlSWRTcGVjaWZpY1Rvb2xTdGF0ZU1hbmFnZXI7XG4gICAgICBjb25zdCB0b29sU3RhdGUgPSB0b29sU3RhdGVNYW5hZ2VyLnNhdmVUb29sU3RhdGUoKTtcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgaW1hZ2VzICh0b29sU3RhdGUgaXMga2V5ZWQgYnkgaW1hZ2VJZClcbiAgICAgIE9iamVjdC5rZXlzKHRvb2xTdGF0ZSkuZm9yRWFjaChpbWFnZUlkID0+IHtcbiAgICAgICAgLy8gRGVsZXRlIGFsbCBsZW5ndGggbWVhc3VyZW1lbnRzIG9uIGltYWdlcyB0aGF0IGFyZSBub3QgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgaW1hZ2VcbiAgICAgICAgaWYgKGltYWdlSWQgIT09IGN1cnJlbnRJbWFnZUlkKSB7XG4gICAgICAgICAgZGVsZXRlIHRvb2xTdGF0ZVtpbWFnZUlkXVt0b29sVHlwZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXRyaWV2ZSBhbGwgb2YgdGhlIGxlbmd0aCBtZWFzdXJlbWVudHMgb24gdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgIGNvbnN0IGxlbmd0aE1lYXN1cmVtZW50cyA9IHRvb2xTdGF0ZVtjdXJyZW50SW1hZ2VJZF1bdG9vbFR5cGVdLmRhdGE7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBsZW5ndGggbWVhc3VyZW1lbnQsIHJlbW92ZSB0aGUgb2xkZXN0IG9uZVxuICAgICAgaWYgKGxlbmd0aE1lYXN1cmVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxlbmd0aE1lYXN1cmVtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgc29tZSB2aWV3cG9ydCBkZXRhaWxzIHRvIHRoZSBsZW5ndGggbWVhc3VyZW1lbnQgZGF0YVxuICAgICAgbGVuZ3RoTWVhc3VyZW1lbnRzWzBdLndpbmRvd1dpZHRoID0gdmlld3BvcnQudm9pLndpbmRvd1dpZHRoO1xuICAgICAgbGVuZ3RoTWVhc3VyZW1lbnRzWzBdLndpbmRvd0NlbnRlciA9IHZpZXdwb3J0LnZvaS53aW5kb3dDZW50ZXI7XG4gICAgICBsZW5ndGhNZWFzdXJlbWVudHNbMF0uc2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICAgIGxlbmd0aE1lYXN1cmVtZW50c1swXS50cmFuc2xhdGlvbiA9IHZpZXdwb3J0LnRyYW5zbGF0aW9uO1xuXG4gICAgICAvLyBSZS1zYXZlIHRoaXMgZGF0YSBpbnRvIHRoZSB0b29sU3RhdGUgb2JqZWN0XG4gICAgICB0b29sU3RhdGVbY3VycmVudEltYWdlSWRdW3Rvb2xUeXBlXS5kYXRhID0gbGVuZ3RoTWVhc3VyZW1lbnRzO1xuXG4gICAgICAvLyBSZXN0b3JlIHRvb2xTdGF0ZSBpbnRvIHRoZSB0b29sU3RhdGVNYW5hZ2VyXG4gICAgICB0b29sU3RhdGVNYW5hZ2VyLnJlc3RvcmVUb29sU3RhdGUodG9vbFN0YXRlKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBpbWFnZVxuICAgICAgY29ybmVyc3RvbmUudXBkYXRlSW1hZ2UoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvcm5lcnN0b25ldG9vbHNtZWFzdXJlbWVudGFkZGVkJywgaGFuZGxlTWVhc3VyZW1lbnRBZGRlZCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Nvcm5lcnN0b25ldG9vbHNtZWFzdXJlbWVudGFkZGVkJywgaGFuZGxlTWVhc3VyZW1lbnRBZGRlZCk7XG4gIH0sXG5cbiAgaW5pdFRvb2xzKGltYWdlSWRzKSB7XG4gICAgY29ybmVyc3RvbmVUb29scy5tb3VzZUlucHV0LmVuYWJsZSh0aGlzLmVsZW1lbnQpO1xuICAgIGNvcm5lcnN0b25lVG9vbHMudG91Y2hJbnB1dC5lbmFibGUodGhpcy5lbGVtZW50KTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLm1vdXNlV2hlZWxJbnB1dC5lbmFibGUodGhpcy5lbGVtZW50KTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLmtleWJvYXJkSW5wdXQuZW5hYmxlKHRoaXMuZWxlbWVudCk7XG5cbiAgICB0aGlzLmluaXRJbnRlcmFjdGlvblRvb2xzKCk7XG5cbiAgICAvLyBJZiBhIHByZXZpb3VzbHkgYWN0aXZlIHRvb2wgZXhpc3RzLCByZS1lbmFibGUgaXQuXG4gICAgLy8gSWYgbm90LCB1c2Ugd3d3Y1xuICAgIGNvbnN0IHRvb2xUb0FjdGl2YXRlID0gdGhpcy5hY3RpdmUgfHwgJ3d3d2MnO1xuICAgIHRoaXMudG9nZ2xlVG9vbCh0b29sVG9BY3RpdmF0ZSk7XG5cbiAgICAvLyBSZW1vdmUgdGhlICdhY3RpdmUnIGhpZ2hsaWdodCBmcm9tIHRoZSBvdGhlciB0b29sc1xuICAgICQoYCR7dGhpcy50b29sc1NlbGVjdG9yfSAuYWN0aXZlYCkucmVtb3ZlQ2xhc3MoJy5hY3RpdmUnKTtcblxuICAgIC8vIEFkZCBpdCB0byBvdXIgZGVzaXJlZCB0b29sXG4gICAgJChgJHt0aGlzLnRvb2xzU2VsZWN0b3J9IGRpdltkYXRhLXRvb2w9JHt0b29sVG9BY3RpdmF0ZX1dYCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgdGhpcy5hdHRhY2hFdmVudHMoKTtcbiAgfVxufTtcbiJdfQ==
},{"./debounce":29,"cornerstone-tools":4}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var dicomParser = _interopRequireWildcard(require("dicom-parser"));

var cornerstone = _interopRequireWildcard(require("cornerstone-core"));

var cornerstoneMath = _interopRequireWildcard(require("cornerstone-math"));

var cornerstoneWADOImageLoader = _interopRequireWildcard(require("cornerstone-wado-image-loader"));

var cornerstoneTools = _interopRequireWildcard(require("cornerstone-tools"));

var _hammerjs = _interopRequireDefault(require("hammerjs"));

var _files = _interopRequireDefault(require("./files.js"));

var _tools = _interopRequireDefault(require("./tools.js"));

var _commands = _interopRequireDefault(require("./commands.js"));

var _menu = _interopRequireDefault(require("../menu/menu.js"));

var _debounce = _interopRequireDefault(require("./debounce.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

cornerstoneTools.external.cornerstone = cornerstone;
cornerstoneTools.external.Hammer = _hammerjs.default;
cornerstoneTools.external.cornerstoneMath = cornerstoneMath;
cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
cornerstoneWADOImageLoader.external.dicomParser = dicomParser;
var config = {
  maxWebWorkers: navigator.hardwareConcurrency || 1,
  startWebWorkersOnDemand: true,
  webWorkerPath: 'dist/cornerstoneWADOImageLoaderWebWorker.min.js',
  webWorkerTaskPaths: [],
  taskConfiguration: {
    decodeTask: {
      loadCodecsOnStartup: true,
      initializeCodecsOnStartup: false,
      codecsPath: 'cornerstoneWADOImageLoaderCodecs.min.js',
      usePDFJS: false,
      strict: false
    }
  }
};
var IMAGE_LOADED_EVENT = 'cornerstoneimageloaded';
var _default = {
  $window: $(window),
  $viewer: $('.viewer-wrapper'),
  $overlay: $('.loading-overlay'),
  $loadingText: $('.loading-overlay .content .submit-text'),
  numImagesLoaded: 0,
  getNextCase: function getNextCase() {
    var _this = this;

    // Purge the old image cache, we don't expect to ever load the same case again
    cornerstone.imageCache.purgeCache(); // TODO: Check this. Not sure this is necessary, actually, since things should be decached anyway

    cornerstoneWADOImageLoader.wadouri.dataSetCacheManager.purge(); // Clear any old requests in the request pool

    cornerstoneTools.requestPoolManager.clearRequestStack('interaction');
    cornerstoneTools.requestPoolManager.clearRequestStack('prefetch'); // TODO: Cancel all ongoing requests
    // Remove all tool data in the tool state manager

    cornerstoneTools.globalImageIdSpecificToolStateManager.restoreToolState({});
    return new Promise(function (resolve, reject) {
      var enabledElement = cornerstone.getEnabledElement(_this.element);

      _this.$loadingText.text('Retrieving case metadata...');

      _files.default.getCaseImages().then(function (brokenImageIds) {
        var imageIds = brokenImageIds.map(function (imageId) {
          return imageId.replace('wadouris://', 'wadouri://');
        });

        _this.$loadingText.text('Loading images...');

        console.time('Loading All Images');
        var loadingProgress = $('#loading-progress');
        var numImagesLoaded = 0;

        function handleImageLoaded() {
          numImagesLoaded += 1;
          var imagesLeft = imageIds.length - numImagesLoaded;
          loadingProgress.text("".concat(imagesLeft, " images requested"));

          if (numImagesLoaded === imageIds.length) {
            console.timeEnd('Loading All Images');
            loadingProgress.text('');
          }
        }

        cornerstone.events.removeEventListener(IMAGE_LOADED_EVENT, handleImageLoaded);
        cornerstone.events.addEventListener(IMAGE_LOADED_EVENT, handleImageLoaded);

        _tools.default.initStackTool(imageIds);

        var bottomRight = $('.viewport #mrbottomright');
        var imageIndex = 1;
        bottomRight.text("Image: ".concat(imageIndex, "/").concat(imageIds.length));
        var currentViewport = cornerstone.getViewport(_this.element);
        cornerstone.loadAndCacheImage(imageIds[0]).then(function (image) {
          resolve(); // Set the default viewport parameters
          // We need the new scale and translation parameters so the image fits properly

          var viewport = cornerstone.getDefaultViewport(enabledElement.canvas, image); // e.g. lung window
          //viewport.voi.windowWidth = 1500;
          //viewport.voi.windowCenter = -300;
          // Retain current window width and center

          if (currentViewport) {
            viewport.voi.windowWidth = currentViewport.voi.windowWidth;
            viewport.voi.windowCenter = currentViewport.voi.windowCenter;
          }

          cornerstone.displayImage(_this.element, image, viewport);

          _tools.default.initTools(imageIds);

          _this.$loadingText.text('');
        }, reject);
      }, reject);
    });
  },
  initViewer: function initViewer() {
    var _this2 = this;

    this.$overlay.removeClass('invisible').addClass('loading');
    this.$loadingText.text('Initializing Viewer');
    this.element = $('#cornerstoneViewport')[0];
    $(document.body).css({
      position: 'fixed',
      overflow: 'hidden'
    });

    _menu.default.init();

    this.$viewer.removeClass('invisible');
    _tools.default.element = this.element;
    _commands.default.element = this.element;
    _menu.default.element = this.element;

    _commands.default.initCommands();

    var debounceCornerstoneResize = (0, _debounce.default)(function () {
      return cornerstone.resize(_this2.element, true);
    }, 300);
    this.$window.off('resize', debounceCornerstoneResize);
    this.$window.on('resize', debounceCornerstoneResize);
    cornerstone.enable(this.element); // Listen for changes to the viewport so we can update the text overlays in the corner

    var bottomLeft = $('.viewport #mrbottomrightWWWC');

    function onImageRendered(e) {
      var viewport = e.detail.viewport;
      bottomLeft.text("WW/WC: " + Math.round(viewport.voi.windowWidth) + "/" + Math.round(viewport.voi.windowCenter));
    }

    ;
    this.element.removeEventListener('cornerstoneimagerendered', onImageRendered);
    this.element.addEventListener('cornerstoneimagerendered', onImageRendered);
    var bottomRight = $('.viewport #mrbottomrightImageIndex');

    function onStackScroll(e) {
      var element = e.target;
      var stack = cornerstoneTools.getToolState(element, 'stack');
      var stackData = stack.data[0];
      var imageIndex = stackData.currentImageIdIndex + 1;
      bottomRight.text("Image: ".concat(imageIndex, "/").concat(stackData.imageIds.length));
    }

    ;
    this.element.removeEventListener('cornerstonestackscroll', onStackScroll);
    this.element.addEventListener('cornerstonestackscroll', onStackScroll);
    var loadHandlerTimeout;
    var loadIndicatorDelay = 25;
    var loadIndicator = $('#loadingIndicator');

    var startLoadingHandler = function startLoadingHandler(element) {
      clearTimeout(loadHandlerTimeout);
      loadHandlerTimeout = setTimeout(function () {
        loadIndicator.css('display', 'block');
      }, loadIndicatorDelay);
    };

    var doneLoadingHandler = function doneLoadingHandler(element) {
      clearTimeout(loadHandlerTimeout);
      loadIndicator.css('display', 'none');
    };

    cornerstoneTools.loadHandlerManager.setStartLoadHandler(startLoadingHandler);
    cornerstoneTools.loadHandlerManager.setEndLoadHandler(doneLoadingHandler); // currentSeriesIndex = 0;//a hack to get series in order

    this.getNextCase().then(function () {
      _this2.$overlay.removeClass('loading').addClass('invisible');
    });
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZpZXdlci5qcyJdLCJuYW1lcyI6WyJjb3JuZXJzdG9uZVRvb2xzIiwiZXh0ZXJuYWwiLCJjb3JuZXJzdG9uZSIsIkhhbW1lciIsImNvcm5lcnN0b25lTWF0aCIsImNvcm5lcnN0b25lV0FET0ltYWdlTG9hZGVyIiwiZGljb21QYXJzZXIiLCJjb25maWciLCJtYXhXZWJXb3JrZXJzIiwibmF2aWdhdG9yIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsInN0YXJ0V2ViV29ya2Vyc09uRGVtYW5kIiwid2ViV29ya2VyUGF0aCIsIndlYldvcmtlclRhc2tQYXRocyIsInRhc2tDb25maWd1cmF0aW9uIiwiZGVjb2RlVGFzayIsImxvYWRDb2RlY3NPblN0YXJ0dXAiLCJpbml0aWFsaXplQ29kZWNzT25TdGFydHVwIiwiY29kZWNzUGF0aCIsInVzZVBERkpTIiwic3RyaWN0IiwiSU1BR0VfTE9BREVEX0VWRU5UIiwiJHdpbmRvdyIsIiQiLCJ3aW5kb3ciLCIkdmlld2VyIiwiJG92ZXJsYXkiLCIkbG9hZGluZ1RleHQiLCJudW1JbWFnZXNMb2FkZWQiLCJnZXROZXh0Q2FzZSIsImltYWdlQ2FjaGUiLCJwdXJnZUNhY2hlIiwid2Fkb3VyaSIsImRhdGFTZXRDYWNoZU1hbmFnZXIiLCJwdXJnZSIsInJlcXVlc3RQb29sTWFuYWdlciIsImNsZWFyUmVxdWVzdFN0YWNrIiwiZ2xvYmFsSW1hZ2VJZFNwZWNpZmljVG9vbFN0YXRlTWFuYWdlciIsInJlc3RvcmVUb29sU3RhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVuYWJsZWRFbGVtZW50IiwiZ2V0RW5hYmxlZEVsZW1lbnQiLCJlbGVtZW50IiwidGV4dCIsIkZpbGVzIiwiZ2V0Q2FzZUltYWdlcyIsInRoZW4iLCJicm9rZW5JbWFnZUlkcyIsImltYWdlSWRzIiwibWFwIiwiaW1hZ2VJZCIsInJlcGxhY2UiLCJjb25zb2xlIiwidGltZSIsImxvYWRpbmdQcm9ncmVzcyIsImhhbmRsZUltYWdlTG9hZGVkIiwiaW1hZ2VzTGVmdCIsImxlbmd0aCIsInRpbWVFbmQiLCJldmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIlRvb2xzIiwiaW5pdFN0YWNrVG9vbCIsImJvdHRvbVJpZ2h0IiwiaW1hZ2VJbmRleCIsImN1cnJlbnRWaWV3cG9ydCIsImdldFZpZXdwb3J0IiwibG9hZEFuZENhY2hlSW1hZ2UiLCJpbWFnZSIsInZpZXdwb3J0IiwiZ2V0RGVmYXVsdFZpZXdwb3J0IiwiY2FudmFzIiwidm9pIiwid2luZG93V2lkdGgiLCJ3aW5kb3dDZW50ZXIiLCJkaXNwbGF5SW1hZ2UiLCJpbml0VG9vbHMiLCJpbml0Vmlld2VyIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsImRvY3VtZW50IiwiYm9keSIsImNzcyIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJNZW51IiwiaW5pdCIsIkNvbW1hbmRzIiwiaW5pdENvbW1hbmRzIiwiZGVib3VuY2VDb3JuZXJzdG9uZVJlc2l6ZSIsInJlc2l6ZSIsIm9mZiIsIm9uIiwiZW5hYmxlIiwiYm90dG9tTGVmdCIsIm9uSW1hZ2VSZW5kZXJlZCIsImUiLCJkZXRhaWwiLCJNYXRoIiwicm91bmQiLCJvblN0YWNrU2Nyb2xsIiwidGFyZ2V0Iiwic3RhY2siLCJnZXRUb29sU3RhdGUiLCJzdGFja0RhdGEiLCJkYXRhIiwiY3VycmVudEltYWdlSWRJbmRleCIsImxvYWRIYW5kbGVyVGltZW91dCIsImxvYWRJbmRpY2F0b3JEZWxheSIsImxvYWRJbmRpY2F0b3IiLCJzdGFydExvYWRpbmdIYW5kbGVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImRvbmVMb2FkaW5nSGFuZGxlciIsImxvYWRIYW5kbGVyTWFuYWdlciIsInNldFN0YXJ0TG9hZEhhbmRsZXIiLCJzZXRFbmRMb2FkSGFuZGxlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQUEsZ0JBQWdCLENBQUNDLFFBQWpCLENBQTBCQyxXQUExQixHQUF3Q0EsV0FBeEM7QUFDQUYsZ0JBQWdCLENBQUNDLFFBQWpCLENBQTBCRSxNQUExQixHQUFtQ0EsaUJBQW5DO0FBQ0FILGdCQUFnQixDQUFDQyxRQUFqQixDQUEwQkcsZUFBMUIsR0FBNENBLGVBQTVDO0FBRUFDLDBCQUEwQixDQUFDSixRQUEzQixDQUFvQ0MsV0FBcEMsR0FBa0RBLFdBQWxEO0FBQ0FHLDBCQUEwQixDQUFDSixRQUEzQixDQUFvQ0ssV0FBcEMsR0FBa0RBLFdBQWxEO0FBRUEsSUFBTUMsTUFBTSxHQUFHO0FBQ2JDLEVBQUFBLGFBQWEsRUFBRUMsU0FBUyxDQUFDQyxtQkFBVixJQUFpQyxDQURuQztBQUViQyxFQUFBQSx1QkFBdUIsRUFBRSxJQUZaO0FBR2JDLEVBQUFBLGFBQWEsRUFBRSxpREFIRjtBQUliQyxFQUFBQSxrQkFBa0IsRUFBRSxFQUpQO0FBS2JDLEVBQUFBLGlCQUFpQixFQUFFO0FBQ2pCQyxJQUFBQSxVQUFVLEVBQUU7QUFDVkMsTUFBQUEsbUJBQW1CLEVBQUUsSUFEWDtBQUVWQyxNQUFBQSx5QkFBeUIsRUFBRSxLQUZqQjtBQUdWQyxNQUFBQSxVQUFVLEVBQUUseUNBSEY7QUFJVkMsTUFBQUEsUUFBUSxFQUFFLEtBSkE7QUFLVkMsTUFBQUEsTUFBTSxFQUFFO0FBTEU7QUFESztBQUxOLENBQWY7QUFnQkEsSUFBTUMsa0JBQWtCLEdBQUcsd0JBQTNCO2VBRWU7QUFDYkMsRUFBQUEsT0FBTyxFQUFFQyxDQUFDLENBQUNDLE1BQUQsQ0FERztBQUViQyxFQUFBQSxPQUFPLEVBQUVGLENBQUMsQ0FBQyxpQkFBRCxDQUZHO0FBR2JHLEVBQUFBLFFBQVEsRUFBRUgsQ0FBQyxDQUFDLGtCQUFELENBSEU7QUFJYkksRUFBQUEsWUFBWSxFQUFFSixDQUFDLENBQUMsd0NBQUQsQ0FKRjtBQUtiSyxFQUFBQSxlQUFlLEVBQUUsQ0FMSjtBQU1iQyxFQUFBQSxXQU5hLHlCQU1DO0FBQUE7O0FBQ1o7QUFDQTNCLElBQUFBLFdBQVcsQ0FBQzRCLFVBQVosQ0FBdUJDLFVBQXZCLEdBRlksQ0FJWjs7QUFDQTFCLElBQUFBLDBCQUEwQixDQUFDMkIsT0FBM0IsQ0FBbUNDLG1CQUFuQyxDQUF1REMsS0FBdkQsR0FMWSxDQU9aOztBQUNBbEMsSUFBQUEsZ0JBQWdCLENBQUNtQyxrQkFBakIsQ0FBb0NDLGlCQUFwQyxDQUFzRCxhQUF0RDtBQUNBcEMsSUFBQUEsZ0JBQWdCLENBQUNtQyxrQkFBakIsQ0FBb0NDLGlCQUFwQyxDQUFzRCxVQUF0RCxFQVRZLENBV1o7QUFFQTs7QUFDQXBDLElBQUFBLGdCQUFnQixDQUFDcUMscUNBQWpCLENBQXVEQyxnQkFBdkQsQ0FBd0UsRUFBeEU7QUFFQSxXQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdEMsVUFBTUMsY0FBYyxHQUFHeEMsV0FBVyxDQUFDeUMsaUJBQVosQ0FBOEIsS0FBSSxDQUFDQyxPQUFuQyxDQUF2Qjs7QUFFQSxNQUFBLEtBQUksQ0FBQ2pCLFlBQUwsQ0FBa0JrQixJQUFsQixDQUF1Qiw2QkFBdkI7O0FBQ0FDLHFCQUFNQyxhQUFOLEdBQXNCQyxJQUF0QixDQUEyQixVQUFDQyxjQUFELEVBQW9CO0FBQzdDLFlBQU1DLFFBQVEsR0FBR0QsY0FBYyxDQUFDRSxHQUFmLENBQW1CLFVBQUFDLE9BQU8sRUFBSTtBQUM3QyxpQkFBT0EsT0FBTyxDQUFDQyxPQUFSLENBQWdCLGFBQWhCLEVBQStCLFlBQS9CLENBQVA7QUFDRCxTQUZnQixDQUFqQjs7QUFJQSxRQUFBLEtBQUksQ0FBQzFCLFlBQUwsQ0FBa0JrQixJQUFsQixDQUF1QixtQkFBdkI7O0FBQ0FTLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLG9CQUFiO0FBRUEsWUFBTUMsZUFBZSxHQUFHakMsQ0FBQyxDQUFDLG1CQUFELENBQXpCO0FBQ0EsWUFBSUssZUFBZSxHQUFHLENBQXRCOztBQUVBLGlCQUFTNkIsaUJBQVQsR0FBNkI7QUFDM0I3QixVQUFBQSxlQUFlLElBQUksQ0FBbkI7QUFDQSxjQUFNOEIsVUFBVSxHQUFHUixRQUFRLENBQUNTLE1BQVQsR0FBa0IvQixlQUFyQztBQUNBNEIsVUFBQUEsZUFBZSxDQUFDWCxJQUFoQixXQUF3QmEsVUFBeEI7O0FBQ0EsY0FBSTlCLGVBQWUsS0FBS3NCLFFBQVEsQ0FBQ1MsTUFBakMsRUFBeUM7QUFDdkNMLFlBQUFBLE9BQU8sQ0FBQ00sT0FBUixDQUFnQixvQkFBaEI7QUFDQUosWUFBQUEsZUFBZSxDQUFDWCxJQUFoQixDQUFxQixFQUFyQjtBQUNEO0FBQ0Y7O0FBRUQzQyxRQUFBQSxXQUFXLENBQUMyRCxNQUFaLENBQW1CQyxtQkFBbkIsQ0FBdUN6QyxrQkFBdkMsRUFBMkRvQyxpQkFBM0Q7QUFDQXZELFFBQUFBLFdBQVcsQ0FBQzJELE1BQVosQ0FBbUJFLGdCQUFuQixDQUFvQzFDLGtCQUFwQyxFQUF3RG9DLGlCQUF4RDs7QUFFQU8sdUJBQU1DLGFBQU4sQ0FBb0JmLFFBQXBCOztBQUVBLFlBQU1nQixXQUFXLEdBQUczQyxDQUFDLENBQUMsMEJBQUQsQ0FBckI7QUFDQSxZQUFNNEMsVUFBVSxHQUFHLENBQW5CO0FBQ0FELFFBQUFBLFdBQVcsQ0FBQ3JCLElBQVosa0JBQTJCc0IsVUFBM0IsY0FBeUNqQixRQUFRLENBQUNTLE1BQWxEO0FBRUEsWUFBTVMsZUFBZSxHQUFHbEUsV0FBVyxDQUFDbUUsV0FBWixDQUF3QixLQUFJLENBQUN6QixPQUE3QixDQUF4QjtBQUVBMUMsUUFBQUEsV0FBVyxDQUFDb0UsaUJBQVosQ0FBOEJwQixRQUFRLENBQUMsQ0FBRCxDQUF0QyxFQUEyQ0YsSUFBM0MsQ0FBZ0QsVUFBQ3VCLEtBQUQsRUFBVztBQUN6RC9CLFVBQUFBLE9BQU8sR0FEa0QsQ0FHekQ7QUFDQTs7QUFDQSxjQUFNZ0MsUUFBUSxHQUFHdEUsV0FBVyxDQUFDdUUsa0JBQVosQ0FBK0IvQixjQUFjLENBQUNnQyxNQUE5QyxFQUFzREgsS0FBdEQsQ0FBakIsQ0FMeUQsQ0FNekQ7QUFDQTtBQUNBO0FBRUE7O0FBQ0EsY0FBSUgsZUFBSixFQUFxQjtBQUNuQkksWUFBQUEsUUFBUSxDQUFDRyxHQUFULENBQWFDLFdBQWIsR0FBMkJSLGVBQWUsQ0FBQ08sR0FBaEIsQ0FBb0JDLFdBQS9DO0FBQ0FKLFlBQUFBLFFBQVEsQ0FBQ0csR0FBVCxDQUFhRSxZQUFiLEdBQTRCVCxlQUFlLENBQUNPLEdBQWhCLENBQW9CRSxZQUFoRDtBQUNEOztBQUVEM0UsVUFBQUEsV0FBVyxDQUFDNEUsWUFBWixDQUF5QixLQUFJLENBQUNsQyxPQUE5QixFQUF1QzJCLEtBQXZDLEVBQThDQyxRQUE5Qzs7QUFDQVIseUJBQU1lLFNBQU4sQ0FBZ0I3QixRQUFoQjs7QUFFQSxVQUFBLEtBQUksQ0FBQ3ZCLFlBQUwsQ0FBa0JrQixJQUFsQixDQUF1QixFQUF2QjtBQUNELFNBcEJELEVBb0JHSixNQXBCSDtBQXFCRCxPQXJERCxFQXFER0EsTUFyREg7QUFzREQsS0ExRE0sQ0FBUDtBQTJERCxHQWpGWTtBQW1GYnVDLEVBQUFBLFVBbkZhLHdCQW1GQTtBQUFBOztBQUNYLFNBQUt0RCxRQUFMLENBQWN1RCxXQUFkLENBQTBCLFdBQTFCLEVBQXVDQyxRQUF2QyxDQUFnRCxTQUFoRDtBQUNBLFNBQUt2RCxZQUFMLENBQWtCa0IsSUFBbEIsQ0FBdUIscUJBQXZCO0FBQ0EsU0FBS0QsT0FBTCxHQUFlckIsQ0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEIsQ0FBMUIsQ0FBZjtBQUVBQSxJQUFBQSxDQUFDLENBQUM0RCxRQUFRLENBQUNDLElBQVYsQ0FBRCxDQUFpQkMsR0FBakIsQ0FBcUI7QUFDbkJDLE1BQUFBLFFBQVEsRUFBRSxPQURTO0FBRW5CQyxNQUFBQSxRQUFRLEVBQUU7QUFGUyxLQUFyQjs7QUFLQUMsa0JBQUtDLElBQUw7O0FBRUEsU0FBS2hFLE9BQUwsQ0FBYXdELFdBQWIsQ0FBeUIsV0FBekI7QUFFQWpCLG1CQUFNcEIsT0FBTixHQUFnQixLQUFLQSxPQUFyQjtBQUNBOEMsc0JBQVM5QyxPQUFULEdBQW1CLEtBQUtBLE9BQXhCO0FBQ0E0QyxrQkFBSzVDLE9BQUwsR0FBZSxLQUFLQSxPQUFwQjs7QUFFQThDLHNCQUFTQyxZQUFUOztBQUVBLFFBQU1DLHlCQUF5QixHQUFHLHVCQUFTO0FBQUEsYUFBTTFGLFdBQVcsQ0FBQzJGLE1BQVosQ0FBbUIsTUFBSSxDQUFDakQsT0FBeEIsRUFBaUMsSUFBakMsQ0FBTjtBQUFBLEtBQVQsRUFBdUQsR0FBdkQsQ0FBbEM7QUFFQSxTQUFLdEIsT0FBTCxDQUFhd0UsR0FBYixDQUFpQixRQUFqQixFQUEyQkYseUJBQTNCO0FBQ0EsU0FBS3RFLE9BQUwsQ0FBYXlFLEVBQWIsQ0FBZ0IsUUFBaEIsRUFBMEJILHlCQUExQjtBQUVBMUYsSUFBQUEsV0FBVyxDQUFDOEYsTUFBWixDQUFtQixLQUFLcEQsT0FBeEIsRUF6QlcsQ0EyQlg7O0FBQ0EsUUFBTXFELFVBQVUsR0FBRzFFLENBQUMsQ0FBQyw4QkFBRCxDQUFwQjs7QUFDQSxhQUFTMkUsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEI7QUFDeEIsVUFBTTNCLFFBQVEsR0FBRzJCLENBQUMsQ0FBQ0MsTUFBRixDQUFTNUIsUUFBMUI7QUFDQXlCLE1BQUFBLFVBQVUsQ0FBQ3BELElBQVgsQ0FBZ0IsWUFBWXdELElBQUksQ0FBQ0MsS0FBTCxDQUFXOUIsUUFBUSxDQUFDRyxHQUFULENBQWFDLFdBQXhCLENBQVosR0FBbUQsR0FBbkQsR0FBeUR5QixJQUFJLENBQUNDLEtBQUwsQ0FBVzlCLFFBQVEsQ0FBQ0csR0FBVCxDQUFhRSxZQUF4QixDQUF6RTtBQUNIOztBQUFBO0FBRUQsU0FBS2pDLE9BQUwsQ0FBYWtCLG1CQUFiLENBQWlDLDBCQUFqQyxFQUE2RG9DLGVBQTdEO0FBQ0EsU0FBS3RELE9BQUwsQ0FBYW1CLGdCQUFiLENBQThCLDBCQUE5QixFQUEwRG1DLGVBQTFEO0FBRUEsUUFBTWhDLFdBQVcsR0FBRzNDLENBQUMsQ0FBQyxvQ0FBRCxDQUFyQjs7QUFDQSxhQUFTZ0YsYUFBVCxDQUF1QkosQ0FBdkIsRUFBMEI7QUFDeEIsVUFBTXZELE9BQU8sR0FBR3VELENBQUMsQ0FBQ0ssTUFBbEI7QUFDQSxVQUFNQyxLQUFLLEdBQUd6RyxnQkFBZ0IsQ0FBQzBHLFlBQWpCLENBQThCOUQsT0FBOUIsRUFBdUMsT0FBdkMsQ0FBZDtBQUNBLFVBQU0rRCxTQUFTLEdBQUdGLEtBQUssQ0FBQ0csSUFBTixDQUFXLENBQVgsQ0FBbEI7QUFDQSxVQUFNekMsVUFBVSxHQUFHd0MsU0FBUyxDQUFDRSxtQkFBVixHQUFnQyxDQUFuRDtBQUNBM0MsTUFBQUEsV0FBVyxDQUFDckIsSUFBWixrQkFBMkJzQixVQUEzQixjQUF5Q3dDLFNBQVMsQ0FBQ3pELFFBQVYsQ0FBbUJTLE1BQTVEO0FBQ0Q7O0FBQUE7QUFFRCxTQUFLZixPQUFMLENBQWFrQixtQkFBYixDQUFpQyx3QkFBakMsRUFBMkR5QyxhQUEzRDtBQUNBLFNBQUszRCxPQUFMLENBQWFtQixnQkFBYixDQUE4Qix3QkFBOUIsRUFBd0R3QyxhQUF4RDtBQUVBLFFBQUlPLGtCQUFKO0FBQ0EsUUFBTUMsa0JBQWtCLEdBQUcsRUFBM0I7QUFDQSxRQUFNQyxhQUFhLEdBQUd6RixDQUFDLENBQUMsbUJBQUQsQ0FBdkI7O0FBRUEsUUFBTTBGLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0IsQ0FBQXJFLE9BQU8sRUFBSTtBQUNyQ3NFLE1BQUFBLFlBQVksQ0FBQ0osa0JBQUQsQ0FBWjtBQUNBQSxNQUFBQSxrQkFBa0IsR0FBR0ssVUFBVSxDQUFDLFlBQU07QUFDcENILFFBQUFBLGFBQWEsQ0FBQzNCLEdBQWQsQ0FBa0IsU0FBbEIsRUFBNkIsT0FBN0I7QUFDRCxPQUY4QixFQUU1QjBCLGtCQUY0QixDQUEvQjtBQUdELEtBTEQ7O0FBT0EsUUFBTUssa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFBeEUsT0FBTyxFQUFJO0FBQ3BDc0UsTUFBQUEsWUFBWSxDQUFDSixrQkFBRCxDQUFaO0FBQ0FFLE1BQUFBLGFBQWEsQ0FBQzNCLEdBQWQsQ0FBa0IsU0FBbEIsRUFBNkIsTUFBN0I7QUFDRCxLQUhEOztBQUtBckYsSUFBQUEsZ0JBQWdCLENBQUNxSCxrQkFBakIsQ0FBb0NDLG1CQUFwQyxDQUF3REwsbUJBQXhEO0FBQ0FqSCxJQUFBQSxnQkFBZ0IsQ0FBQ3FILGtCQUFqQixDQUFvQ0UsaUJBQXBDLENBQXNESCxrQkFBdEQsRUFsRVcsQ0FvRVg7O0FBQ0EsU0FBS3ZGLFdBQUwsR0FBbUJtQixJQUFuQixDQUF3QixZQUFNO0FBQzVCLE1BQUEsTUFBSSxDQUFDdEIsUUFBTCxDQUFjdUQsV0FBZCxDQUEwQixTQUExQixFQUFxQ0MsUUFBckMsQ0FBOEMsV0FBOUM7QUFDRCxLQUZEO0FBR0Q7QUEzSlksQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGRpY29tUGFyc2VyIGZyb20gJ2RpY29tLXBhcnNlcic7XG5pbXBvcnQgKiBhcyBjb3JuZXJzdG9uZSBmcm9tICdjb3JuZXJzdG9uZS1jb3JlJztcbmltcG9ydCAqIGFzIGNvcm5lcnN0b25lTWF0aCBmcm9tICdjb3JuZXJzdG9uZS1tYXRoJztcbmltcG9ydCAqIGFzIGNvcm5lcnN0b25lV0FET0ltYWdlTG9hZGVyIGZyb20gJ2Nvcm5lcnN0b25lLXdhZG8taW1hZ2UtbG9hZGVyJztcbmltcG9ydCAqIGFzIGNvcm5lcnN0b25lVG9vbHMgZnJvbSAnY29ybmVyc3RvbmUtdG9vbHMnO1xuaW1wb3J0IEhhbW1lciBmcm9tICdoYW1tZXJqcyc7XG5cbmltcG9ydCBGaWxlcyBmcm9tICcuL2ZpbGVzLmpzJztcbmltcG9ydCBUb29scyBmcm9tICcuL3Rvb2xzLmpzJztcbmltcG9ydCBDb21tYW5kcyBmcm9tICcuL2NvbW1hbmRzLmpzJztcbmltcG9ydCBNZW51IGZyb20gJy4uL21lbnUvbWVudS5qcyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5cbmNvcm5lcnN0b25lVG9vbHMuZXh0ZXJuYWwuY29ybmVyc3RvbmUgPSBjb3JuZXJzdG9uZTtcbmNvcm5lcnN0b25lVG9vbHMuZXh0ZXJuYWwuSGFtbWVyID0gSGFtbWVyO1xuY29ybmVyc3RvbmVUb29scy5leHRlcm5hbC5jb3JuZXJzdG9uZU1hdGggPSBjb3JuZXJzdG9uZU1hdGg7XG5cbmNvcm5lcnN0b25lV0FET0ltYWdlTG9hZGVyLmV4dGVybmFsLmNvcm5lcnN0b25lID0gY29ybmVyc3RvbmU7XG5jb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlci5leHRlcm5hbC5kaWNvbVBhcnNlciA9IGRpY29tUGFyc2VyO1xuXG5jb25zdCBjb25maWcgPSB7XG4gIG1heFdlYldvcmtlcnM6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDEsXG4gIHN0YXJ0V2ViV29ya2Vyc09uRGVtYW5kOiB0cnVlLFxuICB3ZWJXb3JrZXJQYXRoOiAnZGlzdC9jb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlcldlYldvcmtlci5taW4uanMnLFxuICB3ZWJXb3JrZXJUYXNrUGF0aHM6IFtdLFxuICB0YXNrQ29uZmlndXJhdGlvbjoge1xuICAgIGRlY29kZVRhc2s6IHtcbiAgICAgIGxvYWRDb2RlY3NPblN0YXJ0dXA6IHRydWUsXG4gICAgICBpbml0aWFsaXplQ29kZWNzT25TdGFydHVwOiBmYWxzZSxcbiAgICAgIGNvZGVjc1BhdGg6ICdjb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlckNvZGVjcy5taW4uanMnLFxuICAgICAgdXNlUERGSlM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IElNQUdFX0xPQURFRF9FVkVOVCA9ICdjb3JuZXJzdG9uZWltYWdlbG9hZGVkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAkd2luZG93OiAkKHdpbmRvdyksXG4gICR2aWV3ZXI6ICQoJy52aWV3ZXItd3JhcHBlcicpLFxuICAkb3ZlcmxheTogJCgnLmxvYWRpbmctb3ZlcmxheScpLFxuICAkbG9hZGluZ1RleHQ6ICQoJy5sb2FkaW5nLW92ZXJsYXkgLmNvbnRlbnQgLnN1Ym1pdC10ZXh0JyksXG4gIG51bUltYWdlc0xvYWRlZDogMCxcbiAgZ2V0TmV4dENhc2UoKSB7XG4gICAgLy8gUHVyZ2UgdGhlIG9sZCBpbWFnZSBjYWNoZSwgd2UgZG9uJ3QgZXhwZWN0IHRvIGV2ZXIgbG9hZCB0aGUgc2FtZSBjYXNlIGFnYWluXG4gICAgY29ybmVyc3RvbmUuaW1hZ2VDYWNoZS5wdXJnZUNhY2hlKCk7XG5cbiAgICAvLyBUT0RPOiBDaGVjayB0aGlzLiBOb3Qgc3VyZSB0aGlzIGlzIG5lY2Vzc2FyeSwgYWN0dWFsbHksIHNpbmNlIHRoaW5ncyBzaG91bGQgYmUgZGVjYWNoZWQgYW55d2F5XG4gICAgY29ybmVyc3RvbmVXQURPSW1hZ2VMb2FkZXIud2Fkb3VyaS5kYXRhU2V0Q2FjaGVNYW5hZ2VyLnB1cmdlKCk7XG5cbiAgICAvLyBDbGVhciBhbnkgb2xkIHJlcXVlc3RzIGluIHRoZSByZXF1ZXN0IHBvb2xcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnJlcXVlc3RQb29sTWFuYWdlci5jbGVhclJlcXVlc3RTdGFjaygnaW50ZXJhY3Rpb24nKTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLnJlcXVlc3RQb29sTWFuYWdlci5jbGVhclJlcXVlc3RTdGFjaygncHJlZmV0Y2gnKTtcblxuICAgIC8vIFRPRE86IENhbmNlbCBhbGwgb25nb2luZyByZXF1ZXN0c1xuXG4gICAgLy8gUmVtb3ZlIGFsbCB0b29sIGRhdGEgaW4gdGhlIHRvb2wgc3RhdGUgbWFuYWdlclxuICAgIGNvcm5lcnN0b25lVG9vbHMuZ2xvYmFsSW1hZ2VJZFNwZWNpZmljVG9vbFN0YXRlTWFuYWdlci5yZXN0b3JlVG9vbFN0YXRlKHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBlbmFibGVkRWxlbWVudCA9IGNvcm5lcnN0b25lLmdldEVuYWJsZWRFbGVtZW50KHRoaXMuZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuJGxvYWRpbmdUZXh0LnRleHQoJ1JldHJpZXZpbmcgY2FzZSBtZXRhZGF0YS4uLicpO1xuICAgICAgRmlsZXMuZ2V0Q2FzZUltYWdlcygpLnRoZW4oKGJyb2tlbkltYWdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGltYWdlSWRzID0gYnJva2VuSW1hZ2VJZHMubWFwKGltYWdlSWQgPT4ge1xuICAgICAgICAgIHJldHVybiBpbWFnZUlkLnJlcGxhY2UoJ3dhZG91cmlzOi8vJywgJ3dhZG91cmk6Ly8nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kbG9hZGluZ1RleHQudGV4dCgnTG9hZGluZyBpbWFnZXMuLi4nKTtcbiAgICAgICAgY29uc29sZS50aW1lKCdMb2FkaW5nIEFsbCBJbWFnZXMnKTtcblxuICAgICAgICBjb25zdCBsb2FkaW5nUHJvZ3Jlc3MgPSAkKCcjbG9hZGluZy1wcm9ncmVzcycpO1xuICAgICAgICBsZXQgbnVtSW1hZ2VzTG9hZGVkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVJbWFnZUxvYWRlZCgpIHtcbiAgICAgICAgICBudW1JbWFnZXNMb2FkZWQgKz0gMTtcbiAgICAgICAgICBjb25zdCBpbWFnZXNMZWZ0ID0gaW1hZ2VJZHMubGVuZ3RoIC0gbnVtSW1hZ2VzTG9hZGVkO1xuICAgICAgICAgIGxvYWRpbmdQcm9ncmVzcy50ZXh0KGAke2ltYWdlc0xlZnR9IGltYWdlcyByZXF1ZXN0ZWRgKTtcbiAgICAgICAgICBpZiAobnVtSW1hZ2VzTG9hZGVkID09PSBpbWFnZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgnTG9hZGluZyBBbGwgSW1hZ2VzJyk7XG4gICAgICAgICAgICBsb2FkaW5nUHJvZ3Jlc3MudGV4dCgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29ybmVyc3RvbmUuZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoSU1BR0VfTE9BREVEX0VWRU5ULCBoYW5kbGVJbWFnZUxvYWRlZCk7XG4gICAgICAgIGNvcm5lcnN0b25lLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKElNQUdFX0xPQURFRF9FVkVOVCwgaGFuZGxlSW1hZ2VMb2FkZWQpO1xuXG4gICAgICAgIFRvb2xzLmluaXRTdGFja1Rvb2woaW1hZ2VJZHMpO1xuXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gJCgnLnZpZXdwb3J0ICNtcmJvdHRvbXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IGltYWdlSW5kZXggPSAxO1xuICAgICAgICBib3R0b21SaWdodC50ZXh0KGBJbWFnZTogJHtpbWFnZUluZGV4fS8ke2ltYWdlSWRzLmxlbmd0aH1gKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Vmlld3BvcnQgPSBjb3JuZXJzdG9uZS5nZXRWaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgIGNvcm5lcnN0b25lLmxvYWRBbmRDYWNoZUltYWdlKGltYWdlSWRzWzBdKS50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcblxuICAgICAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCB2aWV3cG9ydCBwYXJhbWV0ZXJzXG4gICAgICAgICAgLy8gV2UgbmVlZCB0aGUgbmV3IHNjYWxlIGFuZCB0cmFuc2xhdGlvbiBwYXJhbWV0ZXJzIHNvIHRoZSBpbWFnZSBmaXRzIHByb3Blcmx5XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBjb3JuZXJzdG9uZS5nZXREZWZhdWx0Vmlld3BvcnQoZW5hYmxlZEVsZW1lbnQuY2FudmFzLCBpbWFnZSk7XG4gICAgICAgICAgLy8gZS5nLiBsdW5nIHdpbmRvd1xuICAgICAgICAgIC8vdmlld3BvcnQudm9pLndpbmRvd1dpZHRoID0gMTUwMDtcbiAgICAgICAgICAvL3ZpZXdwb3J0LnZvaS53aW5kb3dDZW50ZXIgPSAtMzAwO1xuXG4gICAgICAgICAgLy8gUmV0YWluIGN1cnJlbnQgd2luZG93IHdpZHRoIGFuZCBjZW50ZXJcbiAgICAgICAgICBpZiAoY3VycmVudFZpZXdwb3J0KSB7XG4gICAgICAgICAgICB2aWV3cG9ydC52b2kud2luZG93V2lkdGggPSBjdXJyZW50Vmlld3BvcnQudm9pLndpbmRvd1dpZHRoO1xuICAgICAgICAgICAgdmlld3BvcnQudm9pLndpbmRvd0NlbnRlciA9IGN1cnJlbnRWaWV3cG9ydC52b2kud2luZG93Q2VudGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvcm5lcnN0b25lLmRpc3BsYXlJbWFnZSh0aGlzLmVsZW1lbnQsIGltYWdlLCB2aWV3cG9ydCk7XG4gICAgICAgICAgVG9vbHMuaW5pdFRvb2xzKGltYWdlSWRzKTtcblxuICAgICAgICAgIHRoaXMuJGxvYWRpbmdUZXh0LnRleHQoJycpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSxcblxuICBpbml0Vmlld2VyKCkge1xuICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpLmFkZENsYXNzKCdsb2FkaW5nJyk7XG4gICAgdGhpcy4kbG9hZGluZ1RleHQudGV4dCgnSW5pdGlhbGl6aW5nIFZpZXdlcicpO1xuICAgIHRoaXMuZWxlbWVudCA9ICQoJyNjb3JuZXJzdG9uZVZpZXdwb3J0JylbMF07XG5cbiAgICAkKGRvY3VtZW50LmJvZHkpLmNzcyh7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgIH0pO1xuXG4gICAgTWVudS5pbml0KCk7XG5cbiAgICB0aGlzLiR2aWV3ZXIucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpO1xuXG4gICAgVG9vbHMuZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBDb21tYW5kcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIE1lbnUuZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgIENvbW1hbmRzLmluaXRDb21tYW5kcygpO1xuXG4gICAgY29uc3QgZGVib3VuY2VDb3JuZXJzdG9uZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IGNvcm5lcnN0b25lLnJlc2l6ZSh0aGlzLmVsZW1lbnQsIHRydWUpLCAzMDApO1xuXG4gICAgdGhpcy4kd2luZG93Lm9mZigncmVzaXplJywgZGVib3VuY2VDb3JuZXJzdG9uZVJlc2l6ZSk7XG4gICAgdGhpcy4kd2luZG93Lm9uKCdyZXNpemUnLCBkZWJvdW5jZUNvcm5lcnN0b25lUmVzaXplKTtcblxuICAgIGNvcm5lcnN0b25lLmVuYWJsZSh0aGlzLmVsZW1lbnQpO1xuXG4gICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSB2aWV3cG9ydCBzbyB3ZSBjYW4gdXBkYXRlIHRoZSB0ZXh0IG92ZXJsYXlzIGluIHRoZSBjb3JuZXJcbiAgICBjb25zdCBib3R0b21MZWZ0ID0gJCgnLnZpZXdwb3J0ICNtcmJvdHRvbXJpZ2h0V1dXQycpO1xuICAgIGZ1bmN0aW9uIG9uSW1hZ2VSZW5kZXJlZChlKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZS5kZXRhaWwudmlld3BvcnQ7XG4gICAgICAgIGJvdHRvbUxlZnQudGV4dChcIldXL1dDOiBcIiArIE1hdGgucm91bmQodmlld3BvcnQudm9pLndpbmRvd1dpZHRoKSArIFwiL1wiICsgTWF0aC5yb3VuZCh2aWV3cG9ydC52b2kud2luZG93Q2VudGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb3JuZXJzdG9uZWltYWdlcmVuZGVyZWQnLCBvbkltYWdlUmVuZGVyZWQpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3JuZXJzdG9uZWltYWdlcmVuZGVyZWQnLCBvbkltYWdlUmVuZGVyZWQpO1xuXG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSAkKCcudmlld3BvcnQgI21yYm90dG9tcmlnaHRJbWFnZUluZGV4Jyk7XG4gICAgZnVuY3Rpb24gb25TdGFja1Njcm9sbChlKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICBjb25zdCBzdGFjayA9IGNvcm5lcnN0b25lVG9vbHMuZ2V0VG9vbFN0YXRlKGVsZW1lbnQsICdzdGFjaycpO1xuICAgICAgY29uc3Qgc3RhY2tEYXRhID0gc3RhY2suZGF0YVswXTtcbiAgICAgIGNvbnN0IGltYWdlSW5kZXggPSBzdGFja0RhdGEuY3VycmVudEltYWdlSWRJbmRleCArIDE7XG4gICAgICBib3R0b21SaWdodC50ZXh0KGBJbWFnZTogJHtpbWFnZUluZGV4fS8ke3N0YWNrRGF0YS5pbWFnZUlkcy5sZW5ndGh9YCk7XG4gICAgfTtcblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb3JuZXJzdG9uZXN0YWNrc2Nyb2xsJywgb25TdGFja1Njcm9sbCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Nvcm5lcnN0b25lc3RhY2tzY3JvbGwnLCBvblN0YWNrU2Nyb2xsKTtcblxuICAgIGxldCBsb2FkSGFuZGxlclRpbWVvdXQ7XG4gICAgY29uc3QgbG9hZEluZGljYXRvckRlbGF5ID0gMjU7XG4gICAgY29uc3QgbG9hZEluZGljYXRvciA9ICQoJyNsb2FkaW5nSW5kaWNhdG9yJyk7XG5cbiAgICBjb25zdCBzdGFydExvYWRpbmdIYW5kbGVyID0gZWxlbWVudCA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQobG9hZEhhbmRsZXJUaW1lb3V0KTtcbiAgICAgIGxvYWRIYW5kbGVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2FkSW5kaWNhdG9yLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgfSwgbG9hZEluZGljYXRvckRlbGF5KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZG9uZUxvYWRpbmdIYW5kbGVyID0gZWxlbWVudCA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQobG9hZEhhbmRsZXJUaW1lb3V0KTtcbiAgICAgIGxvYWRJbmRpY2F0b3IuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9O1xuXG4gICAgY29ybmVyc3RvbmVUb29scy5sb2FkSGFuZGxlck1hbmFnZXIuc2V0U3RhcnRMb2FkSGFuZGxlcihzdGFydExvYWRpbmdIYW5kbGVyKTtcbiAgICBjb3JuZXJzdG9uZVRvb2xzLmxvYWRIYW5kbGVyTWFuYWdlci5zZXRFbmRMb2FkSGFuZGxlcihkb25lTG9hZGluZ0hhbmRsZXIpO1xuXG4gICAgLy8gY3VycmVudFNlcmllc0luZGV4ID0gMDsvL2EgaGFjayB0byBnZXQgc2VyaWVzIGluIG9yZGVyXG4gICAgdGhpcy5nZXROZXh0Q2FzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcygnbG9hZGluZycpLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICB9KTtcbiAgfVxufVxuIl19
},{"../menu/menu.js":24,"./commands.js":27,"./debounce.js":29,"./files.js":30,"./tools.js":31,"cornerstone-core":2,"cornerstone-math":3,"cornerstone-tools":4,"cornerstone-wado-image-loader":5,"dicom-parser":6,"hammerjs":8}]},{},[22])